\documentclass{wg21}

\usepackage{xcolor}
\usepackage{soul}
\usepackage{ulem}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{minted}
\usepackage{enumitem}
\usepackage{minted}


\lstdefinestyle{base}{
  language=c++,
  breaklines=false,
  basicstyle=\ttfamily\color{black},
  moredelim=**[is][\color{green!50!black}]{@}{@},
  escapeinside={(*@}{@*)}
}

\newcommand{\cc}[1]{\mintinline{c++}{#1}}
\newminted[cpp]{c++}{}


\title{Range constructor for \tcode{std::span}}
\docnumber{D1394R0}
\audience{LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}


\begin{document}
\maketitle

\section{Abstract}

This paper proposes that \tcode{span} be constructible from any forwarding contiguous range of its value type.
The idea was extracted from P1206. 

\section{Tony tables}
\begin{center}
\begin{tabular}{l|l}
Before & After\\ \hline

\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\footnotesize]{cpp}
std::vector<int> v(42);
std::span foo = v | view::take(3); //ill-formed
\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\footnotesize]{cpp}
std::vector<int> v(42);
std::span<int> foo = v | view::take(3); //valid
\end{minted}
\end{minipage}
\\\\ \hline


\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\footnotesize]{cpp}
std::vector<int> v(42);
std::span foo = v; // ill-valid
std::span bar(v.begin(), 3); // ill-formed
\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\footnotesize]{cpp}
std::vector<int> v(42);
std::span foo = v; // valid
std::span bar(v.begin(), 3); // valid

\end{minted}
\end{minipage}
\\\\ \hline

\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\footnotesize]{cpp}
std::vector<int> get_vector();
void foo(std::experimental::span<int>);
void bar(std::experimental::span<const int>);
bar(get_vector()); //valid
foo(get_vector()); //ill-formed
\end{minted}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{minted}[fontsize=\footnotesize]{cpp}
std::vector<int> get_vector();
void foo(std::experimental::span<int>);
void bar(std::experimental::span<const int>);
bar(get_vector()); //ill-formed
foo(get_vector()); //ill-formed
\end{minted}
\end{minipage}
\\\\ \hline
\end{tabular}
\end{center}


\section{Motivation}

Span is specified to be constructible from \tcode{Container} types.
However, while defined, \tcode{Container} is not a concept and as such \tcode{ContiguousRange} is more expressive.
Furthermore, there exist some non-container ranges that would otherwise be valid ranges to construct span from.
As such span as currently specified fits poorly with the iterators / ranges model of the rest of the standard library. 


\section{Design considerations}

Currently, a \tcode{rvalue-ref Container<T>} binds to \tcode{span<const T>}.
This behavior is surprising, dangerous and fits poorly with the \tcode{forwarding-range} model introduced with ranges.
We therefore propose that span should only be constructible from \tcode{forwarding-range}s.

We propose to specify all constructors currently accepting a container or pointers in terms of \tcode{ContiguousRange} and \tcode{ContiguousIterator}
respectively as well as to add or modify the relevant deduction guides for these constructors.

\section{Future work}

\begin{itemize}
	\item We suggest that both the wording and the implementation of span would greatly benefit from a trait to detect whether a type has a static extent.
Because \tcode{std::extent} equals to 0 for types without static extent, and because 0 is a valid extent for containers, \tcode{std::extent} proved too limited. However we do not propose a solution in the present paper. 
\end{itemize}

\section{Proposed wording}

Change in \textbf{[views.span] 21.7.3}:
\begin{quote}
\begin{codeblock}

 // [span.cons], constructors, copy, and assignment
constexpr span() noexcept;
@\added{template <ContiguousIterator It>}@
@\added{requires ConvertibleTo<remove_reference_t<iter_reference_t<It>>(*)[], ElementType(*)[]>}@
constexpr span( @\removed{pointer ptr}@ @\added{It begin}@, index_type count);
@\removed{constexpr span(pointer first, pointer last);}@
@\added{template <ContiguousIterator It, SizedSentinel<It> End>}@
@\added{requires ConvertibleTo<remove_reference_t<iter_reference_t<It>>(*)[], ElementType(*)[]>}@
@\added{constexpr span(It first, End last);}@

template<size_t N>
constexpr span(element_type (&arr)[N]) noexcept;
template<size_t N>
constexpr span(array<value_type, N>& arr) noexcept;
template<size_t N>
constexpr span(const array<value_type, N>& arr) noexcept;
@\removed{template<class Container>}@
@\removed{constexpr span(Container\& cont);}@
@\removed{template<class Container>}@
@\removed{constexpr span(const Container\& cont);}@
@\added{template <ranges::ContiguousRange R>}@
@\added{requires ranges::SizedRange<R> \&\& \placeholder{forwarding-range}<R> \&\&}@
@\added{ConvertibleTo<remove_reference_t<iter_reference_t<ranges::iterator_t<R>>>(*)[], ElementType(*)[]>}@
@\added{constexpr span(R\&\& r)}@

constexpr span(const span\& other) noexcept = default;
template<class OtherElementType, ptrdiff_t OtherExtent>
constexpr span(const span<OtherElementType, OtherExtent>\& s) noexcept;

...

}


template<class T, size_t N>
span(T (&)[N]) -> span<T, N>;
template<class T, size_t N>
span(array<T, N>&) -> span<T, N>;
template<class T, size_t N>
span(const array<T, N>&) -> span<const T, N>;
@\added{template <ContiguousIterator It, SizedSentinel<It> End>}@
@\added{span(It, End) -> span<remove_reference_t<iter_reference_t<It>>>;}@
@\added{template <ContiguousIterator It, size_t N>}@
@\added{span(It, N) -> span<remove_reference_t<iter_reference_t<It>>>;}@

template<class T, size_t N>
span(const array<T, N>&) -> span<const T, N>;
@\removed{template<class Container>}@
@\removed{constexpr span(Container\& cont);}@
@\removed{template<class Container>}@
@\removed{constexpr span(const Container\& cont);}@
@\removed{constexpr span(const span\& other) noexcept = default;}@
@\added{template<ranges::ContiguousRange>}@
@\added{requires ranges::SizedRange<R> \&\& \placeholder{forwarding-range}<R>}@
@\added{-> span<remove_reference_t<iter_reference_t<ranges::iterator_t<R>>>>;}@

\end{codeblock}
\end{quote}

In 21.7.3.2 [span.cons]

\begin{quote}

	
\begin{itemdecl}
	constexpr span() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\ensures
	\tcode{size() == 0 \&\& data() == nullptr}.
	
	\pnum
	\remarks
	This constructor shall not participate in overload resolution
	unless \tcode{Extent <= 0} is \tcode{true}.
\end{itemdescr}
\begin{removedblock}
\begin{itemdecl}
constexpr span(pointer ptr, index_type count);
\end{itemdecl}
\end{removedblock}
\begin{addedblock}
\begin{itemdecl}
template <ContiguousIterator It>
requires ConvertibleTo<remove_reference_t<iter_reference_t<It>>(*)[], ElementType(*)[]>
constexpr span(It first, index_type count);
\end{itemdecl}
\end{addedblock}
\begin{itemdescr}
	\pnum
	\requires \range{\changed{ptr}{first}}{ \changed{ptr}{first} + count} shall be a valid range.
	If \tcode{extent} is not equal to \tcode{dynamic_extent},
	then \tcode{count} shall be equal to \tcode{extent}.
	
	\pnum
	\effects
	Constructs a \tcode{span} that is a view over the range \range{\changed{ptr}{first} }{\changed{ptr}{first}  + count}.
	
	\pnum
	\ensures
	\tcode{size() == count \&\& data() == \changed{ptr}{\tcode{adressof(*first)}}}.
	
	\pnum
	\throws
	Nothing.
\end{itemdescr}

	
\begin{removedblock}
\begin{itemdecl}
constexpr span(pointer first, pointer last);
\end{itemdecl}
\end{removedblock}
\begin{removedblock}

\begin{itemdescr}
	\pnum
	\requires
	\range{first}{last} shall be a valid range.
	If \tcode{extent} is not equal to \tcode{dynamic_extent},
	then \tcode{last - first} shall be equal to \tcode{extent}.
	
	\pnum
	\effects
	Constructs a span that is a view over the range \range{first}{last}.
	
	\pnum
	\ensures
	\tcode{size() == last - first \&\& data() == first}.
	
	\pnum
	\throws
	Nothing.
\end{itemdescr}
\end{removedblock}

\begin{addedblock}
\begin{itemdecl}
template <ContiguousIterator It, SizedSentinel<It> End>
requires ConvertibleTo<remove_reference_t<iter_reference_t<It>>(*)[], ElementType(*)[]>
constexpr span(It first, End last);
\end{itemdecl}
\end{addedblock}

\begin{addedblock}

\begin{itemdescr}

	\pnum
	\expects
	If \tcode{extent} is not equal to \tcode{dynamic_extent},
	then \tcode{last - first} shall be equal to \tcode{extent}.
	
	\pnum
	\effects
	Constructs a span that is a view over the range \range{first}{last}.
	
	\pnum
	\ensures
	\tcode{size() == last - first \&\& data() ==  \tcode{adressof(*first)}}.
	
	\pnum
	\throws
	Nothing.

\end{itemdescr}
\end{addedblock}

\begin{itemdecl}
template<size_t N> constexpr span(element_type (&arr)[N]) noexcept;
template<size_t N> constexpr span(array<value_type, N>& arr) noexcept;
template<size_t N> constexpr span(const array<value_type, N>& arr) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs a \tcode{span} that is a view over the supplied array.
	
	\pnum
	\ensures
	\tcode{size() == N \&\& data() == data(arr)}.
	
	\pnum
	\remarks
	These constructors shall not participate in overload resolution unless:
	\begin{itemize}
		\item \tcode{extent == dynamic_extent || N == extent} is \tcode{true}, and
		\item \tcode{remove_pointer_t<decltype(data(arr))>(*)[]} is convertible to \tcode{ElementType(*)[]}.
	\end{itemize}
\end{itemdescr}

\begin{removedblock}
\begin{itemdecl}
template<class Container> constexpr span(Container& cont);
template<class Container> constexpr span(const Container& cont);
\end{itemdecl}
\end{removedblock}
\begin{removedblock}
\begin{itemdescr}
	\pnum
	\requires
	\range{data(cont)}{data(cont) + size(cont)} shall be a valid range.
	If \tcode{extent} is not equal to \tcode{dynamic_extent},
	then \tcode{size(cont)} shall be equal to \tcode{extent}.
	
	\pnum
	\effects
	Constructs a \tcode{span} that is a view over the range \range{data(cont)}{data(cont) + size(cont)}.
	
	\pnum
	\ensures
	\tcode{size() == size(cont) \&\& data() == data(cont)}.
	
	\pnum
	\throws
	What and when \tcode{data(cont)} and \tcode{size(cont)} throw.
	
	\pnum
	\remarks
	These constructors shall not participate in overload resolution unless:
	\begin{itemize}
		\item \tcode{Container} is not a specialization of \tcode{span},
		\item \tcode{Container} is not a specialization of \tcode{array},
		\item \tcode{is_array_v<Container>} is \tcode{false},
		\item \tcode{data(cont)} and \tcode{size(cont)} are both well-formed, and
		\item \tcode{remove_pointer_t<decltype(data(cont))>(*)[]} is convertible to \tcode{ElementType(*)[]}.
	\end{itemize}
\end{itemdescr}
\end{removedblock}


\begin{addedblock}
\begin{itemdecl}
template <ranges::ContiguousRange R>
requires ranges::SizedRange<R> && @{\placeholder{forwarding-range}<R>}@ &&
ConvertibleTo<remove_reference_t<iter_reference_t<ranges::iterator_t<R>>>(*)[], ElementType(*)[]>
constexpr span(R&& r)
\end{itemdecl}
\end{addedblock}

\begin{addedblock}
\begin{itemdescr}
	\pnum
	\expects
	If \tcode{extent} is not equal to \tcode{dynamic_extent},
	then \tcode{size(r)} shall be equal to \tcode{extent}.
	
	\pnum
	\effects
	Constructs a \tcode{span} that is a view over the range \tcode{r}.
	
	\pnum
	\ensures
	\tcode{ranges::size() == ranges::size(r) \&\& ranges::data() == ranges::data(r)}.
	
	\pnum
	\throws
	What and when \tcode{ranges::data(r)} and \tcode{ranges::size(r)} throw.
	
	\pnum
	\constraints
	\begin{itemize}
		\item \tcode{R} is not a specialization of \tcode{span},
		\item \tcode{R} is not a specialization of \tcode{array},
		\item \tcode{is_array_v<R>} is \tcode{false},
	\end{itemize}
\end{itemdescr}
\end{addedblock}

\begin{itemdecl}
constexpr span(const span& other) noexcept = default;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\ensures
	\tcode{other.size() == size() \&\& other.data() == data()}.
\end{itemdescr}


\end{quote}


\end{document}