% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{\tcode{size\_hint}: Eagerly reserving memory for not-quite-sized lazy ranges}
\docnumber{P2846R1}
\audience{SG-9, LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle

\section{Abstract}

This proposals adds a \tcode{ranges::size_hint} customization point object which allows \tcode{ranges::to} to
reserve memory for non-sized ranges whose size can be approximated.

\section{Revisions}

\subsection{R1}

When SG-9 reviewed R0, Tim Song pointed out that \tcode{std::vector} and \tcode{std::string} call \tcode{std::distance} in their constructor (rather than calling \tcode{push_back} and reallocating themselves).
This was not mentioned or considered at all in R0. R1 fixes this blattant omission.

If anything this makes the motivation stronger but it opens some interesting design questions.

SG-9 also pointed out that R0, despite being motivated by performance considerations failed to present any benchmarks. Benchmarks are now provided.

SG-9 also suggested that it would be useful for \tcode{sized_range} to subsume \tcode{approximately\_sized\_range}.
This change has been applied.

Add a section on naming.

\section{Motivation}

You should know this proposal is secretly about Unicode.

Consider the string

\tcode{"In C++ ist es schwieriger, sich selbst in den fuß zu schießen."}

Its correct upper-case transformation is

\tcode{"IN C++ IST ES SCHWIERIGER, SICH SELBST IN DEN FUSS ZU SCHIESSEN".}

You will have observed that the transformed string is longer.
2 codepoints longer to be exact. This is because \textbf{ß} capitalizes as \textbf{SS}.

Now consider a hypothetical uppercase_view that transforms Unicode codepoints into their uppercase version.
It might look like this:

\begin{colorblock}
U"In C++ ist es schwieriger, sich selbst in den fuß zu schießen."sv
    | views::uppercase
    | ranges::to<std::u32string>();
\end{colorblock}

We do not have to know anything else about \tcode{views::uppercase} to know that it cannot be a \tcode{sized_range}.

In fact, it cannot be, for the same reason, a \tcode{random_access_range}.  It will be, at best, a \tcode{bidirectional_range}.
This means that in the above example, we cannot reserve memory in advance when constructing the output vector in \tcode{ranges::to}.
So the implementation will
\begin{itemize}
\item for a forward range, call \tcode{distance}, in effect going over the view twice (unless the range is random access, which is never the case in the presence of Unicode algorithms) which for a Unicode algorithm is very expensive.
\item for a non forward range, call \tcode{push_back} in a loop
\end{itemize}

But... only a couple thousand codepoints have a casing that is not their identity and of those only a few hundred might produce more than
one codepoint. That's about 1\% of the total number of allocated codepoints.

Most scripts not derived from Latin (for example CJK characters) do not even have a notion of case.

So the above example is massively pessimized because of a statistically unlikely scenario.

This is not just a problem with upper-casing. All casing transformations in Unicode have the same peculiarity.
It also applies to all forms of Unicode Normalization (normalization can produce output strings that are longer, or shorter than the input)
and text encoding and decoding, especially between UTF forms.

It is not possible to compute the size of the conversion from a string of length \tcode{L} from UTF-32 to UTF-8, but we know it will be at least \tcode{L}.
And for some scripts, including English, it will be equal or very close to \tcode{L}.


We need a way to advertise "This range is about yea big" so that \tcode{ranges::to} and all the ranges constructors added by \paper{P1206R7}
can reduce the number of allocations they perform.

\section{Design}

To that end, we propose:

\begin{itemize}
\item a \tcode{ranges::size_hint} CPO
\item a \tcode{approximately_sized_range} concept that checks whether a range supports \tcode{size_hint}
\item the extension of many existing standard views so that they can forward the \tcode{size_hint} of their adapted view
\end{itemize}

\subsection{\tcode{ranges::size_hint}}

\tcode{ranges::size_hint} is a CPO that calls
\begin{itemize}
    \item \tcode{ranges::size} for sized ranges
    \item the \tcode{size_hint} member function.
    \item the \tcode{size_hint} function found by adl.
\end{itemize}

Like \tcode{ranges::size} we mandate O(1) evaluation of \tcode{size_hint}.
With this design, ranges that are sized are already \tcode{approximately_sized_range}, which avoids some duplication, undue complexity, and confusion.
for example, we don't have to modify existing containers and views whose sized-ness does not depend on another view.

\subsection{Usage}

An implementation of \tcode{uppercase_view} might look like this

\begin{colorblock}
template <input_range V>
class uppercase_view {
    constexpr const V & base() const;
    constexpr auto begin() const;
    constexpr auto end() const;

    constexpr auto size_hint() requires approximately_sized_range<View> {
        return ranges::size_hint(base());
    }
    constexpr auto size_hint() const requires approximately_sized_range<const View> {
        return ranges::size_hint(base());
    }
};
\end{colorblock}

IE, we assume \tcode{uppercase_view} will have approximatively the same size as the underlying range, even if it might be in rare cases slightly more.
Note that \tcode{uppercase_view} would not provide a \tcode{size} method because it cannot determine its exact size.

\subsection{Adapting existing views}

Views that transform elements of their adapted view can just forward the \tcode{size_hint} of their underlying view.
Nothing too complicated there. \tcode{drop}, \tcode{take}, \tcode{adjacent} \tcode{chunk}, \tcode{slide} and \tcode{stride} can also
compute a \tcode{size_hint} the same way they compute their size.

\tcode{join} andf \tcode{split} cannot compute their size in O(1), so they do not provide a \tcode{size_hint}.

\subsubsection{Views with predicate}

\tcode{take_while}, \tcode{drop_while} and \tcode{filter} could, in theory, expose the size of their adapted range.
however, this might lead to huge overallocation so, conservatively, these things do not expose a \tcode{size_hint}.

\subsubsection{\tcode{zip} and \tcode{cartesian_product}}

It would be reasonable for \tcode{zip}'s \tcode{size_hint} to be the smallest \tcode{size_hint} amongst
the adapted ranges that do have a \tcode{size_hint}.
Similarly, it would make sense that the \tcode{size_hint} of \tcode{cartesian_product} would be the product of
the \tcode{size_hint} of the ranges that do have one.

I think the correct way to do that might be to provide 3 overloads:

\begin{colorblock}
constexpr auto size_hint() requires (approximately_sized_range<Views> &&...);
constexpr auto size_hint() const requires (approximately_sized_range<const Views> &&...);
constexpr auto size_hint() const requires (!((approximately_sized_range<Views> || approximately_sized_range<Views>) &&...));
\end{colorblock}

Otherwise, the const and non-const overload could give different results.

As I'm not entirely certain what the best approach is, this paper does not make a change to zip or \tcode{cartesian_product}

\subsection{\tcode{ranges::to}}

\tcode{ranges::to} is sligtly modified to use \tcode{ranges::size_hint} instead of \tcode{ranges::size}.
An implementation can also use \tcode{size_hint} in the various range constructors.
User code could use that feature for similar purposes.


\subsection{\tcode{vector} and \tcode{string} constructors}

\tcode{std::vector} performs a single allocation on construction by calling \tcode{distance} first.
It could only use \tcode{size_hint} on types that are \tcode{Cpp17MoveInsertable} (which is the case for Unicode algorithms), as reallocation would force items to be moved around.
It may affect the performance of vector construction negatively when it is constructed from a forward range that is not sized, but for which calling \tcode{distance} is cheap, and \tcode{size_hint} is off enough that the reallocations are noticeable.

The proposed wording is currently silent on what happens to vector but we have 3 options:

\begin{itemize}
  \item Require implementation to rely on \tcode{size_hint} when constructing a vector from a non-sized range of \tcode{Cpp17MoveInsertable} elements.

        A concern here is that custom allocators can't tell whether elements are move insertable because they are not required to be SFINAE-friendly.
        So, we could either only require calling \tcode{size_hint} for \tcode{std::allocator} only, or it would break \tcode{vector}s of non-movable types using a custom \tcode{allocator}.

        Another solution is to check for \tcode{MoveConstructible} - which would still break the fringe case of types that are \tcode{MoveConstructible} and not \tcode{Cpp17MoveInsertable}.
        But there is consensus in SG-9 that those are fringe edge cases.

  \item Allowing implementations to do so without requiring it.

        Note that whether allocations are performed would be observable through whether the move constructor of each element is called or not (unless the elements are of trivial types (or are otherwise trivially relocatable \paper{P2786R0})). Any effect resulting from a call to \tcode{std::distance} would not be performed.

        SG-9 had a preference for this option.

  \item In the presence of a \tcode{approximately_sized_range}, \tcode{ranges::to} could construct the container using reserve and insertions, instead of forwarding to the container constructor.
        The downside of this approach is that \tcode{ranges::to} would have different performance characteristics than container construction, which seems undesirable, and the optimization could not be applied to other operations such as \tcode{assign_range}/\tcode{insert_range}.
\end{itemize}

\section{Benchmarks}

The following graph shows 2 Unicode normalization algorithms (Upper casing and NFC) for translations of the \href{https://unicode.org/udhr/index.html}{Universal Declaration of Human Rights} in English, Danish, Japanese, and Chinese.
Each such Transformation is performed twice:

\begin{itemize}
\item By reserving the number of elements of the pre-transformation text in the output container, emulating the proposed \tcode{size_hint}
\item By constructing the output container directly without reserve (status quo behavior of \tcode{ranges::to}).
\end{itemize}

The graph shows that, for a forward range, reserving is consistently about twice as fast. This is consistent with the fact the range is traversed twice.

\includegraphics[width=\textwidth]{D2846_bench1.png}

If the input range is non-forward, there is less difference on small datasets:

\includegraphics[width=\textwidth]{D2846_bench2.png}

But as the data gets bigger and the number of allocations increases being able to reserve memory gets more noticeably impactful (performance delta of 5-10\%).

\section{Existing practices and alternatives considered}

Rust has a similar facility \href{https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.size_hint}{in the iterator trait}.

\begin{quoteblock}
\textbf{\tcode{fn size_hint(\&self) -> (usize, Option<usize>)}}


Returns the bounds on the remaining length of the iterator.
Specifically, size_hint() returns a tuple where the first element is the lower bound, and the second element is the upper bound.
The second half of the tuple that is returned is an Option<usize>. A None here means that either there is no known upper bound, or the upper bound is larger than usize.\\

It is not enforced that an iterator implementation yields the declared number of elements. A buggy iterator may yield less than the lower bound or more than the upper bound of elements.
size_hint() is primarily intended to be used for optimizations such as reserving space for the elements of the iterator, but must not be trusted to e.g., omit bounds checks in unsafe code. An incorrect implementation of size_hint() should not lead to memory safety violations.

That said, the implementation should provide a correct estimation, because otherwise, it would be a violation of the trait’s protocol.
\end{quoteblock}

However, that flexibility is not useful in practice:
The upper bound is \href{https://internals.rust-lang.org/t/is-size-hint-1-ever-used/8187?u=scottmcm}{rarely used},
and I'm told that using it in reserved was tried and led to performance regression.
The complex return type seems to also create some confusion for rust users.


\section{Naming}

SG-9 had no strong preferences between the naming of the \tcode{size_hint} function.
The two options considered are \tcode{size_hint} (which is nice because it reflects the fact that it's a function intended as a performance hint)
and \tcode{approximate_size} (which is nice because it reflects the name of the \tcode{approximately_sized_range} concept).
Both options being equally cromulent, we are happy to let LEWG pick their preference.

\section{Wording}

\ednote{Add the macro \tcode{__cpp_lib_ranges_zip} to \tcode{<version>} and \tcode{<ranges>}}
\begin{addedblock}
\begin{codeblock}
    #define __cpp_lib_ranges_zip 2026XX (**placeholder**)
\end{codeblock}
\end{addedblock}

\rSec1[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}
#include <compare>              // see \ref{compare.syn}
#include <initializer_list>     // see \ref{initializer.list.syn}
#include <iterator>             // see \ref{iterator.synopsis}

namespace std::ranges {
inline namespace @\unspec@ {
    // \ref{range.access}, range access
    inline constexpr @\unspec@ begin = @\unspec@;    // freestanding
    inline constexpr @\unspec@ end = @\unspec@;      // freestanding
    inline constexpr @\unspec@ cbegin = @\unspec@;   // freestanding
    inline constexpr @\unspec@ cend = @\unspec@;     // freestanding
    inline constexpr @\unspec@ rbegin = @\unspec@;   // freestanding
    inline constexpr @\unspec@ rend = @\unspec@;     // freestanding
    inline constexpr @\unspec@ crbegin = @\unspec@;  // freestanding
    inline constexpr @\unspec@ crend = @\unspec@;    // freestanding

    inline constexpr @\unspec@ size = @\unspec@;    // freestanding
    @\added{inline constexpr \unspec{}  size_hint = \unspec{};           // freestanding}@
    inline constexpr @\unspec@ ssize = @\unspec@;   // freestanding
    inline constexpr @\unspec@ empty = @\unspec@;   // freestanding
    inline constexpr @\unspec@ data = @\unspec@;    // freestanding
    inline constexpr @\unspec@ cdata = @\unspec@;   // freestanding
}


template<class>
constexpr bool disable_sized_range = false; // freestanding

@\added{template<class T>}@
@\added{concept approximately_sized_range = \seebelow;  // freestanding}@

template<class T>
concept sized_range = @\seebelow@;  // freestanding

template<class T>
constexpr bool enable_view = @\seebelow@;    // freestanding

}
\end{codeblock}

\ednote{Insert after [range.prim.ssize] }

\begin{addedblock}
\rSec2[range.prim.size.hint]{\tcode{ranges::size_hint}}
\indexlibraryglobal{size}%

\pnum
The name \tcode{ranges::size_hint} denotes a customization point
object \iref{customization.point.object}.

\pnum
Given a subexpression \tcode{E} with type \tcode{T},
let \tcode{t} be an lvalue that denotes the reified object for \tcode{E}.
Then:

\begin{itemize}
    \item
    If \tcode{ranges::size(E)} is a valid expression, \tcode{ranges::size_hint(E)} is expression-equivalent to
    \tcode{ranges::size(E)}.

    \item
    Otherwise, if \tcode{auto(t.size_hint())}
    is a valid expression of integer-like type \iref{iterator.concept.winc},
    \tcode{ranges::size_hint(E)} is expression-equivalent to
    \tcode{auto(\brk{}t.size_hint())}.

    \item
    Otherwise, if \tcode{T} is a class or enumeration type and \tcode{auto(size_hint(t))}
    is a valid expression of integer-like type
    where the meaning of \tcode{size_hint} is established as-if by performing
    argument-dependent lookup only \iref{basic.lookup.argdep},
    then \tcode{ranges::size_hint(E)} is expression-equivalent to
    that expression.

    \item
    Otherwise, \tcode{ranges::size_hint(E)} is ill-formed.
\end{itemize}

\pnum
\begin{note}
    Diagnosable ill-formed cases above
    result in substitution failure when \tcode{ranges::size_hint(E)}
    appears in the immediate context of a template instantiation.
\end{note}

\pnum
\begin{note}
    Whenever \tcode{ranges::size_hint(E)} is a valid expression, its
    type is integer-like.
\end{note}

\end{addedblock}

\rSec2[range.sized]{Sized ranges}

\begin{addedblock}
\rSec2[range.approximately.sized]{Approximately sized ranges}

\pnum
The \libconcept{approximately_sized_range} concept refines \libconcept{range} with
the requirement that an approximation of the number of elements in the range can be determined
in amortized constant time using \tcode{ranges::size_hint}.

\begin{itemdecl}
template<class T>
concept @\deflibconcept{approximately_sized_range}@ =
@\libconcept{range}@<T> && requires(T& t) { ranges::size_hint(t); };
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{T}
    models \libconcept{approximately_sized_range} only if \tcode{ranges::size_hint(t)} is amortized \bigoh{1}, and does not modify \tcode{t}.
\end{itemdescr}
\end{addedblock}

\pnum
The \libconcept{sized_range} concept refines \libconcept{\changed{range}{approximately_sized_range}} with
the requirement that the number of elements in the range can be determined
in amortized constant time using \tcode{ranges::size}.

\begin{itemdecl}
    template<class T>
    concept @\deflibconcept{sized_range}@ =
    @\libconcept{\changed{range}{approximately_sized_range}}@<T> && requires(T& t) { ranges::size(t); };
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Given an lvalue \tcode{t} of type \tcode{remove_reference_t<T>}, \tcode{T}
    models \libconcept{sized_range} only if
    \begin{itemize}
        \item \tcode{ranges::size(t)} is amortized \bigoh{1}, does not modify \tcode{t},
        and is equal to \tcode{ranges::distance(\brk{}ranges::begin(t), ranges::end(t))}, and

        \item if \tcode{iterator_t<T>} models \libconcept{forward_iterator},
        \tcode{ranges::size(t)} is well-defined regardless of the evaluation of
        \tcode{ranges::begin(t)}.
        \begin{note}
            \tcode{ranges::size(t)} is otherwise not required to be
            well-defined after evaluating \tcode{ranges::begin(t)}.
            For example, it is possible for \tcode{ranges::size(t)} to be well-defined
            for a \libconcept{sized_range} whose iterator type
            does not model \libconcept{forward_iterator}
            only if evaluated before the first call to \tcode{ranges::begin(t)}.
        \end{note}
    \end{itemize}
\end{itemdescr}


\rSec3[range.utility.conv.to]{\tcode{ranges::to}}

\indexlibrarymember{to}{ranges}%
\begin{itemdecl}
    template<class C, @\libconcept{input_range}@ R, class... Args> requires (!@\libconcept{view}@<C>)
    constexpr C to(R&& r, Args&&... args);
\end{itemdecl}

\begin{itemdescr}
\pnum
\mandates
\tcode{C} is a cv-unqualified class type.

\pnum
\returns
An object of type \tcode{C}
constructed from the elements of \tcode{r} in the following manner:
\begin{itemize}
\item
If \tcode{C} does not satisfy \libconcept{input_range} or
\tcode{\libconcept{convertible_to}<range_reference_t<R>, range_value_t<C>>}
is \tcode{true}:
\begin{itemize}
    \item
    If \tcode{\libconcept{constructible_from}<C, R, Args...>} is \tcode{true}:
    \begin{codeblock}
        C(std::forward<R>(r), std::forward<Args>(args)...)
    \end{codeblock}
    \item
    Otherwise, if
    \tcode{\libconcept{constructible_from}<C, from_range_t, R, Args...>}
    is \tcode{true}:
    \begin{codeblock}
        C(from_range, std::forward<R>(r), std::forward<Args>(args)...)
    \end{codeblock}
    \item
    Otherwise, if
    \begin{itemize}
        \item
        \tcode{\libconcept{common_range}<R>} is \tcode{true},
        \item
        the \grammarterm{qualified-id}
        \tcode{iterator_traits<iterator_t<R>>::iterator_category}
        is valid and denotes a type that models
        \tcode{\libconcept{derived_from}<input_iterator_tag>}, and
        \item
        \tcode{\libconcept{constructible_from}<C, iterator_t<R>, sentinel_t<R>, Args...>}
        is \tcode{true}:
    \end{itemize}
    \begin{codeblock}
        C(ranges::begin(r), ranges::end(r), std::forward<Args>(args)...)
    \end{codeblock}
    \item
    Otherwise, if
    \begin{itemize}
        \item
        \tcode{\libconcept{constructible_from}<C, Args...>} is \tcode{true}, and
        \item
        \tcode{\exposid{container-insertable}<C, range_reference_t<R>>} is \tcode{true}:
    \end{itemize}
    \begin{codeblock}
        C c(std::forward<Args>(args)...);
        if constexpr (@\libconcept{\added{approximately_}sized_range}@<R> && @\exposid{reservable-container}@<C>)
            c.reserve(static_cast<range_size_t<C>>(ranges::size@\added{_hint}@(r)));
        ranges::copy(r, @\exposid{container-inserter}@<range_reference_t<R>>(c));
    \end{codeblock}
\end{itemize}

\item
Otherwise,
if \tcode{\libconcept{input_range}<range_reference_t<R>>} is \tcode{true}:
\begin{codeblock}
    to<C>(r | views::transform([](auto&& elem) {
        return to<range_value_t<C>>(std::forward<decltype(elem)>(elem));
    }), std::forward<Args>(args)...);
\end{codeblock}

\item
Otherwise, the program is ill-formed.
\end{itemize}
\end{itemdescr}

\rSec3[range.ref.view]{Class template \tcode{ref_view}}

\pnum
\tcode{ref_view} is a view of the elements of some other range.
\indexlibraryglobal{ref_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{range}@ R>
requires is_object_v<R>
class ref_view : public view_interface<ref_view<R>> {
    //...

    constexpr auto size() const requires @\libconcept{sized_range}@<R>
    { return ranges::size(*@\exposid{r_}@); }


    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<R>}@
    @\added{\{ return ranges::size_hint(*\exposid{r_}); \}}@

    constexpr auto data() const requires @\libconcept{contiguous_range}@<R>
    { return ranges::data(*@\exposid{r_}@); }
};
\end{codeblock}

\rSec3[range.owning.view]{Class template \tcode{owning_view}}

\pnum
\tcode{owning_view} is a move-only view
of the elements of some other range.
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{range}@ R>
requires @\libconcept{movable}@<R> && (!@\exposid{is-initializer-list}@<R>) // see \ref{range.refinements}
class owning_view : public view_interface<owning_view<R>> {
    private:
    R @\exposid{r_}@ = R();         // \expos

    public:
    owning_view() requires @\libconcept{default_initializable}@<R> = default;
    constexpr owning_view(R&& t);

    owning_view(owning_view&&) = default;
    owning_view& operator=(owning_view&&) = default;

    //...

    constexpr auto size() requires @\libconcept{sized_range}@<R>
    { return ranges::size(@\exposid{r_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const R>
    { return ranges::size(@\exposid{r_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<R>}@
    @\added{\{ return ranges::size_hint(\exposid{r_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const R>}@
    @\added{\{ return ranges::size_hint(\exposid{r_}); \}}@

    constexpr auto data() requires @\libconcept{contiguous_range}@<R>
    { return ranges::data(@\exposid{r_}@); }
    constexpr auto data() const requires @\libconcept{contiguous_range}@<const R>
    { return ranges::data(@\exposid{r_}@); }
};
}
\end{codeblock}

\rSec3[range.as.rvalue.view]{Class template \tcode{as_rvalue_view}}

\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{input_range}@<V>
class as_rvalue_view : public view_interface<as_rvalue_view<V>> {
    V @\exposid{base_}@ = V();      // \expos

    public:
    as_rvalue_view() requires @\libconcept{default_initializable}@<V> = default;
    constexpr explicit as_rvalue_view(V base);

    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V> { return ranges::size(@\exposid{base_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V> { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};

template<class R>
as_rvalue_view(R&&) -> as_rvalue_view<views::all_t<R>>;
}
\end{codeblock}

\rSec3[range.transform.view]{Class template \tcode{transform_view}}

\indexlibraryglobal{transform_view}%
\indexlibrarymember{base}{transform_view}%
\indexlibrarymember{size}{transform_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{input_range}@ V, @\libconcept{move_constructible}@ F>
requires @\libconcept{view}@<V> && is_object_v<F> &&
@\libconcept{regular_invocable}@<F&, range_reference_t<V>> &&
@\exposconcept{can-reference}@<invoke_result_t<F&, range_reference_t<V>>>
class transform_view : public view_interface<transform_view<V, F>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V> { return ranges::size(@\exposid{base_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>
    { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};

}
\end{codeblock}

\rSec3[range.take.view]{Class template \tcode{take_view}}

\indexlibraryglobal{take_view}%
\indexlibrarymember{base}{take_view}%
\indexlibrarymember{begin}{take_view}%
\indexlibrarymember{end}{take_view}%
\indexlibrarymember{size}{take_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
class take_view : public view_interface<take_view<V>> {
    // ...
constexpr auto size() requires @\libconcept{sized_range}@<V> {
    auto n = ranges::size(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}

constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
    auto n = ranges::size(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V> {
    auto n = ranges::size_hint(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}

constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V> {
    auto n = ranges::size_hint(@\exposid{base_}@);
    return ranges::min(n, static_cast<decltype(n)>(@\exposid{count_}@));
}
\end{codeblock}
\end{addedblock}
\begin{codeblock}
};

}
\end{codeblock}


\rSec3[range.drop.view]{Class template \tcode{drop_view}}

\indexlibraryglobal{drop_view}%
\indexlibrarymember{base}{drop_view}%
\indexlibrarymember{end}{drop_view}%
\indexlibrarymember{size}{drop_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
///...

constexpr auto size() requires @\libconcept{sized_range}@<V> {
    const auto s = ranges::size(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}

constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
    const auto s = ranges::size(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}

\end{codeblock}
\begin{addedblock}
\begin{codeblock}
constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V> {
    const auto s = ranges::size_hint(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}

constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V> {
    const auto s = ranges::size_hint(@\exposid{base_}@);
    const auto c = static_cast<decltype(s)>(@\exposid{count_}@);
    return s < c ? 0 : s - c;
}
\end{codeblock}
\end{addedblock}
\begin{codeblock}

private:
V @\exposid{base_}@ = V();                              // \expos
range_difference_t<V> @\exposid{count_}@ = 0;           // \expos
};

}
\end{codeblock}

\rSec3[range.common.view]{Class template \tcode{common_view}}

\indexlibraryglobal{common_view}%
\indexlibrarymember{base}{common_view}%
\indexlibrarymember{size}{common_view}%
\indexlibrarymember{begin}{common_view}%
\indexlibrarymember{end}{common_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires (!@\libconcept{common_range}@<V> && @\libconcept{copyable}@<iterator_t<V>>)
class common_view : public view_interface<common_view<V>> {
    // ...
    constexpr auto size() requires @\libconcept{sized_range}@<V> {
        return ranges::size(@\exposid{base_}@);
    }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
        return ranges::size(@\exposid{base_}@);
    }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};
}
\end{codeblock}

\rSec3[range.reverse.view]{Class template \tcode{reverse_view}}

\indexlibraryglobal{reverse_view}%
\indexlibrarymember{base}{reverse_view}%
\indexlibrarymember{size}{reverse_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{bidirectional_range}@<V>
class reverse_view : public view_interface<reverse_view<V>> {
    ///...
    constexpr auto size() requires @\libconcept{sized_range}@<V> {
        return ranges::size(@\exposid{base_}@);
    }

    constexpr auto size() const requires @\libconcept{sized_range}@<const V> {
        return ranges::size(@\exposid{base_}@);
    }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};

}
\end{codeblock}

\rSec3[range.as.const.view]{Class template \tcode{as_const_view}}

\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{input_range}@<V>
class as_const_view : public view_interface<as_const_view<V>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V> { return ranges::size(@\exposid{base_}@); }
    constexpr auto size() const requires @\libconcept{sized_range}@<const V> { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@
};
}
\end{codeblock}

\rSec3[range.elements.view]{Class template \tcode{elements_view}}

\indexlibraryglobal{elements_view}%
\indexlibrarymember{base}{elements_view}%
\indexlibrarymember{begin}{elements_view}%
\indexlibrarymember{end}{elements_view}%
\indexlibrarymember{size}{elements_view}%
\begin{codeblock}
namespace std::ranges {
template<class T, size_t N>
concept @\defexposconcept{has-tuple-element}@ =                   // \expos
@\exposconcept{tuple-like}@<T> && N < tuple_size_v<T>;

template<class T, size_t N>
concept @\defexposconcept{returnable-element}@ =                  // \expos
is_reference_v<T> || @\libconcept{move_constructible}@<tuple_element_t<N, T>>;

template<@\libconcept{input_range}@ V, size_t N>
requires @\libconcept{view}@<V> && @\exposconcept{has-tuple-element}@<range_value_t<V>, N> &&
@\exposconcept{has-tuple-element}@<remove_reference_t<range_reference_t<V>>, N> &&
@\exposconcept{returnable-element}@<range_reference_t<V>, N>
class elements_view : public view_interface<elements_view<V, N>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V>
    { return ranges::size(@\exposid{base_}@); }

    constexpr auto size() const requires @\libconcept{sized_range}@<const V>
    { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    private:
    // \ref{range.elements.iterator}, class template \tcode{elements_view::\exposid{iterator}}
    template<bool> class @\exposid{iterator}@;                      // \expos

    // \ref{range.elements.sentinel}, class template \tcode{elements_view::\exposid{sentinel}}
    template<bool> class @\exposid{sentinel}@;                      // \expos

    V @\exposid{base_}@ = V();                                      // \expos
};
}
\end{codeblock}


\rSec3[range.enumerate.view]{Class template \tcode{enumerate_view}}

\indexlibrarymember{begin}{enumerate_view}%
\indexlibrarymember{end}{enumerate_view}%
\indexlibrarymember{size}{enumerate_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\exposconcept{range-with-movable-references}@<V>
class enumerate_view : public view_interface<enumerate_view<V>> {
     //...

    constexpr auto size()
    requires @\libconcept{sized_range}@<V>
    { return ranges::size(@\exposid{base_}@); }

    constexpr auto size() const
    requires @\libconcept{sized_range}@<const V>
    { return ranges::size(@\exposid{base_}@); }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>}@
    @\added{\{ return ranges::size_hint(\exposid{base_}); \}}@

    constexpr V base() const & requires @\libconcept{copy_constructible}@<V> { return @\exposid{base_}@; }
    constexpr V base() && { return std::move(@\exposid{base_}@); }
};

template<class R>
enumerate_view(R&&) -> enumerate_view<views::all_t<R>>;
}
\end{codeblock}

%\rSec3[range.zip.view]{Class template \tcode{zip_view}}
%
%\indexlibrarymember{begin}{zip_view}%
%\indexlibrarymember{end}{zip_view}%
%\indexlibrarymember{size}{zip_view}%
%\begin{codeblock}
%namespace std::ranges {
%template<class... Rs>
%concept @\defexposconcept{zip-is-common}@ =                             // \expos
%(sizeof...(Rs) == 1 && (@\libconcept{common_range}@<Rs> && ...)) ||
%(!(@\libconcept{bidirectional_range}@<Rs> && ...) && (@\libconcept{common_range}@<Rs> && ...)) ||
%((@\libconcept{random_access_range}@<Rs> && ...) && (@\libconcept{sized_range}@<Rs> && ...));
%
%template<@\libconcept{input_range}@... Views>
%requires (@\libconcept{view}@<Views> && ...) && (sizeof...(Views) > 0)
%class zip_view : public view_interface<zip_view<Views...>> {
%    //...
%    constexpr auto size() requires (@\libconcept{sized_range}@<Views> && ...);
%    constexpr auto size() const requires (@\libconcept{sized_range}@<const Views> && ...);
%
%    @\added{constexpr auto size_hint();}@
%    @\added{constexpr auto size_hint() const;}@
%
%};
%}
%\end{codeblock}

\rSec3 [range.adjacent.view]{Class template \tcode{adjacent_view}}

\indexlibrarymember{begin}{adjacent_view}%
\indexlibrarymember{end}{adjacent_view}%
\indexlibrarymember{size}{adjacent_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{forward_range}@ V, size_t N>
requires @\libconcept{view}@<V> && (N > 0)
class adjacent_view : public view_interface<adjacent_view<V, N>> {
    //...

    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@

};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        using ST = decltype(ranges::size(@\exposid{base_}@));
        using CT = common_type_t<ST, size_t>;
        auto sz = static_cast<CT>(ranges::size(@\exposid{base_}@));
        sz -= std::min<CT>(sz, N - 1);
        return static_cast<ST>(sz);
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
    using ST = decltype(ranges::size_hint(@\exposid{base_}@));
    using CT = common_type_t<ST, size_t>;
    auto sz = static_cast<CT>(ranges::size_hint(@\exposid{base_}@));
    sz -= std::min<CT>(sz, N - 1);
    return static_cast<ST>(sz);
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[range.adjacent.transform.view]{Class template \tcode{adjacent_transform_view}}

\indexlibrarymember{begin}{adjacent_transform_view}%
\indexlibrarymember{end}{adjacent_transform_view}%
\indexlibrarymember{size}{adjacent_transform_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{forward_range}@ V, @\libconcept{move_constructible}@ F, size_t N>
requires @\libconcept{view}@<V> && (N > 0) && is_object_v<F> &&
@\libconcept{regular_invocable}@<F&, @\exposid{REPEAT}@(range_reference_t<V>, N)...> &&
@\exposconcept{can-reference}@<invoke_result_t<F&, @\exposid{REPEAT}@(range_reference_t<V>, N)...>>
class adjacent_transform_view : public view_interface<adjacent_transform_view<V, F, N>> {
    //...
    constexpr auto size() requires @\libconcept{sized_range}@<@\exposid{InnerView}@> {
        return @\exposid{inner_}@.size();
    }

    constexpr auto size() const requires @\libconcept{sized_range}@<const @\exposid{InnerView}@> {
        return @\exposid{inner_}@.size();
    }

    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<InnerView>}@
    @\added{\{ return \exposid{inner_}.size_hint(); \}}@

    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const InnerView>}@
    @\added{\{ \exposid{inner_}.size_hint(); \}}@
};
}
\end{codeblock}

\rSec3[range.chunk.view.input]{Class template \tcode{chunk\_view} for input ranges}

\indexlibrarymember{begin}{chunk_view}%
\indexlibrarymember{end}{chunk_view}%
\indexlibrarymember{size}{chunk_view}%
\begin{codeblock}
class chunk_view : public view_interface<chunk_view<V>> {
    //...
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::distance(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::size_hint(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[range.chunk.view.fwd]{Class template \tcode{chunk_view} for forward ranges}

\indexlibrarymember{begin}{chunk_view}%
\indexlibrarymember{end}{chunk_view}%
\indexlibrarymember{size}{chunk_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{view}@ V>
requires @\libconcept{forward_range}@<V>
class chunk_view<V> : public view_interface<chunk_view<V>> {
   //...
   constexpr auto size() requires @\libconcept{sized_range}@<V>;
   constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
   @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
   @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::distance(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::size_hint(@\exposid{base_}@), @\exposid{n_}@));
    \end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[range.slide.view]{Class template \tcode{slide_view}}

\indexlibrarymember{begin}{slide_view}%
\indexlibrarymember{end}{slide_view}%
\indexlibrarymember{size}{slide_view}%
\begin{codeblock}
namespace std::ranges {
template<@\libconcept{forward_range}@ V>
requires @\libconcept{view}@<V>
class slide_view : public view_interface<slide_view<V>> {
    //...
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        auto sz = ranges::distance(@\exposid{base_}@) - @\exposid{n_}@ + 1;
        if (sz < 0) sz = 0;
        return @\exposid{to-unsigned-like}@(sz);
    \end{codeblock}
\end{itemdescr}


\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        auto sz = static_cast<range_difference_t<R>>(ranges::size_hint(r)) - @\exposid{n_}@ + 1;
        if (sz < 0) sz = 0;
        return @\exposid{to-unsigned-like}@(sz);
    \end{codeblock}
\end{itemdescr}
\end{addedblock}

\rSec3[range.stride.view]{Class template \tcode{stride_view}}

\begin{codeblock}
namespace std::ranges {
template<@\libconcept{input_range}@ V>
requires @\libconcept{view}@<V>
class stride_view : public view_interface<stride_view<V>> {
    //

    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
    @\added{constexpr auto size_hint() requires \libconcept{approximately_sized_range}<V>;}@
    @\added{constexpr auto size_hint() const requires \libconcept{approximately_sized_range}<const V>;}@
};
}
\end{codeblock}

\begin{itemdecl}
    constexpr auto size() requires @\libconcept{sized_range}@<V>;
    constexpr auto size() const requires @\libconcept{sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::distance(@\exposid{base_}@), @\exposid{stride_}@));
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\begin{itemdecl}
    constexpr auto size_hint() requires @\libconcept{approximately_sized_range}@<V>;
    constexpr auto size_hint() const requires @\libconcept{approximately_sized_range}@<const V>;
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
    return @\exposid{to-unsigned-like}@(@\exposid{div-ceil}@(ranges::size_hint(@\exposid{base_}@), @\exposid{stride_}@));
\end{codeblock}
\end{itemdescr}
\end{addedblock}


\section{Acknowledgments}

Thanks to Zach Laine and Barry Revzin for providing valuable feedback on an early draft of this paper.


\bibliographystyle{plain}
\bibliography{wg21}


\renewcommand{\section}[2]{}%

\begin{thebibliography}{9}


\end{thebibliography}
\end{document}
