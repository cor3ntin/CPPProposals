% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{\tcode{constexpr} structured bindings\\{\small and}\\\ references to \tcode{constexpr} variables}
\docnumber{P2686R5}
\audience{CWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Brian Bi}{bbi10@bloomberg.net}

\usepackage{color, colortbl}
\begin{document}
\maketitle

\section{Abstract}

\paper{P1481R0} proposed allowing references to constant expressions to be themselves constant expressions,
as a means to support \tcode{constexpr} structured bindings.
This paper reports implementation experience on this proposal and provides updated wording.


\section{Revisions}


\subsection{Revision 5}

\begin{itemize}
\item Fix examples in the core wording.
\item Add notes on implementation
\end{itemize}

\subsection{Revision 4}

The definitions of "constituent values" and "constituent references" have been
tweaked slightly with no change in meaning.  The imprecise "at a point [...]
namespace scope" wording has been changed to refer to the nearest following
point at namespace scope.  The example in the wording that states which
variables are constexpr-referenceable has been updated to clarify which
variables are not constexpr-referenceable.  A new term has been introduced in
order to clarify the presentation of the definition of "usable in constant
expressions".  A new term has been introduced in order to reduce duplicative
specification between "constant-initialized" and the requirements for
\tcode{constexpr} variable declarations.  Function parameter scopes introduced
by \tcode{requires} expressions are now ignored.  Additional examples have been
added to [expr.const] demonstrating the semantics of structured bindings during
constant evaluation.

Remove the feature test macro, as core did not find a use case for you and recent papers
bump both \tcode{__cpp_constexpr} and \tcode{__cpp_structured_bindings}.

\textbf{This revision was approved by CWG in St Louis and is waiting an implementation to be forwarded to plenary.}

\subsection{Revision 3}

CWG pointed out that the restrictions on volatile variables and mutable subobjects in the definition of ``usable in constant expressions'' have undesirable consequences. Those restrictions have therefore been moved to [basic.def.odr]. An unintentional omission in R2 has also been fixed: a local static constexpr reference shall not refer to a variable with automatic storage duration. Examples have also been added to the wording section.

Following discussion in EWG and on the reflector, we have also refined our explanation for why the proposed changes do not allow constexpr references declared inside lambdas to bind to variables with automatic storage duration declared in an enclosing function.

\subsection{Revision 2}

We provide wording for option 3 (symbolic addressing), which is the direction chosen by EWG in Varna.
We also allow \tcode{constinit} structured bindings, mostly because we could not find a good reason not to,
and we think it's best to avoid too many exceptions and inconsistencies.

\subsection{Revision 1}

After core expressed implementability concerns of the original design as it pertains to constexpr references to automatic storage duration variables, we provide different options.

\subsection{Revision 0}

Design and wording similar to that of \paper{P1481R0}.

\section{Issues with R0 and possible solutions}

The previous revision of this paper, (\paper{P2686R0}), was approved by the EWG in Issaquah and was subsequently
reviewed by CWG, which found the proposed wording to be quite insufficient.

No issue arises with allowing \tcode{constexpr} structured binding in general, except for the case of an automatic storage duration structured binding
initialized by a tuple, i.e.,

\begin{colorblock}
void f() {
    constexpr auto [a] = std::tuple(1);
    static_assert(a == 1);
}
\end{colorblock}

which translates to

\begin{colorblock}
void f() {
    constexpr auto __sb = std::tuple(1);  // __sb has automatic storage scenario.
    constexpr const int& a = get<0>(__sb);
}
\end{colorblock}

When the structured binding is over an array or a class type, it doesn't create actual references,
so we have no issue. When the structured binding is not at function scope, the underlying tuple object has
static storage duration, and its address is a permitted result of a constant expression.

So the problematic case occurs when we are creating an automatic storage duration (i.e., at block scope) structured binding of a tuple (or \placeholder{tuple-like})
object. This specific situation, though, is not uncommon.

The initial wording simply allowed references initialized by a constant expression to be usable in constant expressions.
This phrasing failed to observe that the address of a \tcode{constexpr} variable with automatic storage duration may be different for each evaluation
of a function and, therefore, cannot be a \emph{permitted result of a constant expression}.

The CWG asks that the EWG consider and pick one direction to resolve these concerns.
Some options are explored below.

\section{Possible solutions}

\subsection{0. Allowing static and non-tuple \tcode{constexpr} structured binding}

We should be clear that nothing prevents \tcode{constexpr} structured bindings from just working when binding an aggregate or an array since those are modeled by special magic aliases that are not quite references
(which allows them to work with bitfields).

A \tcode{constexpr} structured binding of a tuple \emph{with static storage duration}, i.e.,

\begin{colorblock}
static constexpr auto [a, b] = std::tuple{1, 2};
\end{colorblock}

would also simply work as it would be equivalent to

\begin{colorblock}
static constexpr auto __t = std::tuple{1, 2};
static constexpr auto & a = std::get<0>(__t);
static constexpr auto & b = std::get<1>(__t);
\end{colorblock}

Supporting this solution requires no further changes to the language than basically allowing the compiler to
parse and apply the \tcode{constexpr} specifier.
Independently of the other solutions presented here, this option would be useful and should be done.

The problematic scenario is an automatic storage duration binding to a \tcode{tuple}.

We could stop there, not try to solve this problem, and force users to use \tcode{static}.
We would, however, have to ensure that expansion statements work with static variables since that was one of the motivations for this paper.

\subsection{1. Making \tcode{constexpr} implicitly static}

We could make \tcode{constexpr} variables implicitly static, but
doing so would most certainly break existing code, in addition to being inconsistent with the meaning of \tcode{constexpr}:

\begin{colorblock}
int f() {
    constexpr struct S {
        mutable int m ;
    } s{0};
    return ++s.m;
}

int main() {
    assert(f() + f() == 2); // currently 2. Becomes 3 if 's' is made implicitly static
}
\end{colorblock}

So this solution is impractical. We could make \tcode{constexpr} static only in some cases to alleviate some of the breakages or even make only \tcode{constexpr} bindings static, not other variables, but this option feels like a hack rather than an actual solution.

\subsection{2. Always re-evaluate a call to \tcode{get}?}

We could conceive that during constant evaluation, tuple structured bindings are replaced by a call to \tcode{get} every time they are constant-evaluated.
This would help with \tcode{constexpr} structured binding but would still disallow generic cases:

\begin{colorblock}
constexpr in not_a_sb =1;
constexpr const int&  a = sb;
\end{colorblock}

Additionally, this would be observable in scenarios in which \tcode{get} would perform some kind of compile-time i/o such as proposed by \paper{P2758R0}.

\subsection{3. Symbolic addressing}

The most promising option --- the one we think should be pursued --- is for \tcode{constexpr} references to designate a specific object, rather than an address,
and to retain that information across constant evaluation contexts.
This is how constant evaluation of references works, but this information is not currently persisted across constant evaluation, which is why we do not permit
\tcode{constexpr} references to refer to objects with automatic storage duration (or subobjects thereof).

To quote \href{https://lists.isocpp.org/core/2023/04/14163.php}{a discussion on the reflector}:

\begin{quoteblock}
This would also resolve a longstanding complaint that the following is invalid:
\begin{colorblock}
void f() {
    constexpr int a = 1;
    constexpr auto *p = &a;
}
\end{colorblock}

It seems like a lot of C++ developers expect the declaration of p to be valid, even though it's potentially initialized to a different address each time f is invoked.
\end{quoteblock}

This solution has the benefit of not being structured-binding specific and would arguably meet user expectations better than the current rule.
Interestingly and maybe counter-intuitively, the constexprness of pointers and references is completely orthogonal to that of their underlying object:

\begin{colorblock}
int main() {
    static int i = 0;
    static constexpr int & r = i; // currently valid

    int j = 0;
    constexpr int & s = j; // could be valid under the "symbolic addressing" model
}
\end{colorblock}

References can be constant expressions because we can track during constant evaluation which objects they refer to, independently of whether the value of that object is or isn't a constant expression.

We would have to be careful about several things.
Pointers and references to variables with automatic storage duration cannot be used outside of the lifetime of their underlying objects, so they could not appear
\begin{itemize}
  \item in template arguments
  \item as the initializer of a variable with static storage duration
\end{itemize}

Similarly, we can construct an automatic storage duration \tcode{constexpr} reference to a static variable but not a static \tcode{constexpr} reference bound to an automatic storage duration object.

\subsection{Thread-local variables}

Taking the address of a thread-local variable may initialize the variable, and that initialization may not be a constant expression.
Supporting references/pointers to thread-local variables would therefore require additional consideration, and we would probably want to allow it only if it were  already initialized
on declaration.

We could exclude thread locals from the design entirely as we're not sure a compelling use case exists for constexpr references to thread-local objects.

\subsection{Lambdas that reference automatic storage duration objects from the enclosing function}

\tcode{constexpr} references are not ODR-used.  Therefore, a constexpr reference used in a lambda does not trigger a capture.
This would be problematic for references bound to automatic storage duration objects:

\begin{colorblock}
auto f() {
    int i = 0;
    constexpr const int & ref = i;
    return [] {
        return ref;
    });
}
f();
\end{colorblock}

The current rules never require odr-use of \tcode{constexpr} references because
any use of a \tcode{constexpr} reference can always be evaluated as if it were
replaced by its initializer. However, in the above example, such a
transformation is not desirable since it would require \tcode{i} to be captured.
Instead, we need to
modify \href{http://eel.is/c++draft/basic.def.odr#5.1}{[basic.def.odr]/p5.1} so that \tcode{constexpr} references to automatic storage duration variables (or subobjects thereof) are ODR-used.
In the above example, \tcode{ref} therefore needs to be captured.

Because lambdas can name variables declared in an enclosing function, they
also present other questions about the scope of this proposal. During EWG review in Kona (November
2023), examples similar to the following were discussed:
\begin{colorblock}
auto f1() {
    int i = 0;
    constexpr const int & ref = i;
    return [&] {
        constexpr const int & ref2 = i;
        return ref2;
    }();
}
auto f2() {
    int i = 0;
    constexpr const int & ref = i;
    return [&] {
        constexpr const int & ref2 = i;
        return ref2;
    };
}
\end{colorblock}
In such examples, the relationship between the lifetime of the reference and
that of the variable it refers to is not obvious, and we initially viewed this
as a rationale to forbid such examples. However, further discussion on the
reflector revealed that there are currently two different rules in the
language that make the above examples ill-formed:

\begin{enumerate}
\item A \tcode{constexpr} reference may not refer to \tcode{i} because
\tcode{i} has automatic storage duration. This restriction is found in
\href{http://eel.is/c++draft/expr.const#14}{[expr.const]/p14} and it is the one
that we propose to relax in order to support constexpr structured bindings at
block scope.
\item In a \grammarterm{lambda-expression}, any expression that names a
variable with automatic storage duration declared in an enclosing function and
that odr-uses that variable is not a constant expression. This restriction is
found in \href{http://eel.is/c++draft/expr.const#5.13}{[expr.const]/p5.13}.
\end{enumerate}

The second restriction follows from the fact that the use of an automatic
variable from an enclosing function has the same semantics as if it referred to
a member of the closure type, e.g.,
\begin{colorblock}
auto f1() {
    int i = 0;
    constexpr const int & ref = i;
    class __lambda {
        int& __i;
        __lambda(int& i) : __i(i) {}
        auto operator()() const {
            constexpr const int & ref2 = *this.__i;
            return ref2;
        }
    };
    return __lambda(i)();
}
auto f2() {
    int i = 0;
    constexpr const int & ref = i;
    class __lambda {
        int& __i;
        __lambda(int& i) : __i(i) {}
        auto operator()() const {
            constexpr const int & ref2 = *this.__i;
            return ref2;
        }
    };
    return __lambda(i);
}
\end{colorblock}
In the above ""desugared lambdas"", the \tcode{*this} always refers to an
object of type \tcode{__lambda} whose lifetime begins before that of
\tcode{ref2}. Consequently,
\href{http://eel.is/c++draft/expr.const#9}{[expr.const]/p9} applies: during the
checking of whether \tcode{ref2}'s initializer is a constant expression,
\tcode{*this} is treated as referring to an unspecified object, and so is
\tcode{*this.__i}. Since \paper{P2280R4}, a reference to an unspecified object
can participate in constant evaluation in limited ways, but cannot, of course,
be the final result of a constant expression.

In the desugared forms, it is clear why the \tcode{ref2} cannot be constexpr in
\tcode{f1} and \tcode{f2}. In current C++, the validity of a \tcode{constexpr}
variable declaration (or any expression that is manifestly constant-evaluated)
cannot depend on a control flow analysis that determines all paths by which
that construct is reached; therefore, \tcode{*this.__i} must be rejected as the
initializer of a \tcode{constexpr} variable as it cannot be \emph{locally}
verified that it refers to an entity known at compile time. We do not propose
to introduce such control flow analysis to C++ as would be necessary to lift
the restrictions in [expr.const]/p9 and [expr.const]/p5.13.

\subsection{Other cases that are not allowed}

We also do not propose to make the following code well-formed:

\begin{colorblock}
int& foo(int x) { return x; }
int bar() {
    constexpr int& r = foo(1);
}
\end{colorblock}

On a callee-destroy implementation, the lvalue result of \tcode{foo(1)} is
dangling because the parameter object \tcode{x} is destroyed immediately after
\tcode{foo} returns to its caller. On a caller-destroy implementation, the
parameter object \tcode{x} is not destroyed until after \tcode{r} is
initialized. Therefore, on a callee-destroy implementation, the initialization
of \tcode{r} has undefined behavior and is, for that reason, not a constant
expression, while on a caller-destroy implementation, the only reason why this
code is currently ill-formed is that \tcode{foo(1)} does not have static
storage duration. Although we propose to allow \tcode{constexpr} references to
refer to objects with automatic storage duration, which includes parameter
objects, we do not think it is desirable for the above code to be well-formed
only on caller-destroy implementations, as it would create a new portability
issue with no known upside. Therefore we propose the restriction that when the
referent of a \tcode{constexpr} reference has automatic storage duration, the
referent must have the same innermost enclosing function parameter scope as the
reference.

\subsection{Teachability of the relaxed restrictions}
Concerns were raised on the reflector about how to explain the changes proposed
by this paper to the broader C++ community. In a few sentences, the changes
could be explained as follows:
\begin{quote}
You can now declare structured bindings \tcode{constexpr}. Because structured
bindings behave like references, \tcode{constexpr} structured bindings are
subject to similar restrictions as \tcode{constexpr} references, and supporting
this feature required relaxing the previous rule that a \tcode{constexpr}
reference must bind to a variable with static storage duration. Now,
\tcode{constexpr} references and structured bindings may also bind to a
variable with automatic storage duration, but only when that variable has an
address that is constant relative to the stack frame in which the reference or
structured binding lives.
\end{quote}
For a C++ programmer who is curious about the rationale for the ``constant
relative to the stack frame'' restriction as it disallows a \tcode{constexpr}
reference in a lambda from binding to a local variable in an enclosing
function, we suggest the following brief explanation:
\begin{quote}
In a lambda, when you refer to a local variable \tcode{x} from an enclosing
function, the compiler transforms that access into something like
\tcode{(*this).__x}, where \tcode{__x} represents the captured address of
\tcode{x}. The expression \tcode{(*this).__x} is not a constant expression
because it isn't known at compile time what object \tcode{this} points to.
\end{quote}

\section{Implenentation}

This paper was implemented in EDG (Thanks Daveed). The implementation is available on
\href{https://compiler-explorer.com/z/sezf7rd6c}{Compiler explorer}.

Note that EDG (and MSVC) is not capable of handling some valid C++23 code, where a temporary is persisted
via lifetime extension in aggregate initialization.
\begin{colorblock}
struct A {
    int* const& r;
};
static int x;
static constexpr A a = {&x};
static_assert(a.r == &x);
\end{colorblock}

\href{https://compiler-explorer.com/z/3fbKqGzbr}{[Compiler Explorer]}.

And this proposal make this problem somewhat more visible.

After discussion with EDG, we agree that this is an orthogonal issue that might require
a core issue in the future if the implementation challenges prove too great.

\section{Wording for Option 3a (symbolic addressing with the same-function restriction)}

\rSec1[basic.def.odr]{One-definition rule}%

\ednote{Modify p5 as follows:}

\label{term.odr.use}%
A variable is named by an expression
if the expression is an \grammarterm{id-expression} that denotes it.
A variable \tcode{x} that is named by a
potentially-evaluated expression \changed{$E$}{$N$}\added{ that appears at a point $P$}
is \defnx{odr-used}{odr-use} by \changed{$E$}{$N$} unless
\begin{itemize}
\item
\tcode{x} is a reference that is
usable in constant expressions \added{at $P$} \iref{expr.const} \added{or}
\begin{removedblock}
    \item
    \tcode{x} is a variable of non-reference type that is
    usable in constant expressions and has no mutable subobjects, and
    $E$ is an element of the set of potential results of an expression
    of non-volatile-qualified non-class type
    to which the lvalue-to-rvalue conversion \iref{conv.lval} is applied, or
    \item
    \tcode{x} is a variable of non-reference type, and
    $E$ is an element of the set of potential results
    of a discarded-value expression \iref{expr.context}
    to which the lvalue-to-rvalue conversion is not applied.
\end{removedblock}

\draftnote{Ideally, \tcode{x} should be allowed to have mutable subobjects as
long as we don't touch the mutable parts of \tcode{x}. This would probably only
require slightly more complex wording, but isn't in scope for this paper because
the status quo also doesn't allow it.}

\begin{addedblock}
\item N is an element of the set of potential results of an expression E, where
\begin{itemize}
\item
$E$ is a discarded-value expression (\iref{expr.context}) to which the lvalue-to-rvalue
conversion is not applied or
\item \tcode{x} is a non-volatile object that is usable in constant expressions at $P$ and has no mutable subobjects and
\begin{itemize}
\item $E$ is a class member access expression ([expr.ref]) naming a non-static data member of reference type and whose object expression has non-volatile-qualified type or
\item the lvalue-to-rvalue conversion (\iref{conv.lval}) is applied to $E$ and $E$ has non-volatile-qualified non-class type.
\end{itemize}
\end{itemize}
\end{addedblock}
\end{itemize}

\begin{addedblock}
\begin{example}
\begin{codeblock}
int f(int);
int g(int&);
struct A {
    int x;
};
struct B {
    int& r;
};
int h(bool cond) {
    constexpr A a = {1};
    constexpr const volatile A& r = a;  // odr-uses \tcode{a}
    int _ = f(cond ? a.x : r.x);  // does not odr-use \tcode{a} or \tcode{r}
    int x, y;
    constexpr B b1 = {x}, b2 = {y};  // odr-uses \tcode{x} and \tcode{y}
    int _ = g(cond ? b1.r : b2.r);  // does not odr-use \tcode{b1} or \tcode{b2}
    int _ = ((cond ? x : y), 0);  // does not odr-use \tcode{x} or \tcode{y}
    return [] {
        return b1.r;  // error: \tcode{b1} is odr-used here because the object
                      // referred to by \tcode{b1.r} is not constexpr-referenceable
                      // here
    }();
}
\end{codeblock}
\end{example}
\end{addedblock}

\rSec3[basic.start.static]{Static initialization}

\draftnote{The constant initialization of a variable implicitly
includes the constant initialization of any temporary objects whose lifetimes
are extended to that of the variable. All references to constant initialization
from elsewhere in the standard currently refer only to variables with constant
initialization. Removing the words "or temporary object" from this paragraph
simplifies the wording elsewhere by avoiding the need to define when an object
(as opposed to variable) is constant-initialized.}

\ednote{Modify p2 as follows:}

\pnum
\indextext{initialization!constant}%
\defnx{Constant initialization}{constant initialization} is performed
if a variable \removed{or temporary object} with static or thread storage duration
is constant-initialized\iref{expr.const}.
\indextext{initialization!zero-initialization}%
If constant initialization is not performed, a variable with static
storage duration\iref{basic.stc.static} or thread storage
duration\iref{basic.stc.thread} is zero-initialized\iref{dcl.init}.
Together, zero-initialization and constant initialization are called
\defnadj{static}{initialization};
all other initialization is \defnadj{dynamic}{initialization}.
All static initialization strongly happens before\iref{intro.races}
any dynamic initialization.
\begin{note}
    The dynamic initialization of non-block variables is described
    in \iref{basic.start.dynamic}; that of static block variables is described
    in \iref{stmt.dcl}.
\end{note}

\rSec1[expr.const]{Constant expressions}
\indextext{expression!constant}

\draftnote{\paper{P0784R7} abolished the previous restriction that constexpr
constructors of non-literal class types may not be invoked during constant
evaluation. The current wording of [expr.const]/2 still contains a special
exception that allows a variable to be considered constant-initialized even
though the initialization would invoke such a constructor; that wording is
unnecessary since \paper{P0784R7} was accepted.}

\draftnote{A structured binding is a named lvalue, but is not a
reference in the non-tuple-like cases; therefore, the current rules regarding references that are not
usable in constant expressions ([expr.const]/8) do not always apply to structured
bindings. The intent of the below wording is that structured bindings should be
subject to the same restrictions during constant evaluation that would apply if
they were references.
}

% https://eel.is/c++draft/dcl.struct.bind#4

\draftnote{The definition of "constexpr-referenceable" below is
written under the assumption that temporary objects are considered to have the
storage duration described in \paper{CWG1634}, namely, that a temporary object whose
lifetime is extended inherits the storage duration of the reference that is
bound to it, and any other temproary object has a distinct storage duration.
}

\pnum
Certain contexts require expressions that satisfy additional
requirements as detailed in this subclause; other contexts have different
semantics depending on whether or not an expression satisfies these requirements.
Expressions that satisfy these requirements,
assuming that copy elision\iref{class.copy.elision} is not performed,
are called
\indexdefn{expression!constant}%
\defnx{constant expressions}{constant expression}.
\begin{note}
    Constant expressions can be evaluated
    during translation.
\end{note}

\begin{bnf}
    \nontermdef{constant-expression}\br
    conditional-expression
\end{bnf}

\ednote{Insert a paragraph after p1:}

\begin{addedblock}
The \defn{constituent values} of an object $o$ are
\begin{itemize}
\item if $o$ has scalar type, the value of $o$;
\item otherwise, the constituent values of any direct subobjects of $o$ other
than inactive union members.
\end{itemize}

The \defn{constituent references} of an object $o$ are
\begin{itemize}
\item any direct members of $o$ that have reference type, and
\item the constituent references of any direct subobjects of $o$ other than
inactive union members.
\end{itemize}
\end{addedblock}

\ednote{Insert a paragraph after p1:}

\begin{addedblock}
The constituent values and constituent references of a variable \tcode{x} are defined as follows:
\begin{itemize}
\item If \tcode{x} declares an object, the constituent values and references of that object are
constituent values and references of \tcode{x}.
\item If \tcode{x} declares a reference, that reference is a constituent reference of \tcode{x}.
\end{itemize}
For any constituent reference \tcode{r} of a variable \tcode{x}, if \tcode{r} is bound to a temporary object or
subobject thereof whose lifetime is extended to that of \tcode{r}, the constituent values and
references of that temporary object are also constituent values and references of \tcode{x},
recursively.
\end{addedblock}

\ednote{Insert a paragraph after p1:}

\begin{addedblock}
An object $o$ is \defn{constexpr-referenceable} from a point $P$ if
\begin{itemize}
\item $o$ has static storage duration, or
\item $o$ has automatic storage duration, and, letting \tcode{v} denote
\begin{itemize}
    \item the variable corresponding to $o$’s complete object or
    \item the variable to whose lifetime that of $o$ is extended,
\end{itemize}
the smallest scope enclosing \tcode{v} and the smallest scope enclosing $P$ that
are neither
\begin{itemize}
    \item block scopes nor
    \item function parameter scopes associated with a
    \grammarterm{requirement-parameter-list}
\end{itemize}
are the same function parameter scope.
\end{itemize}
\begin{example}
\begin{codeblock}
struct A {
    int m;
    const int& r;
};
void f() {
    static int sx;
    thread_local int tx;  // \tcode{tx} is never constexpr-referenceable
    int ax;
    A aa = {1, 2};
    static A sa = {3, 4};
    // The objects \tcode{sx}, \tcode{ax}, and \tcode{aa.m}, \tcode{sa.m}, and
    // the temporaries to which \tcode{aa.r} and \tcode{sa.r} are bound, are
    // constexpr-referenceable.
    auto lambda = [] {
        int ay;
        // The objects \tcode{sx}, \tcode{sa.m}, and \tcode{ay} (but not \tcode{ax} or \tcode{aa}), and the
        // temporary to which \tcode{sa.r} is bound, are constexpr-referenceable.
    };
}
\end{codeblock}
\end{example}
\end{addedblock}

\ednote{Insert a paragraph after p1:}

\begin{addedblock}
An object or reference \tcode{x} is \defn{constexpr-representable} at a point $P$ if, for each constituent value
of \tcode{x} that points to or past an object $o$, and for each constituent reference of \tcode{x} that refers to an
object $o$, $o$ is constexpr-referenceable from $P$.
\end{addedblock}

\ednote{Modify p2 as follows:}

\pnum
A variable \removed{or temporary object} \changed{\tcode{o}}\tcode{v}} is \changed{\defn{constant-initialized}}{\defn{constant-initializable}} if
\begin{itemize}
\item
\begin{removedblock}
either it has an initializer or its default-initialization results in some
initialization being performed, and
\end{removedblock}
\item the full-expression of its initialization is a constant expression when
interpreted as a \grammarterm{constant-expression}, \removed{except that if
\tcode{o} is an object, that full-expression may also invoke constexpr
constructors for \tcode{o} and its subobjects even if those objects are of
non-literal class types.}\\
\begin{note}
    \removed{Such a class can have a non-trivial destructor.}
    Within this evaluation
    \tcode{std::is_constant_evaluated()} \iref{meta.const.eval}
    returns \keyword{true}.
\end{note}
\\
\added{and}
\item
\begin{addedblock}
immediately after the initializing declaration of \tcode{v}, the object or
reference \tcode{x} declared by \tcode{v} is constexpr-representable, and
\end{addedblock}
\item
\begin{addedblock}
if \tcode{x} has static or thread storage duration, \tcode{x} is
constexpr-representable at the nearest point whose immediate scope is a
namespace scope that follows the initializing declaration of \tcode{v}.
\end{addedblock}
\end{itemize}

\ednote{Insert a paragraph after p2:}

\begin{addedblock}
A constant-initializable variable is \defn{constant-initialized} if either it
has an initializer or its default-initialization results in some initialization
being performed.

\begin{example}
\begin{codeblock}
void f() {
    int ax = 0;                  // \tcode{ax} is constant-initialized
    thread_local int tx = 0;     // \tcode{tx} is constant-initialized
    static int sx;               // \tcode{sx} is not constant-initialized
    static int& rss = sx;        // \tcode{rss} is constant-initialized
    static int& rst = tx;        // \tcode{rst} is not constant-initialized
    static int& rsa = ax;        // \tcode{rsa} is not constant-initialized
    thread_local int& rts = sx;  // \tcode{rts} is constant-initialized
    thread_local int& rtt = tx;  // \tcode{rtt} is not constant-initialized
    thread_local int& rta = ax;  // \tcode{rta} is not constant-initialized
    int& ras = sx;               // \tcode{ras} is constant-initialized
    int& rat = tx;               // \tcode{rat} is not constant-initialized
    int& raa = ax;               // \tcode{raa} is constant-initialized
}
\end{codeblock}
\end{example}
\end{addedblock}

\pnum
A variable is \defn{potentially-constant} if
it is constexpr or
it has reference or non-volatile const-qualified integral or enumeration type.

\ednote{Modify p4 as follows:}

\pnum
A constant-initialized potentially-constant variable $V$ is
\defn{usable in constant expressions} at a point $P$ if
$V$'s initializing declaration $D$ is reachable from $P$ and
\begin{itemize}
    \item $V$ is constexpr,
    \item $V$ is not initialized to a TU-local value, or
    \item $P$ is in the same translation unit as $D$.
\end{itemize}
\begin{addedblock}
An object or reference $x$ is \defn{potentially usable in constant expressions}
at point $P$ if it is
\begin{itemize}
        \item the object or reference declared by a variable that is usable in constant expressions at $P$,
        \item a temporary object of non-volatile const-qualified literal type
        whose lifetime is extended (\iref{class.temporary})
        to that of a variable that is usable in constant expressions at $P$,
        \item a template parameter object \iref{temp.param},
        \item a string literal object \iref{lex.string},
        \item a non-mutable subobject of any of the above, or
        \item a reference member of any of the above.
\end{itemize}
\end{addedblock}
An object or reference \added{$x$} is \defn{usable in constant expressions} \added{at point $P$} if it is
\added{an object or reference that is potentially usable in constant expressions
at $P$ and is constexpr-representable at $P$}.
\begin{removedblock}
\begin{itemize}
    \item a variable that is usable in constant expressions, or
    \item a template parameter object \iref{temp.param}, or
    \item a string literal object \iref{lex.string}, or
    \item a temporary object of non-volatile const-qualified literal type
    whose lifetime is extended (\iref{class.temporary})
    to that of a variable that is usable in constant expressions at $P$, or
    \item a non-mutable subobject or reference member of any of the above.
\end{itemize}
\end{removedblock}
\begin{addedblock}
\begin{example}
\begin{codeblock}
struct A {
    int* const & r;
};
void f(int x) {
    constexpr A a = {&x};
    static_assert(a.r == &x);  // OK
    [&] {
        static_assert(a.r != nullptr);  // error: \tcode{a.r} is not usable in
                                        // constant expressions at this point
    }();
}
\end{codeblock}
\end{example}
\end{addedblock}

\ednote{Add after p8:}

\begin{addedblock}
For the purposes of determining whether an expression is a core constant expression, the
evaluation of an \grammarterm{id-expression} that names a structured binding \tcode{v} (\iref{dcl.struct.bind}) has the
following semantics:
\begin{itemize}
\item If \tcode{v} is an lvalue referring to the object bound to an invented reference \tcode{r}, the
behavior is as if \tcode{r} were nominated.
\item Otherwise, if \tcode{v} names an array element or class member, the behavior is that of
evaluating \tcode{$e$[$i$]} or \tcode{$e$.$m$}, respectively, where \tcode{$e$} is the name of the variable initialized
from the initializer of the structured binding declaration, and \tcode{$i$} is the index of the
element referred to by \tcode{v} or \tcode{$m$} is the name of the member referred to by \tcode{v}, respectively.
\end{itemize}
\begin{example}
\begin{codeblock}
#include <tuple>
struct S {
    mutable int m;
    constexpr S(int m): m(m) {}
    virtual int g() const;
};
void f(std::tuple<S&> t) {
    auto [r] = t;
    static_assert(r.g() >= 0);  // error: dynamic type is constexpr-unknown

    constexpr auto [m] = S(1);
    static_assert(m == 1);  // error: lvalue-to-rvalue conversion on mutable
                            // subobject \tcode{e.m}, where \tcode{e} is a
                            // \tcode{constexpr} object of type \tcode{S}

    using A = int[2];
    constexpr auto [v0, v1] = A{2, 3};
    static_assert(v0 + v1 == 5);  // OK, equivalent to \tcode{e[0] + e[1]} where
                                  // \tcode{e} is a \tcode{constexpr} array
}
\end{codeblock}
\end{example}
\end{addedblock}

\ednote{Modify p13 as follows:}

\pnum
A \defnadj{constant}{expression} is either
a glvalue core constant expression that refers to
\changed{an entity that is a permitted result of a constant expression (as defined below)}{an object or a non-immediate function}, or
a prvalue core constant expression whose value
satisfies the following constraints:
\begin{itemize}
    \begin{removedblock}
    \item
    if the value is an object of class type,
    each non-static data member of reference type refers to
    an entity that is a permitted result of a constant expression,

    \item
    if the value is an object of scalar type,
    it does not have an indeterminate value\iref{basic.indet},

    \item
    if the value is of pointer type, it contains
    the address of an object with static storage duration,
    the address past the end of such an object\iref{expr.add},
    the address of a non-immediate function,
    or a null pointer value,

    \item
    if the value is of pointer-to-member-function type,
    it does not designate an immediate function, and

    \item
    if the value is an object of class or array type,
    each subobject satisfies these constraints for the value.
    \end{removedblock}
    \begin{addedblock}
    \item each constituent reference refers to an object or a non-immediate function,
    \item no constituent value of scalar type is an indeterminate value ([basic.indet]),
    \item no constituent value of pointer type is a pointer to an immediate function or an invalid pointer value (\iref{basic.compound}), and
    \item no constituent value of pointer-to-member type designates an immediate function.
    \end{addedblock}
\end{itemize}
\begin{removedblock}
An entity is a
\defnx{permitted result of a constant expression}{constant expression!permitted result of}
if it is an
object with static storage duration that either is not a temporary object or is
a temporary object whose value satisfies the above constraints, or if
it is a non-immediate function.
\end{removedblock}
\begin{note}
    A glvalue core constant expression
    that either refers to or points to an unspecified object
    is not a constant expression.
\end{note}


\rSec1[dcl.dcl]{Declarations}%
\rSec2[dcl.pre]{Preamble}

\ednote{Change p6 as follows:}

\pnum
A \grammarterm{simple-declaration} with an \grammarterm{identifier-list} is called
a \defn{structured binding declaration} \iref{dcl.struct.bind}.
Each \grammarterm{decl-specifier} in the \grammarterm{decl-specifier-seq}
shall be
\added{\tcode{constexpr}, \tcode{constinit},}
\tcode{static},
\tcode{thread_local},
\tcode{auto} \iref{dcl.spec.auto}, or
a \grammarterm{cv-qualifier}.
\begin{example}
    \begin{codeblock}
        template<class T> concept C = true;
        C auto [x, y] = std::pair{1, 2};    // error: constrained \grammarterm{placeholder-type-specifier}
        // not permitted for structured bindings
    \end{codeblock}
\end{example}

\rSec1[dcl.struct.bind]{Structured binding declarations}%
%\indextext{structured binding declaration}%
%\indextext{declaration!structured binding|see{structured binding declaration}}%

\ednote{Change p1 as follows:}

\pnum
A structured binding declaration introduces the \grammarterm{identifier}{s}
$\tcode{v}_0$, $\tcode{v}_1$, $\tcode{v}_2, \dotsc$
of the
\grammarterm{identifier-list} as names
of \defn{structured binding}{s}.
Let \cv{} denote the \grammarterm{cv-qualifier}{s} in
the \grammarterm{decl-specifier-seq} and
\placeholder{S} consist of \changed{the \grammarterm{storage-class-specifier}{s} of
the \grammarterm{decl-specifier-seq} (if any)}
{each \grammarterm{decl-specifier} of the \grammarterm{decl-specifier-seq} that
is \tcode{constexpr}, \tcode{constinit}, or a
\grammarterm{storage-class-specifier}}.
A \cv{} that includes \tcode{volatile} is deprecated;
see [depr.volatile.type].
First, a variable with a unique name \exposid{e} is introduced. If the
\grammarterm{assignment-expression} in the \grammarterm{initializer}
has array type \cvqual{cv1} \tcode{A} and no \grammarterm{ref-qualifier} is present,
\exposid{e} is defined by
\begin{ncbnf}
    \opt{attribute-specifier-seq} \placeholder{S} \cv{} \terminal{A} \exposid{e} \terminal{;}
\end{ncbnf}
and each element is copy-initialized or direct-initialized
from the corresponding element of the \grammarterm{assignment-expression} as specified
by the form of the \grammarterm{initializer}.
Otherwise, \exposid{e}
is defined as-if by
\begin{ncbnf}
    \opt{attribute-specifier-seq} decl-specifier-seq \opt{ref-qualifier} \exposid{e} initializer \terminal{;}
\end{ncbnf}
where
the declaration is never interpreted as a function declaration and
the parts of the declaration other than the \grammarterm{declarator-id} are taken
from the corresponding structured binding declaration.
The type of the \grammarterm{id-expression}
\exposid{e} is called \tcode{E}.
\begin{note}
    \tcode{E} is never a reference type \iref{expr.prop}.
\end{note}

\pnum
If the \grammarterm{initializer} refers to
one of the names introduced by the structured binding declaration,
the program is ill-formed.

\pnum
If \tcode{E} is an array type with element type \tcode{T}, the number
of elements in the \grammarterm{identifier-list} shall be equal to the
number of elements of \tcode{E}. Each $\tcode{v}_i$ is the name of an
lvalue that refers to the element $i$ of the array and whose type
is \tcode{T}; the referenced type is \tcode{T}.
\begin{note}
    The top-level cv-qualifiers of \tcode{T} are \cv.
\end{note}
\begin{example}
    \begin{codeblock}
        auto f() -> int(&)[2];
        auto [ x, y ] = f();            // \tcode{x} and \tcode{y} refer to elements in a copy of the array return value
        auto& [ xr, yr ] = f();         // \tcode{xr} and \tcode{yr} refer to elements in the array referred to by \tcode{f}'s return value
    \end{codeblock}
\end{example}


\rSec2[dcl.constexpr]{The \keyword{constexpr} and \keyword{consteval} specifiers}%
\indextext{specifier!\idxcode{constexpr}}
\indextext{specifier!\idxcode{consteval}}

\ednote{Change p1 as follows:}

\pnum
The \keyword{constexpr} specifier shall be applied only to
the definition of a variable or variable template\added{, a structured binding declaration, } or
the declaration of a function or function template.
The \keyword{consteval} specifier shall be applied only to
the declaration of a function or function template.
A function or static data member
declared with the \keyword{constexpr} or \keyword{consteval} specifier
is implicitly an inline function or variable \iref{dcl.inline}.
If any declaration of a function or function template has
a \keyword{constexpr} or \keyword{consteval} specifier,
then all its declarations shall contain the same specifier.

[...]

\ednote{Modify p6 as follows:}

\pnum
A \keyword{constexpr} specifier used in an object declaration
declares the object as const.
Such an object
shall have literal type and
shall be initialized.
\changed{In any \keyword{constexpr} variable declaration,
the full-expression of the initialization
shall be a constant expression \iref{expr.const}.}%
{A \keyword{constexpr} variable shall be constant-initializable
\iref{expr.const}.}
A \keyword{constexpr} variable that is an object,
as well as any temporary to which a \keyword{constexpr} reference is bound,
shall have constant destruction.

\begin{example}
\begin{codeblock}
struct pixel {
    int x, y;
};
constexpr pixel ur = { 1294, 1024 };    // OK
constexpr pixel origin;                 // error: initializer missing
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
namespace N {
void f() {
    int x;
    constexpr int& ar = x;         // OK
    static constexpr int& sr = x;  // error: \tcode{x} is not
                                   // constexpr-representable at the point
                                   // indicated below
}
// immediate scope here is that of \tcode{N}
}
\end{codeblock}
\end{addedblock}
\end{example}

\rSec2[dcl.constinit]{The \keyword{constinit} specifier}

\emph{Drafting note:} Unlike in [dcl.constexpr], we don't need an explicit rule
about the object or reference being constexpr-representable in this section,
because the restriction added to [expr.const]/2 will cause the variable to have
dynamic initialization if the object or reference is not
constexpr-representable.

\ednote{Modify p1 as follows:}

The \keyword{constinit} specifier shall be applied only to a declaration of a
variable with static or thread storage duration
\begin{addedblock}
or to a structured binding declaration (\iref{dcl.struct.bind}).
\begin{note}A structured binding declaration introduces a uniquely named variable, to which the \tcode{constinit} specifier applies. \end{note}
\end{addedblock}
If the specifier is applied to
any declaration of a variable, it shall be applied to the initializing
declaration. No diagnostic is required if no \keyword{constinit} declaration is
reachable at the point of the initializing declaration.

\rSec2[temp.arg.nontype]{Template non-type arguments}

\ednote{Modify [temp.arg.nontype]/p1 as follows:}

\added{%
A \grammarterm{template-argument} for a non-type  \grammarterm{template-parameter} with declared type \tcode{T} shall be such
that the invented declaration%
}
\begin{addedblock}
\begin{codeblock}
    T x = @\grammarterm{template-argument}@ ;
\end{codeblock}
\end{addedblock}
\added{%
satisfies the semantic constraints for the definition of a \tcode{constexpr} variable with static
storage duration [dcl.constexpr].
}%
If \removed{the type} \tcode{T} \removed{of a \grammarterm{template-parameter} \iref{temp.param}}
contains a placeholder type (\iref{dcl.spec.auto})
or a placeholder for a deduced class type (\iref{dcl.type.class.deduct}),
the type of the parameter is \changed{the type deduced for the variable \tcode{x} in the invented declaration}{deduced from the above declaration.}
\begin{removedblock}
\begin{codeblock}
    T x = @\grammarterm{template-argument}@ ;
\end{codeblock}
\end{removedblock}
\changed{If a deduced parameter type}{If the parameter type thus deduced} is not permitted
for a \grammarterm{template-parameter} declaration \iref{temp.param},
the program is ill-formed.

\ednote{Add after [temp.arg.nontype]/p6:}

\begin{addedblock}
\begin{example}
\begin{codeblock}
template <int& r> class A{};
extern int x;
A<x> a;  // OK
void f(int p) {
    constexpr int& r = p;  // OK
    A<r> a;                // error: a \tcode{static constexpr int\&} variable
                           // cannot be initialized to refer to \tcode{p} here
}
\end{codeblock}
\end{example}
\end{addedblock}

\section{Acknowledgments}

We would like to thanks EDG and Daveed Vandevoorde for providing an implementation.

Thanks to Nina Dinka Ranns, Pablo Halpern, and Joshua Berne for their feedback.

Thanks to Richard Smith for the original discussion of possible solutions on the Core reflector, for helping us understand the interaction of this feature with lambda expressions, and for feedback on the wording.

Thanks to Nicolas Lesser for the original work on \paper{P1481R0}.

Thanks to Daisy Hollman for input on the issue of lambdas that reference
variables from their enclosing functions.

Thanks to JF Bastien for encouraging us to clarify the interaction of this
feature with lambda expressions.

\section{References}

\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}

\end{document}

%%%% example foo6 on godbolt is usable as a pr-value in a constant expression
% [expr.const] 5.9
% special case structure bindings to say they are evaluated in a constant expression context.
% Modify https://eel.is/c++draft/dcl.pre#6
