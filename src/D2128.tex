% !TeX program = luatex
% !TEX encoding = UTF-8

\RequirePackage{luatex85}

\documentclass{wg21}

\title{Multidimensional subscript operator}
\docnumber{P2128R4}
\audience{EWG}
\author{Mark Hoemmen}{mhoemmen@stellarscience.com}
\authortwo{Daisy Hollman}{dshollm@sandia.gov}
\authorthree{Corentin Jabot}{corentin.jabot@gmail.com}
\authorfive{Christian Trott}{crtrott@sandia.gov}
\authorfour{Isabella Muerte}{imuerte@hey.com}

\begin{document}
\maketitle


\section{Abstract}

We propose that user-defined types can define a subscript operator with multiple arguments to better support multi-dimensional containers and views.

\section{Tony tables}
\begin{center}
\begin{tabular}{l|l}
Before & After\\ \hline

\begin{minipage}[t]{0.55\textwidth}
\begin{colorblock}
template<class ElementType, class Extents>
class mdspan {
  template<class... IndexType>
  constexpr reference operator()(IndexType...);
};

int main() {
  int buffer[2*3*4] = { };
  auto s = mdspan<int, extents<2, 3, 4>>(buffer);
  s(1, 1, 1) = 42;
\end{colorblock}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}
template<class ElementType, class Extents>
class mdspan {
  template<class... IndexType>
  constexpr reference operator[](IndexType...);
};

int main() {
  int buffer[2*3*4] = { };
  auto s = mdspan<int, extents<2, 3, 4>> (buffer);
  s[1, 1, 1] = 42;
}
\end{colorblock}
\end{minipage}
\\\\ \hline

\end{tabular}
\end{center}

\section{Revisions}

\subsection{R5}

\begin{itemize}
\item Add more motivation
\item Add a feature test macro
\end{itemize}

\subsection{R4}

\begin{itemize}
\item Wording fixes
\end{itemize}


\subsection{R3}

\begin{itemize}
\item Add some discussions about interpreting \tcode{t[a][b]} as a syntactic rewrite for a variadic \tcode{operator[]} (wich we are not proposing)
\end{itemize}


\subsection{R2}

\begin{itemize}
    \item Add explanation about not adapting this proposal to C arrays
    \item Remove the restriction to require at least one parameter
    \item Add a paragraph about valarray
\end{itemize}

\section{Motivation}

\begin{itemize}
\item C++ uses \tcode{operator[]} for array access.
\item C++ libraries use various syntaxes to work around \tcode{operator[]} not taking multiple arguments.
\item Those syntaxes are inconsistent with single-dimensional C++ arrays.
  They carry the wrong semantic implications,
  make compile-time error detection and reporting more difficult,
  and/or hinder inlining.
\item Therefore, we should allow \tcode{operator[]} to take multiple arguments.
\end{itemize}

\subsection{What are multidimensional arrays?}

\emph{Multidimensional arrays} map multiple integer indices to a reference to an element of the array.
They naturally generalize single-dimensional arrays.
Programmers use types that behave like multidimensional arrays to represent objects in many domains, including

\begin{itemize}
\item matrices (as in linear algebra) and tensors;
\item discretized physical space (e.g., for physics simulations or video games); and
\item images (as in graphics).
\end{itemize}

Two examples of multidimensional arrays are the multidimensional array container \tcode{mdarray} (P1684)
and the multidimensional array view \tcode{mdspan} (P0009).

Other types generalize multidimensional arrays to accept index types other than integers.
For example, a type could map from a sequence of string ``indices'' to an element in a hierarchical data format,
like XML (as in XPATH) or INI (as in Windows configuration files).

\subsection{C++ uses square brackets for one-dimensional array access}

C++ preferentially uses \tcode{operator[]} for one-dimensional array access.  Standard C++ provides several different single-dimensional array types: both ``native'' arrays \tcode{T[]}, and the Standard Library types \tcode{array}, \tcode{span}, and \tcode{vector}.  All of these types use \tcode{operator[]} as the array access operator, that maps from an integer index to a reference to an array element.  While not all users consider \tcode{string} and \tcode{string_view} to be array types, these types also use \tcode{operator[]} as the ``array access'' operator mapping from an integer offset to a reference to the corresponding string character.  Finally, the types \tcode{map} and \tcode{unordered_map} use \tcode{operator[]} for table look-ups returning a reference, as a generalization of array access.

\subsection{Work-around multidimensional array access syntaxes}

It would seem that C++ intends \tcode{operator[]} for array access.  However, C++ does not currently permit passing multiple arguments to \tcode{operator[]}.  Thus, C++ multidimensional array types must work around by using a different syntax.  Many current libraries take one of the following three options:

\begin{itemize}
\item \tcode{a(x, y, z)}: the function call operator taking multiple indices, as in the Fortran or Matlab languages;
\item \tcode{a[x][y][z]}: a chain of single-argument array access operators, as with C array-of-array; or
\item \tcode{a[\{x, y, z\}]}: an array access operator taking a \tcode{tuple} or tuple-like aggregate index type.
\end{itemize}

We will go through each in turn, and argue that their disadvantages call out for fixing \tcode{operator[]} to accept multiple indices.

\subsection{Function call operator}

One syntax for multidimensional array access is the function call operator taking multiple indices, like this: \tcode{a(x, y, z)}.  In this example, \tcode{a} is a three-dimensional array \tcode{a}, and \tcode{x}, \tcode{y}, and \tcode{z} are the three indices.  Programming languages such as Fortran, Matlab, and Scala use this syntax, as do many C++ libraries (Armadillo, Boost.uBLAS, Eigen, Kokkos) and C++ Standard Library proposals (\tcode{mdspan} (P0009) and \tcode{mdarray} (P1684)).  P0009 in particular, as of March 2021 currently at Revision 10, passed LEWG review in 2018 with this syntax.

Use of \tcode{operator()} overloads the same syntax for both array access and calling a function or invocable object.  It's true that array access is a special kind of function, mapping indices to a reference.  However, using the same syntax for both causes several problems.

First, it's not consistent with use of \tcode{operator[]} for one-dimensional array access.  Other programming languages are consistent in their choice of array access operator, regardless of the array's dimension.  Fortran and Matlab use parentheses for both single-dimensional and multi-dimensional arrays.  Mathematica and Python use square brackets, as in \tcode{a[x]} or \tcode{b[x, y, z]}.  Only C++ switches punctuation depending on the number of dimensions.  Novice C++ programmers find the language's inconsistency confusing.  One anecdote we gathered, is that it puzzles novices to see what appears to be a function call on the left-hand side of an assignment, as in \tcode{a(x,y,z) = 42}.

Second, function calls in C++ carry no particular semantics, while array access generally implies mapping from indices to a reference (or proxy reference).

Third, interfaces that take both invocables and multidimensional arrays need to distinguish between them easily at compile time, in order to catch errors at compile time and produce more user-friendly error messages.  Suppose that \tcode{combine(f, A, B, C)} applies the binary function \tcode{f} elementwise to the two-dimensional arrays \tcode{A} and \tcode{B}, assigning the results to the elements of \tcode{C}.  In our preferred syntax, the ``inner loop'' would look like this: \tcode{C[i,j] = f(A[i,j], B[i,j])}.  Using the same syntax for array access and function calls might mean that mixing up the order of \tcode{f} and \tcode{A} makes the call to \tcode{combine} compile (resulting in run-time errors), or at least fail with more mysterious build errors.  The proliferation of asynchronous interfaces that take callbacks makes it even more important to catch errors at compile time.

Fourth, many of the C++ libraries that use \tcode{operator()} for array access also provide \tcode{operator[]} for one-dimensional arrays.  This includes Armadillo, Boost.uBLAS, \tcode{boost::multi_array}, Eigen, and Kokkos.  Users of these libraries prefer \tcode{operator[]} or at least want to be able to write generic code that works for C++'s other one-dimensional array types.  In Kokkos' case at least, the library's authors consider \tcode{operator()} merely a work-around for \tcode{operator[]} not taking multiple arguments.

\subsection{Chain of single-argument array access operators}

Another syntax for multidimensional array access is a chain of single-argument array access operators, like this: \tcode{a[x][y][z]}.  In this example, \tcode{a} is a three-dimensional array \tcode{a}, and \tcode{x}, \tcode{y}, and \tcode{z} are the three indices.  This has the advantage of being consistent with C's array-of-array(-of-array\ldots) syntax, and with C++ \tcode{vector<vector<T>>} and similar types.  That makes it easier to write generic code that accepts all these types.  However, there are a few problems with this syntax.

First, \tcode{a[x][y]} implies that \tcode{a[x]} is a valid expression.  For any custom array type, this implies that \tcode{a[x]} is a proxy reference.  This hinders inlining by making the required function call depth for an array access no less than the number of dimensions.  Anecdotally, the compiler failing to inline array accesses has a devastating effect on performance.  Greater function call depth for frequent operations like array access tends to hinder compiler optimizations like inlining.  (It is often difficult to demonstrate this with small code examples.  Compilers tend to disable optimizations when faced with larger compilation units.)  Furthermore, the proxy reference \tcode{a[x]} may be expensive to construct or rarely needed for some array types.  For instance, for a sparse matrix in compressed column format, \tcode{a[x]} would represent a view of the entire row.  It's much more complicated to construct this, than just to get the entry at row \tcode{x} and column \tcode{y}.  Column-oriented access is faster than row-oriented access for this sparse matrix format, so it is more common to get column views than row views.

Second, the notation \tcode{a[x][y]} does not tell users about the copy behavior of \tcode{a[x]}.  If \tcode{a} is \tcode{vector<vector<int>>}, then \tcode{auto a_x = a[x]} makes a deep copy.  If \tcode{a} is \tcode{int**}, then \tcode{auto a_x = a[x]} makes a shallow copy.  Authors of generic code might be tempted to write \tcode{auto\& a_x = a[x]}, but if \tcode{a[x]} is a proxy reference, then it is unsafe to assign it to a reference.  This hinders writing generic code that is both safe and avoids unnecessary copies.

Third, \tcode{a[x][y]} strongly suggests an array of arrays, perhaps even a C array of arrays (like \tcode{int**}).  This notation comes with its own semantic expectations, such as:

\begin{itemize}
\item the rightmost index is contiguous (``row-wise'' storage);
\item \tcode{a[x]} is a pointer and thus requires allocation for all \tcode{x} in range; and
\item for \tcode{q != r}, \tcode{a[q]} and \tcode{a[r]} might have different sizes (``ragged'' arrays).
\end{itemize}

Fourth, the notations \tcode{a(x,y,z)} or \tcode{a[x,y,z]} are more friendly to pack expansion than \tcode{a[x][y][z]}.  It might be possible to extend pack expansion to support a chain of 1-argument \tcode{operator[]}, but that would require a more substantial change to C++ than what we propose.

\subsection{Array access operator taking a struct of indices}

Microsoft AMP's \tcode{array} type has an \tcode{operator[]} with a single parameter of type \tcode{index<Rank>}.  This is a \tcode{tuple}-like type, where \tcode{Rank} is the array's number of dimensions.  Users who do not want to construct \tcode{index<Rank>} on each array access can use the syntax \tcode{a[\{x, y, z\}]} (for example), where \tcode{a} is a three-dimensional array \tcode{a}, and \tcode{x}, \tcode{y}, and \tcode{z} are the three indices.  One advantage to this approach is that users can reason about a multidimensional index as a unit.  However, this syntax has greater inlining requirements per array expression: the \tcode{index<Rank>} object must be constructed, and then unpacked to get the indices.  Also, there is no precedent for this \tcode{a[\{x, y, z\}]} syntax in other languages.

\subsection{Summary}

The array access operator carries the right meaning for array types in C++, no matter how many dimensions they have.  C++ developers see it and immediately know that it maps an index to a reference or reference-like type.  For instance, the function call operator is too generic, while a chain of single-argument array accesses is too specific to arrays-of-arrays.  While the notation \tcode{a[\{x, y, z\}]} at least uses the array access operator, the extra level of punctuation is unprecedented, and has potential performance issues.  Forcing different punctuation for single-dimensional and multi-dimensional array access is a mistake that other languages do not make, regardless of what symbol they use.  In C++, \tcode{a[x, y, z]} is the right notation for multidimensional array access.

TODO BELOW HERE

\subsection{Scientific community expectations}

TODO DAISY AND MARK

\section{Proposal}
We propose that the \tcode{operator[]} should be able to accept 0 or more arguments, including variadic arguments.
Both its use and definition would match that of \tcode{operator()}.

We make the expressions deprecated in 20 ill-formed while allowing multi-dimensional subscripts expressions in \textbf{new} standard types
and user types. We do not propose modifications to C arrays as to leave a cycle before giving new meaning to syntax that was still valid in C++20.

\section{What about comma expressions?}

In C++20 we deprecated the use of comma expressions in subscript expressions [P1161R3]\cite{P1161R3}.
This proposal would make these ill-formed and give a new meaning to commas in subscript expressions.
While the timeline is aggressive, we think it is important that this feature be available for the benefit of \tcode{mdspan} and \tcode{mdarray}.
At the time of writing [P1161R3], \cite{P1161R3} has been implemented by at least GCC, clang, and MSVC.
[P1161R3]\cite{P1161R3} further denotes that the cases where comma expressions appear in subscript are vanishingly rare.

However, an implementation could keep supporting the current behavior as an extension, for example, they could fall-back to a comma expression if no overload is found for an expression list, or always assume a comma expression in the presence of a C-array.

Because we should not make C++ more confusing, we think the standard should not continue to support the old meaning of a comma
in subscript expressions.

\section{Should we adopt the same syntax for C arrays?}

Code that is deprecated in 20, should be ill-formed in 23 rather than a potentially silent change.
As such we do not propose the proposed syntax to apply to C arrays.
The usefulness of this should be discussed in the C++26 time frame.
However C arrays are not widely used by C++, spending time on them might therefore not be useful.

\section{Should we add a multidimentional operator to \tcode{valarray}?}

Again, we shouldn't change the meaning of existing code in C++23.
We should only add multidimensional operators to new in C++23 types such as \tcode{mdspan}.
If there are users of \tcode{valarray} interested in this feature, this can be done in C++26

\section{What about [foo][bar]?}

As mentioned in [P1161R3]\cite{P1161R3}, an \tcode{operator[]} can return an object which has itself an \tcode{operator[]}.
Therefore chaining multiple \tcode{[]} to index a single object isn't a viable proposal.

\section{Should we interpret \tcode{t[a][b]} as a syntactic rewrite that looks for a variadic operator[]?}

After Richard Smith raised this possibility on the EWG reflector, there was some discussion about this possibility. The rationale behind this suggestion was that current and future generic code that uses multidimensional array semantics (particularly code that may need to work with C-style pointer-to-pointer-like multidimensional arrays) would be syntactically incompatible with types that overload variadic \tcode{operator[]}.  The authors have ultimately decided to reject this direction for a number of reasons.

First of all, we reject the premise that significant generic code exists or will ever exist that needs to be instantiated with types like \tcode{double***}. As experts in scientific computing (expected to be the primary consumer of multidimensional arrays and thus of this proposal), we have seen very little of this sort of generic code. The vast majority of such generic code in production today uses overloads of \tcode{operator()}. No suggestion has been made to have \tcode{operator()} look for \tcode{operator[]} when a sufficient \tcode{operator()} overload cannot be found, so such a proposal will not be discussed here (though we find it equally unsatisfying).

Another important reason to shy away from the \tcode{t[a][b]} rewrite is related to one of the overall motivations for the variadic subscript operator in general: \tcode{t[a]} looks like a valid subexpression, even though it isn't necessarily.  This is a confusing and misleading user experience that we'd like to avoid. 

Finally, we believe the broader issue of generic interoperability with C-style pointer-to-pointer arrays can be addressed with a non-breaking, follow-on proposal in the other direction: if \tcode{t[a, b]} fails overload resolution, the compiler could look for \tcode{(t[a])[b]}. This would make things like \tcode{std::array<std::array<T, 3>, 4>} work out of the box, without any library changes. The authors would welcome such a proposal, but do not believe it should be a part of the initial language change proposed herein. This potential extension also solves the problem that \tcode{t[a][b]} is not a syntax that interacts favorably with parameter packs.

% 

Ultimately, our proposal is one that satisfy the needs of library types without adding complexity to overload resolution.
It leaves the door to future evolutions if these evolutions prove useful and usable.

TODO REQUIEREMENTS CHECKING DAISY AND MARK

TODO MENTION INLINING

\subsection{Non-member operator[]}

We think non-member \tcode{operator[]} is out of scope of this paper and could be added later.
We do not see such hypotetical non-member \tcode{operator[]} as being useful as a migration strategy towards adoption of the \tcode{[]} syntax.
Indeed, adding non-members operators that do not depend on users defined types is prone to future breakage as the author of the class can add
a member operator later, which would create an ambiguous overload set (and therefore an ill-formed program).
That being said there might be motivating use cases.

on the mailing list,
it was suggested that such facility could be useful to simd

\begin{colorblock}
template <typename T>
struct simd
{
    friend operator[](ranges::contiguous_range auto & range, stdx::simd<int> idx)
    {
        for (size_t i = 0; i < idx.size(); ++i)
            ++range[idx[i]];
    }
};

\end{colorblock}

More research should be encouraged in a separate paper!

\section{Wording}

\rSec1[expr]{Expressions}
\rSec2[expr.post]{Postfix expressions}%

\pnum
Postfix expressions group left-to-right.

\begin{bnf}
\nontermdef{postfix-expression}\\
primary-expression\\
\removed{postfix-expression \terminal{[} expr-or-braced-init-list \terminal{]}}\\
\added{postfix-expression \terminal{[}  expression-list \terminal{]}}\\
\added{postfix-expression \terminal{[} braced-init-list \terminal{]}}\\
postfix-expression \terminal{(} \opt{expression-list} \terminal{)}\\
simple-type-specifier \terminal{(} \opt{expression-list} \terminal{)}\\
typename-specifier \terminal{(} \opt{expression-list} \terminal{)}\\
simple-type-specifier braced-init-list\\
\end{bnf}


\rSec3[expr.sub]{Subscripting}
\begin{quote}
\pnum
\indextext{operator!subscripting}%
\indextext{\idxcode{[]}|see{operator, subscripting}}%
A postfix expression followed an expression in square brackets is a
postfix expression. One of the expressions shall be a glvalue of type ``array of
\tcode{T}'' or a prvalue of type ``pointer
to \tcode{T}'' and the other shall be a prvalue of unscoped enumeration or integral type.
The result is of type ``\tcode{T}''.
\indextext{type!incomplete}%
The type ``\tcode{T}'' shall be a completely-defined object type.\footnote{This
    is true even if the subscript operator is used in the following common idiom:
    \tcode{\&x[0]}.}
The expression \tcode{E1[E2]} is identical (by definition) to
\tcode{*((E1)+(E2))},
except that in the case of an array operand, the result is an lvalue
if that operand is an lvalue and an xvalue otherwise.
The expression \tcode{E1} is sequenced before the expression \tcode{E2}.

\pnum
\begin{removedblock}
\begin{note}
    A comma expression\iref{expr.comma}
    appearing as the \grammarterm{expr-or-braced-init-list}
    of a subscripting expression is deprecated;
    see [depr.comma.subscript].
\end{note}
\end{removedblock}

\pnum
\begin{note}
    Despite its asymmetric appearance, subscripting is a commutative
    operation except for sequencing.
    See [expr.unary] and [expr.add] for details of \tcode{*} and
    \tcode{+} and [dcl.array] for details of array types.
\end{note}

\pnum
\changed{A \grammarterm{braced-init-list} shall not be used w}{W}ith the built-in subscript operator\changed{.}{ a \grammarterm{braced-init-list} shall not be used and an \grammarterm{expression-list} shall be a single expression.}

\end{quote}


\rSec1[over.oper]{Overloaded operators}%


\rSec2[over.sub]{Subscripting}%
\indextext{subscripting operator!overloaded}%
\indextext{overloading!subscripting operator}

\pnum
A subscripting operator function
is a function named \tcode{operator[]}
that is a non-static member function \removed{with exactly one parameter}.
For an expression of the form\added{s}

\begin{removedblock}
\begin{ncsimplebnf}
    postfix-expression \terminal{[} expr-or-braced-init-list \terminal{]}
\end{ncsimplebnf}
\end{removedblock}

\begin{addedblock}
\begin{ncsimplebnf}
    postfix-expression \terminal{[}  expression-list \terminal{]}
    
    postfix-expression \terminal{[}  brace-init-list  \terminal{]}
\end{ncsimplebnf}
\end{addedblock}

the operator function is selected by overload resolution ([over.match.oper]).
If a member function is selected, the expression is
interpreted\added{, respectively,} as

\begin{removedblock}
\begin{ncsimplebnf}
    postfix-expression . operator \terminal{[}\terminal{]} \terminal{(} expr-or-braced-init-list \terminal{)}
\end{ncsimplebnf}
\end{removedblock}

\begin{addedblock}
\begin{ncsimplebnf}
     postfix-expression . operator \terminal{[}\terminal{]} \terminal{(} expresssion-list \terminal{)}

      postfix-expression . operator \terminal{[}\terminal{]} \terminal{(}
      braced-init-list  \terminal{)}
\end{ncsimplebnf}
\end{addedblock}

\pnum
\begin{example}
\begin{codeblock}
    struct X {
        Z operator[](std::initializer_list<int>);
        Z operator[](auto...);
    };
    X x;
    x[{1,2,3}] = 7;                 // OK: meaning \tcode{x.operator[](\{1,2,3\})}
    x[1,2,3] = 7;                   // OK: meaning \tcode{x.operator[](1,2,3)}
    int a[10];
    a[{1,2,3}] = 7;                 // error: built-in subscript operator
    a[1,2,3] = 7;                   // error: built-in subscript operator
\end{codeblock}
\end{example}

\rSec2[expr.comma]{Comma operator}%

\pnum
In contexts where comma is given a special meaning,
\begin{example}
    in
    lists of arguments to functions ([expr.call])\added{, subscript expressions,} and lists of
    initializers ([decl.init])
\end{example}
the comma operator as
described in this subclause can appear only in parentheses.
\begin{example}
    \begin{codeblock}
        f(a, (t=3, t+2), c);
    \end{codeblock}
    has three arguments, the second of which has the value
    \tcode{5}.
\end{example}

\begin{removedblock}
\pnum
\begin{note}
    A comma expression
    appearing as the \grammarterm{expr-or-braced-init-list}
    of a subscripting expression [expr.sub] is deprecated;
    see depr.comma.subscript.
\end{note}
\end{removedblock}


\begin{addedblock}

\rSec1[diff.cpp20]{\Cpp{} and ISO C++ 2020{}}


\rSec2[diff.cpp20.expr.sub]{\tcode{[expr.sub]}: declarations}


\change Change the meaning of comma in subscript expressions.
\rationale
Enable repurposing a deprecated syntax to support multidimensional indexing.
\effect Valid C++ program that uses a comma expression within a subscript expression
may fail to compile.


\begin{codeblock}
arr[1, 2] //was equivalent to \tcode{arr[(1, 2)]}, now equivalent to \tcode{arr.operator[](1, 2)} or ill-formed
\end{codeblock}

\end{addedblock}


\begin{removedblock}
\rSec1[depr.comma.subscript]{Comma operator in subscript expressions}

\pnum
A comma expression\iref{expr.comma}
appearing as the \grammarterm{expr-or-braced-init-list}
of a subscripting expression\iref{expr.sub} is deprecated.
\begin{note}
    A parenthesized comma expression is not deprecated.
\end{note}
\begin{example}
\begin{codeblock}
    void f(int *a, int b, int c) {
        a[b,c];                     // deprecated
        a[(b,c)];                   // OK
    }
\end{codeblock}
\end{example}
\end{removedblock}

\subsection{Feature test macros}

Insert an entry in the table into [tab:cpp.predefined.ft]

\begin{addedblock}
\begin{codeblock}
__cpp_multidimensional_subscript | <DATE OF ADOPTION>
\end{codeblock}
\end{addedblock}

\section{Implementation}

A prototype has been implemented in Clang.

\href{https://gcc.godbolt.org/z/4szfLo}{Compiler Explorer Demo}.

Github: \url{https://github.com/cor3ntin/llvm-project/tree/subscript}

\section{Acknowledgments}

Thanks to Jens Maurer for his patient help with the wording, and to the many people who provided valuable feedback.
Thanks to Matt Godbolt for hosting an experimental compiler with the implementation
of this proposal on compiler explorer.

\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{../wg21}

\begin{thebibliography}{9}

    \bibitem[N4861]{N4861}
    Richard Smith
    \emph{Working Draft, Standard for Programming Language C++}\newline
    \url{https://wg21.link/N4861}

\end{thebibliography}

\end{document}
