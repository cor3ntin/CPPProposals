% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}
\usepackage{threeparttable}
\usepackage{adjustbox}

\usepackage{array}
\newcolumntype{?}{!{\vrule width 1pt}}

\title{\tcode{std::generator}: Synchronous Coroutine Generator for Ranges}
\docnumber{P2168R2}
\audience{LEWG}
\author{Lewis Baker}{lewissbaker@gmail.com}
\authortwo{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle


\section{Abstract}

We propose a standard library type \tcode{std::generator} which implements a coroutine generator compatible with ranges.

\section{Revisions}

\subsection{R2}
\begin{itemize}
\item Some wording fixes
\item Improve the section on allocator support
\item Updated implementation
\end{itemize}

\subsection{R1}
\begin{itemize}
\item Add benchmarks results and discussion about performance
\item Introduce \tcode{elements_of} to avoid ambiguities when a generator is convertible to the reference type of the parent generator.
\item Add allocator support
\item Symmetric transfer works with generators of different value / allocator types
\item Remove \tcode{iterator::operator->}
\item Put \tcode{generator} in a new \tcode{<generator>} header.
\item Add an other example to motivate the \tcode{Value} template parameter
\end{itemize}


\section{Example}

\begin{colorblock}
    std::generator<int> fib (int max) {
        co_yield 0;
        auto a = 0, b = 1;
        
        for(auto n : std::views::iota(0, max))  {
            auto next = a + b;
            a = b, b = next;
            co_yield next;
        }
    }
    
    int answer_to_the_universe() {
        auto coro = fib(7) ;
        return std::accumulate(coro | std::views::drop(5), 0);
    }
    
\end{colorblock}

\section{Motivation}

C++ 20 had very minimalist library support for coroutines.
Synchronous generators are an important use case for coroutines, one that cannot be supported without 
the machinery presented in this paper.
Writing an efficient and correctly behaving recursive generator is non-trivial, the standard should provide one.


\section{Design}

While the proposed \tcode{std::generator} interface is fairly straight-forward, a few decisions are worth pointing out.

\subsection{\tcode{input_view}}

\tcode{std::generator} is a non-copyable \tcode{view} which models \tcode{input_range} and spawn move-only iterators.
This is because the coroutine state is a unique resource (even if the coroutine \textit{handle} is copyable).
Unfortunately, some generators can satisfy the \tcode{view} constraints but fail to model the \tcode{view} O(1) 
destruction requirement:

\begin{colorblock}
    
    template <class T>
    std::generator<T> all (vector<T> vec) {
        for(auto & e : vec)  {
            co_yield e;
        }
    }
    
\end{colorblock}



\subsection{Header}

Multiple options are available as to where put the \tcode{generator} class.

\begin{itemize}
    \item \tcode{<coroutine>}, but \tcode{<coroutine>} is a low level header, and \tcode{generator} depends on bits of \tcode{<type_traits>} and \tcode{<iterator>}.
    
    \item \tcode{<ranges>}
    
    \item A new \tcode{<generator>}
    
\end{itemize}

\subsection{Separately specifyable Value Type}

This proposal supports specifying both the "yielded" type, which is the iterator ""reference"" type (not required to be a reference), and its corresponding value type.
This allow ranges to handle proxy types and wrapped \tcode{reference}, like this implementation of \tcode{zip}:

\begin{colorblock}
    template<std::ranges::input_range Rng1,
    std::ranges::input_range Rng2>
    generator<
    std::tuple<std::ranges::range_reference_t<Rng1>,
    std::ranges::range_reference_t<Rng2>,
    std::tuple<std::ranges::range_value_type_t<Rng1>,
    std::ranges::range_value_type_t<Rng2>>>
    zip(Rng1 r1, Rng2 r2) {
        auto it1 = std::ranges::begin(r1);
        auto it2 = std::ranges::begin(r2);
        auto end1 = std::ranges::end(r1);
        auto end2 = std::ranges::end(r2);
        while (it1 != end1 && it2 != end2) {
            co_yield {*it1, *it2};
            ++it1; ++it2;
        }
    }
\end{colorblock}

In this second example, using \tcode{string} as value type ensures that calling code can take the necessay steps
to make sure iterating over a generator would not invalidate any of the yielded values

\begin{colorblock}

// Yielding string literals : always fine
std::generator<std::string_view> string_views() {
    co_yield "foo";
    co_yield "bar";
}

std::generator<std::string_view, std::string> strings() {
    co_yield "start";
    std::string s;
    for (auto sv : string_views()) {
        s = sv;
        s.push_back('!');
        co_yield s;
    }
    co_yield "end";
}

// conversion to a vector of strings
// If the value_type was string_view, it would convert to a vector of string_view,
// which would lead to undefined beavior as the string_views may get invalidated upon iteration!
auto v = std::ranges::to<vector>(strings()); // (@{\paper{P1206R3}}@)

\end{colorblock}


\subsection{Recursive generator}

A "recursive generator" is a coroutine that supports the ability to directly \tcode{co_yield}
a generator of the same type as a way of emitting the elements of that \tcode{generator}
as elements of the current \tcode{generator}.

Example: A \tcode{generator} can \tcode{co_yield} other generators of the same type
\begin{colorblock}
    generator<const std::string&> delete_rows(std::string table, std::vector<int> ids) {
        for (int id : ids) {
            co_yield std::format("DELETE FROM {0} WHERE id = {1}", table, id);
        }
    }
    
    generator<const std::string&> all_queries() {
        co_yield elements_of(delete_rows("user", {4, 7, 9 10}));
        co_yield elements_of(delete_rows("order", {11, 19}));
    }
\end{colorblock}

Example: A \tcode{generator} can also be used recursively
\begin{colorblock}
    struct Tree {
        Tree* left;
        Tree* right;
        int value;
    };
    
    generator<int> visit(Tree& tree) {
        if (tree.left) co_yield elements_of(visit(*tree.left));
        co_yield tree.value;
        if (tree.right) co_yield elements_of(visit(*tree.right));
    }
\end{colorblock}

In addition to being more concise, the ability to directly yield a nested generator has some
performance benefits compared to iterating over the contents of the nested generator and
manually yielding each of its elements.

Yielding a nested \tcode{generator} allows the consumer of the top-level coroutine to
directly resume the current leaf generator when incrementing the iterator, whereas a solution that has each generator manually iterating over elements of the child generator
requires O(depth) coroutine resumptions/suspensions per element of the sequence.

Example: Non-recursive form incurs O(depth) resumptions/suspensions per element
and is more cumbersome to write

\begin{colorblock}
    generator<int> slow_visit(Tree& tree) {
        if (tree.left) {
            for (int x : elements_of(visit(*tree.left)))
            co_yield x;
        }
        co_yield tree.value;
        if (tree.right) {
            for (int x : elements_of(visit(*tree.right)))
            co_yield x;
        }
    }
\end{colorblock}

Exceptions that propagate out of the body of nested \tcode{generator} coroutines
are rethrown into the parent coroutine from the \tcode{co_yield} expression rather
than propagating out of the top-level `iterator::operator++()`. This follows the mental model that `co_yield someGenerator` is semantically equivalent to manually
iterating over the elements and yielding each element.

For example: \tcode{nested_ints()} is semantically equivalent to \tcode{manual_ints()}
\begin{colorblock}
    generator<int> might_throw() {
        co_yield 0;
        throw some_error{};
    }
    
    generator<int> nested_ints() {
        try {
            co_yield elements_of(might_throw());
        } catch (const some_error&) {}
        co_yield 1;
    }
    
    // nested_ints() is semantically equivalent to the following:
    generator<int> manual_ints() {
        try {
            for (int x : might_throw()) {
                co_yield x;
            }
        } catch (const some_error&) {}
        co_yield 1;
    }
    
    void consumer() {
        for (int x : nested_ints()) {
            std::cout << x << " "; // outputs 0 1
        }
        
        for (int x : manual_ints()) {
            std::cout << x << " "; // also outputs 0 1
        }
    }
\end{colorblock}

\subsection{\tcode{elements_of}}

\tcode{elements_of} is a utility function that prevents ambiguity when a nested generator type is convertible to the value type
of the present generator

\begin{colorblock}
    generator<int> f()
    {
        co_yield 42;
    }
    
    generator<any> g()
    {
        co_yield f(); // should we yield 42 or generator<int> ?
    }
    
\end{colorblock}

To avoid this issue, we propose that:

\begin{itemize}
    \item \tcode{co_yield <expression>} always yield the value directly.
    \item \tcode{co_yield elements_of(<expression>)} yield the values of the nested generator.
\end{itemize}


For convenience, we further propose that \tcode{co_yield elements_of(x)} be extended to support
yielding the values of arbitrary ranges beyond generators, ie 

\begin{colorblock}
    generator<int> f()
    {
        std::vector<int> v = /*... */;
        co_yield elements_of(v);
    }
    
\end{colorblock}

\subsection{Symmetric transfer}

The recursive form can be implemented efficiently with symmetric transfer.
Earlier works in \cite{CppCoro} implemented this feature in a distinct \tcode{recursive_generator} type.

However, it appears that a single type is reasonably efficient thanks to HALO optimizations and symmetric transfer.
The memory cost of that feature is 3 extra pointers per generator.
It is difficult to evaluate the runtime cost of our design given the current coroutine support in compilers.
However our tests show no noticeable difference between a \tcode{generator} and a \tcode{recursive_generator} 
which is called non recursively. It is worth noting that the proposed design makes sure that HALO \cite{P0981R0} optimizations are possible.

While we think a single \tcode{generator} type is sufficient and offers a better API, there are three options:

\begin{itemize}
    \item A single \tcode{generator} type supporting recursive calls (this proposal).
    
    \item A separate type \tcode{recursive_generator} that can yield values from either \tcode{recursive_generator} or a \tcode{generator}. That may offer very negligible performance benefits, same memory usage.
    
    \item A separate {recursive_generator} type which can only yield values from other \tcode{recursive_generator}. 
    
    That third option would make the following ill-formed:
    
    \begin{colorblock}
        generator<int> f();
        recursive_generator<int> g() {
            co_yield f(); // incompatible types
        }
    \end{colorblock}
    
    Instead you would need to write:
    \begin{colorblock}
        recursive_generator<int> g() {
            for (int x : f()) co_yield x;
        }
    \end{colorblock}
    
    Such a limitation can make it difficult to decide at the time of writing a generator
    coroutine whether or not you should return a \tcode{generator} or \tcode{recursive_generator}
    as you may not know at the time whether or not this particular generator will be used
    within \tcode{recursive_generator} or not.
    
    If you choose the \tcode{generator} return-type and then later someone wants to yield its
    elements from a \tcode{recursive_generator} then you either need to manually yield its
    elements one-by-one or use a helper function that adapts the \tcode{generator} into a
    \tcode{recursive_generator}. Both of these options can add runtime cost compared to the case where the generator was originally written to return a \tcode{recursive_generator},
    as it requires two coroutine resumptions per element instead of a single coroutine resumption.
    
    Because of these limitations, we are not recommending this approach.
\end{itemize}

Symmetric transfer is possible for different generator types as long as the \tcode{reference} type is the same, aka,
different value type or allocator type does not preclude symmetric transfer (see sectiion on allocators).

\subsection{How to store the yielded value in the promise type?}

The yielded expression is guaranteed to be alive until the coroutine resumes, it is, therefore, sufficient to store
its address. 
This makes \tcode{generator} with a large yielded type efficient.
However, it might pessimize yielding values smaller than a pointer because of the added indirection.
(It is unclear what the cost of this indirection is, as none of these accesses should result in cache misses).

More annoyingly, this prevents conversions in yielding expressions:

\begin{colorblock}
    generator<string_view> f() {
        co_yield std::string(); // error: cannot convert std::string to std::string_view \&
    }
\end{colorblock}

Storing a copy would allow less indirection and the ability to yield any values convertible to the yielded type,
at the cost of more storage.
To avoid that storage cost, a \tcode{generator<const T\&>} can be used.


\section{Allocator support}

In line with the design exploration done in section 2 of \paper{P1681R0}, \tcode{std::generator} can support both stateless and stateful allocators, and strive
to minimize the interface verbosity for stateless allocators, by templating both the generator itself and the \tcode{promise_type}'s \tcode{new} operator
on the allocator type. Details for this interface are found in \paper{P1681R0}.

\tcode{coroutine_parameter_preview_t} such as discussed in section 3 of \paper{P1681R0} has not been explored in this paper.

\begin{colorblock}
    std::generator<int> stateless_example() {
        co_yield 42;
    }
    
    template <class Allocator>
    std::generator<int> 
    allocator_example(std::allocator_arg_t, Allocator alloc) {
        co_yield 42;
    }
    
    my_allocator<std::byte> alloc;
    input_range auto rng = allocator_example<my_allocator<std::byte>>(std::allocator_arg, alloc);
    
\end{colorblock}

The proposed interface requires that, if an allocator is provided, it is the second argument to the coroutine function, 
immediately preceded by an instance of \tcode{std::allocator_arg_t}.
This approach is necessary to distinguish the allocator desired to allocate the coroutine state from allocators whose purpose is to be used in the body of the coroutine function.
The required argument order might be a limitation if any other argument is required to be the first, however, we cannot think of any scenario where that would be the case.

We think it is important that all standard and user coroutines types can accommodate similar interfaces for allocator support.
In fact, the implementation for that allocator support can be shared amongst \tcode{generator}, \tcode{lazy} and other standard types.


\textbf{By default \tcode{std::generator} type erases the allocator type, and uses \tcode{std::allocator} unless an allocator is provided to
the coroutine function}.
Then:

\textbf{Type erased allocator(default)}

\begin{colorblock}
template <class Allocator>
std::generator<int> f(std::allocator_arg_t, Allocator alloc) {}

f(std::allocator_arg, my_alloc{});
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, void>} where \tcode{void} denotes that the allocator is type erased.
The allocator is store on the coroutine state if it is stateful or not default constructible; a pointer is always stored so that the \tcode{deallocate} method of the type erased allocator can be called.


\textbf{No allocator}

\begin{colorblock}
std::generator<int> f() {}
f();
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, void>} where \tcode{void} denotes that the allocator is type erased.
A pointer is stored so that the \tcode{deallocate} method of the type erased allocator can be called. The allocator is \tcode{std::allocator} and is not stored on the frame (because it is stateless)

\textbf{Explicit stateless allocator}

\begin{colorblock}
std::generator<int, int, std::stateless_allocator<int>> f() {}
f();
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, std::stateless_allocator<int>>}
No extra storage is used for the allocator because it is stateless.

\textbf{Explicit stateful allocator}

\begin{colorblock}
std::generator<int, int, some_statefull_allocator<int>> 
    f(std::allocator_arg_t,  some_statefull_allocator<int> alloc) {}
f(std::allocator_arg, some_allocator); // must be convertible to some_statefull_allocator
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, some_statefull_allocator<int>>}
The allocator is copied in the coroutine state.


\subsection{Interaction with symmetric transfer and allocator support}

The allocator must be part of the promise type.
Or implementation uses a base class so that generators of different allocator types can yield each other.
This leaves with 2 implementation strategies
\begin{itemize}
\item Storing a pointer to the base class in the promise handle
\item Leave implementers find the best implementation strategy and can bell their own implementation to be well-formed
\item Modify the wording as follow to allow \tcode{coroutine_handle<promise_base>::from_address(coro.address());} to be well-formed:
\end{itemize}

To support yielding nested generator of different allocator types we then have 3 options:
\begin{itemize}
\item leaving implementers find the most
\end{itemize}

\begin{quote}
\indexlibrarymember{from_address}{coroutine_handle}%
\begin{itemdecl}
static constexpr coroutine_handle<Promise> coroutine_handle<Promise>::from_address(void* addr);
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{addr} was obtained via a prior call to \tcode{address}
on an object of type \cv \changed{\tcode{coroutine_handle<Promise>}}{of type \cv \tcode{coroutine_­handle<T}> where\tcode {T} is any type such that \tcode{is_layout_compatible_v<T, Promise>} is \tcode{true}}.
\end{itemdescr}
\end{quote}



Supporting allocators requires storing, in all cases, a function pointer adjacent to the coroutine state (to track a deallocation function),
along with the allocator itself in the case of stateful allocators.


\subsection{Can we postpone adding support for allocator later?}

A case can be made that allocator support could be added to \tcode{std::generator} later.
However, because the proposed design has the allocator as a template parameter, 
adding allocator after \tcode{std::generator} ships would represent an ABI break.
We recommend that we add allocator support as proposed in this paper now and make sure that the design remains consistent as work on \tcode{std::lazy}
is made in this cycle.
However, it would be possible to extend support for different mechanisms (such as presented in section 3 of \paper{P1681R0} later.

\section{Implementation and experience}

\tcode{generator} has been provided as part of cppcoro and folly.
However, cppcoro offers a separate \tcode{recursive_generator} type, which is different than the proposed design.

Folly uses a single \tcode{generator} type which can be recursive but doesn't implement symmetric transfer. Despite that,
Folly users found the use of \tcode{Folly:::Generator} to be a lot more efficient than the eager algorithm they replaced with it.

\tcode{ranges-v3} also implements a \tcode{generator} type, which is never recursive and predates the work on move-only views and
iterators \cite{P1456R1}, \cite{P1207R0} which forces this implementation to ref-count the coroutine handler.

Our implementation \cite{Implementation} consists of a single type that takes advantage of symmetric transfer to implement
recursion.

\section{Performance \& benchmarks}

Because implementations are still being perfected, and because performance is extremely dependant on whether HALO optimization (see \paper{P0981R1})
occurs, it is difficult at this time to make definitive statements about the performance of the proposed design.

At the time of the writing of this paper, Clang is able to inline non-nested coroutines whether the implementation
supports nested coroutines or not, while GCC never performs HALO optimization.

When the coroutine is not inlined, support for recursion does not noticeably impact performance.
And, when the coroutine yields another generator, the performance of the recursive version is noticeably faster than
yielding each element of the range. This is especially noticeable with deep recursion.

\begin{adjustbox}{center}
\texttt{
\begin{threeparttable}
\begin{tabular}{|l?r|r?r|r?r|r|}
    \hline
    & Clang & Clang ST\tnote{1} & GCC & GCC ST\tnote{1} & MSVC & MSVC ST\tnote{1} \\
    \hline
    Single value & (1) 0.235 &  (2) 2.36 & 12.4 & 13.4 & 61.9 & 63.7 \\
    \hline
    Single value, noinline (3) & 13.5  & 13.7 & 14.1 & 15.2 & 63.8 & 64.4\\
    \hline
    Deep nesting & 43670266.0 & (4) 427955.0 & 58801348 & 338736 & 224052033 & 4760914\\
    \hline
\end{tabular}
\begin{tablenotes}
\item[1] Symmetric transfer.
\end{tablenotes}
\end{threeparttable}
}
\end{adjustbox}


The values are expressed in nanoseconds. However, please note that the comparison of the same result across compiler is not meaningful, notably because the MSVC results were obtained on different hardware.
That being said we observe:

\begin{itemize}
    \item Only Clang can perform constant folding of values yielded by simple coroutine (1)
    \item When the \tcode{generator} supports symmetric transfer, clang is not able to fully inline the generator construction, but HALO is still performed (2).
    \item When HALO is not performed, the relative performance of both approach is similar (3).
    \item Supporting recursion is greatly beneficial to nested/recursive algorithms (4).
\end{itemize}

The code for these benchmarks as well as more detailled results can be found on \href{https://github.com/cor3ntin/coro_benchmark}{Github}.


\section{Wording}

The following wording is meant to illustrate the proposed API.



\rSec2[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}
    
namespace std::ranges {

...

template<@\libconcept{input_or_output_iterator}@ I, @\libconcept{sentinel_for}@<I> S, subrange_kind K>
inline constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;

// \ref{range.dangling}, dangling iterator handling
struct dangling;

\end{codeblock}

\begin{addedblock}
\begin{codeblock}
template<std::ranges::input_range R>
struct elements_of;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
template<@\libconcept{range}@ R>
using borrowed_iterator_t = conditional_t<@\libconcept{borrowed_range}@<R>, iterator_t<R>, dangling>;

...

}

\end{codeblock}


\begin{addedblock}

\rSec2[ranges.elementsof]{ranges::element_of}


\tcode{elements_of} is a type that encapsulates a range and acts as a tag in overload sets to disambiguate when a range should be treated as a sequence rather than a single value in genetric contexts.

\begin{example}
    \begin{codeblock}
        generator<any> f(input_range auto rng) {
            co_yield rng; // yield rng as a single value
            co_yield elements_of(rng); // yield each element of rng
        }
    \end{codeblock}
\end{example}


\begin{codeblock}
namespace std::ranges {        
    template<std::ranges::input_range R>
    struct elements_of {
        R&& range_; // \expos
        
        explicit constexpr elements_of(R&& r) noexcept;
        constexpr elements_of(elements_of&&) = default;
        
        constexpr elements_of(const elements_of&) = delete;
        constexpr elements_of& operator=(const elements_of&) = delete;
        constexpr elements_of& operator=(elements_of&&) = delete;
        
        constexpr R && get() && noexcept;
    };
    template<std::ranges::input_range R>
    elements_of(R&&) -> return elements_of<R>;   

}
\end{codeblock}

\begin{itemdecl}
explicit constexpr elements_of(R&& r) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects   Initializes \tcode{range_} with \tcode{forward<R>(r)}.
\end{itemdescr}

\begin{itemdecl}
constexpr R && get() && noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{forward<R>(range_)}.
\end{itemdescr}

\pagebreak

\rSec2[generator.syn]{Header \tcode{<generator>} synopsis}


\begin{codeblock}

#include <coroutine>
#include <ranges>
    
namespace std {      
    
    template<class Ref, 
        common_reference_with<Ref> Value = remove_cvref_t<Ref>, 
        class Allocator = void>
    class generator;    
    
    template <class Ref, class Value, class Allocator>
    inline constexpr bool ranges::enable_view<generator<Ref, Value, Allocator>> = true;
}
    
\end{codeblock}


\rSec2[coroutine.generator]{Generator View}

\rSec3[coroutine.generator.overview]{Overview}


\tcode{generator} generates a sequence of elements by repeatedly resuming the coroutine it was returned from.
When the coroutine is resumed, it is executed until it reaches either a \tcode{co_yield} expression or the end of the coroutine.

Elements of the sequence are produced by the coroutine each time a \tcode{co_yield} expression is evaluated.

When the \tcode{co_yield} expression is of the form \tcode{co_yield elements_of(rng)}, each element of the range \tcode{rng} is successively produced
as an element of the generator.

\tcode{generator} models \tcode{view} and \tcode{input_view}.


\begin{example}
    \begin{codeblock}
        generator<int> iota(int start = 0) {
            while(true)
                co_yield start++;
        }
        
        void f() {
            for(auto i : iota() | views::take(3))
            cout << i << " " ; // prints 0 1 2
        }
        
    \end{codeblock}
\end{example}


\rSec3[coroutine.generator.class]{Class template \tcode{generator}}

\begin{codeblock}
    
namespace std {
    
template <class Ref, common_reference_with<Ref> Value = remove_cvref_t<Y>, 
          class Allocator = void>
class generator  {
    class promise_type_; // \expos

public:
    using promise_type = promise_type_;
    
    class iterator; // \expos
    class sentinel {}; // \expos
   
    generator() noexcept = default;
    generator(const generator &other) = delete;
    generator(generator && other) noexcept;
    
    ~generator();
    
    generator &operator=(generator other) noexcept;
    
    iterator begin();
    sentinel end() const noexcept;
    
private:
    std::coroutine_handle<promise_type> coroutine_ = nullptr; // \expos
    bool started_ = false; // \expos
    
    explicit generator(std::coroutine_handle<promise_type> coroutine) noexcept; // \expos
    
};
}

     
\end{codeblock}

\begin{itemize}
\item \tcode{coroutine_traits<generator<Ref, Value, Allocator>>::promise_type} is valid an denotes a type,
\item \tcode{Allocator} either meets the \tcode{Cpp17Allocator} requirements or is \tcode{void}.
\end{itemize}

\begin{itemdecl}
generator(std::coroutine_handle<promise_type> coro) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{coroutine_} with \tcode{coro}.
\end{itemdescr}



\begin{itemdecl}
generator(generator &&other) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{coroutine_} with \tcode{exchange(other.coroutine_, \{\})}, \\and \tcode{started_} with \tcode{exchange(other.started_, false)}.
\end{itemdescr}

\begin{itemdecl}
~generator() noexcept;
\end{itemdecl}

\begin{itemdescr}
    \effects equivalent to:
    \begin{codeblock}
    if (coroutine_) {
        coroutine_.destroy();
    }
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
generator &operator=(generator other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects equivalent to:
\begin{codeblock}
    swap(coro_, other.coro_);
    swap(started_, other.started_);
\end{codeblock}
\end{itemdescr}



\begin{itemdecl}
iterator begin();
\end{itemdecl}


\begin{itemdescr}
\preconditions
\begin{itemize}
\item \tcode{!coroutine_} is \tcode{true} or \tcode{coroutine_} refers to a coroutine
suspended at its initial suspend-point,
\item \tcode{started_} is false.
\end{itemize}

\effects
Equivalent to:
\begin{codeblock}
    if(coroutine_) {
        started_ = true;
        coroutine_.resume();
    }
    return iterator{coroutine_};
\end{codeblock}

\begin{note}
    It is undefined behavior to call \tcode{begin} multiple times on the same coroutine.
\end{note}
\end{itemdescr}


\begin{itemdecl}
sentinel end();
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{sentinel\{\}}.
\end{itemdescr}


\rSec3[coroutine.generator.promise]{Exposition-only class template \tcode{generator::promise_type_}}

\begin{codeblock}
    
template <class Ref, class Value, class Allocator>
class generator<Ref, Value, Allocator>::promise_type_ {
    
    friend generator;
    
    union {
        Ref value_; // \expos
    };     
    
public:
    
    generator<Ref, Value, Allocator> get_return_object() noexcept;
    
    suspend_always initial_suspend() noexcept;
    
    auto final_suspend() noexcept;
    
    suspend_always yield_value(Ref && value)
        noexcept(is_nothrow_move_constructible_v<Ref>);
    
    template <class T>
      requires (!is_reference_v<Ref>) && is_convertible_v<T, Ref> 
    suspend_always yield_value(T&& x) noexcept(is_nothrow_constructible_v<Ref, T>);
    
    template <class TVal, class TAlloc> 
    @\unspec@ yield_value(elements_of<generator<Ref, TVal, TAlloc>> g) noexcept; // \seebelownc
    
    template<ranges::input_range R>
      requires convertible_to<ranges::range_reference_t<R>, Ref>
    @\unspec@ yield_value(elements_of<R> rng); // \seebelownc
    
    void await_transform() = delete;
    
    void return_void() noexcept {}
    
    void unhandled_exception();
    
    static void* operator new(size_t size) requires same_as<Allocator, void>;
    static void* operator new(size_t size) requires (!same_as<Allocator, void> && is_default_constructible_v<Allocator>);
    
    template<typeame Alloc, class... Args>
    static void* operator new(size_t size, allocator_arg_t, Alloc& alloc, Args&...);

    template<class This, typeame Alloc, class... Args>
    static void* operator new(size_t size, This&, allocator_arg_t, Alloc& alloc, Args&...);
    
    static void operator delete(void* pointer, size_t size) noexcept;
};  
\end{codeblock}




\begin{itemdecl}
generator<Ref, Value, Allocator> get_return_object() noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to:
\begin{codeblock}
    return generator<Ref, Value, Allocator>{
        coroutine_handle<promise_type>::from_promise(*this)};
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
suspend_always initial_suspend() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{suspend_always\{\}}.
\end{itemdescr}


\begin{itemdecl}
suspend_always yield_value(Ref&& x) 
    noexcept(is_nothrow_move_constructible_v<Ref>);
\end{itemdecl}
\begin{itemdecl}
template <class T>
  requires (!is_reference_v<Ref>) && is_convertible_v<T, Ref> 
suspend_always yield_value(T&& x) 
    noexcept(is_nothrow_constructible_v<Ref, T>);
\end{itemdecl}

\begin{itemdescr}
\effects
Initialises \tcode{value_} from \tcode{static_cast<decltype(x)>(x)};
\returns \tcode{suspend_always\{\}}.
\end{itemdescr}


\begin{itemdecl}
template <class TVal, class TAlloc> 
auto yield_value(elements_of<generator<Ref, TVal, TAlloc>> g) noexcept;
\end{itemdecl}

\begin{itemdescr}
    
\mandates
\begin{itemize}
\item \tcode{TAlloc} meets the \tcode{Cpp17Allocator} requirements,
\end{itemize}
    
\effects
This function returns an implementation defined \tcode{awaitable} type which takes ownership of the generator \tcode{g}.

Execution is transferred to the coroutine represented by \tcode{g.coroutine_} until its completion. 
After \tcode{g.coroutine_} completes, the current coroutine is resumed.
If \tcode{g.coroutine_} completes with an exception, the exception is rethrown from the `co_yield` expression.

Variables with automatic storage duration in the scope of the coroutine represented by \tcode{g.coroutine_} are destroyed
before variables with automatic storage duration in the scope of the coroutine denoted by this coroutine.

\begin{note}
Generators can transfer control recursively.
\end{note}
    
\end{itemdescr}


\begin{itemdecl}
template<std::ranges::input_range R>
  requires convertible_to<ranges::range_reference_t<R>, Ref>
std::suspend_always yield_value(elements_of<R> rng);
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
{
    auto it = std::ranges::begin(rng.get());
    auto itEnd = std::ranges::end(rng.get());
    while (it != itEnd) {
        co_yield *it;
        ++it;
    }
}
\end{codeblock}
Calls \tcode{co_yield elem} for each element \tcode{elem} of the range \tcode{rng.get()}. 

\returns A implementation-defined \tcode{awaitable} 
type which takes ownership of the generator returned by \tcode{get_return_object()}.

\end{itemdescr}

\begin{itemdecl}
void unhandled_exception();
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to: \tcode{throw;}
\end{itemdescr}

\begin{itemdecl}
static void* operator new(size_t size) requires same_as<Allocator, void>;
\end{itemdecl}

\begin{itemdescr}
\effects Allocates the coroutine state with \tcode{std::allocator}.
\end{itemdescr}

\begin{itemdecl}
static void* operator new(size_t size) requires (!same_as<Allocator, void> && is_default_constructible_v<Allocator>);
\end{itemdecl}

\begin{itemdescr}
\effects Allocates the coroutine state with a default-constructed instance of \tcode{Allocator}.
\end{itemdescr}


\begin{itemdecl}
template<typeame Alloc, class... Args>
static void* operator new(size_t size, allocator_arg_t, Alloc& alloc, Args&...);

template<class This, typeame Alloc, class... Args>
static void* operator new(size_t size, This&, allocator_arg_t, Alloc& alloc, Args&...);
\end{itemdecl}

\begin{itemdescr}
 
\mandates
\begin{itemize}
\item \tcode{same_as<Allocator, void> || convertible_to<Alloc, Allocator>} is \tcode{true},
\item \tcode{Alloc} meets the \tcode{Cpp17Allocator} requirements,
\end{itemize}   
    
\effects Allocates the coroutine state with \tcode{Alloc}.

\begin{note}
If \tcode{std::allocator_traits<Alloc>::is_always_equal::value} is \tcode{false} or if \tcode{is_default_constructible_v<Alloc>} is \tcode{false}, \tcode{alloc} is stored in the allocation for the coroutine state.
\end{note}

\end{itemdescr}

\begin{itemdecl}
static void operator delete(void* pointer, size_t size) noexcept;
\end{itemdecl}

\begin{itemdescr}
Deallocate the coroutine state with an instance of the allocator equivalent to the one that was use to allocate it.
\end{itemdescr}

\rSec3[coroutine.generator.iterator]{Class template \tcode{generator::iterator}}

\begin{codeblock}
    
template <class Ref, class Value, class Allocator>
class generator<Ref, Value, Allocator>::iterator {
private:
    std::coroutine_handle<promise_type> coroutine_; // \expos
    
public:    
    using iterator_category = std::input_iterator_tag;
    using difference_type = std::ptrdiff_t;
    using value_type = promise_type::value_type;
    using reference = promise_type::reference;
    
    iterator() noexcept = default;

    iterator(const iterator&) = delete;
    
    iterator(iterator&& other) noexcept;
    
    iterator& operator=(iterator&& other) noexcept;
    
    explicit iterator(std::coroutine_handle<promise_type> coroutine) noexcept; // \expos
    
    bool operator==(sentinel) const noexcept;
    
    iterator& operator++();
    void operator++(int);
    
    reference operator*() const noexcept(std::is_nothrow_copy_constructible_v<reference>);
    
}; 
    
\end{codeblock}

\begin{itemdecl}
 iterator(iterator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{coroutine_} with \tcode{exchange(other.coroutine_, \{\})}.
\end{itemdescr}


\begin{itemdecl}
iterator& operator=(iterator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to \tcode{coroutine_ = exchange(other.coroutine_, \{\});}
\end{itemdescr}

\begin{itemdecl}
explicit iterator(std::coroutine_handle<promise_type> coroutine) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{coroutine_} with \tcode{coroutine}.
\end{itemdescr}


\begin{itemdecl}
bool operator==(sentinel) const noexcept
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{!coroutine_ || coroutine_.done()}.
\end{itemdescr}

\begin{itemdecl}
iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{coroutine_ \&\& !coroutine_.done()} is \tcode{true}.

\effects
Equivalent to:
\begin{codeblock}
    coroutine_.resume();
    return *this;
\end{codeblock}
\end{itemdescr}


\begin{itemdecl}
void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{coroutine_ \&\& !coroutine_.done()} is \tcode{true}.

\effects
Equivalent to:
\begin{codeblock}
    (void)operator++();
\end{codeblock}
\end{itemdescr}


\begin{itemdecl}
reference operator*() const 
noexcept (noexcept(std::is_nothrow_copy_constructible_v<reference>));
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{coroutine_ \&\& !coroutine_.done()} is \tcode{true}.

\effects
Equivalent to:
\begin{codeblock}
    return coroutine_.promise().value();
\end{codeblock}
\end{itemdescr}
    
       
\end{addedblock}

\section{Feature test macros}

Insert into [version.syn]

\begin{addedblock}
\begin{codeblock}
    #define __cpp_lib_generator <DATE OF ADOPTION> // also in <ggenerator>
\end{codeblock}
\end{addedblock}
    
    
\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21}

\begin{thebibliography}{9}
    \bibitem[CppCoro]{CppCoro}
    Lewis Baker
    \emph{CppCoro: A library of C++ coroutine abstractions for the coroutines TS}\newline
    \url{https://github.com/lewissbaker/cppcoro}
    
    \bibitem[Folly]{Folly}
    Facebook
    \emph{Folly: An open-source C++ library developed and used at Facebook}\newline
    \url{https://github.com/facebook/folly}
    
    
    \bibitem[range]{range-v3}
    Eric Niebler
    \emph{range-v3 Range library for C++14/17/20}\newline
    \url{https://github.com/ericniebler/range-v3}
    
    \bibitem[Implementation]{Implementation}
    Lewis Baker, Corentin Jabot
    \emph{\tcode{std::generator} implementation}\newline
    \url{https://godbolt.org/z/eoPeTY}
    
    \bibitem[N4861]{N4861}
    Richard Smith
    \emph{Working Draft, Standard for Programming Language C++}\newline
    \url{https://wg21.link/N4861}
    
    
\end{thebibliography}
    
\end{document}
