% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}

\title{Compatibility between \tcode{tuple}, \tcode{pair} and \placeholder{tuple-like} objects}
\docnumber{P2165R2}
\audience{LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle

\paperquote{A tuple by any other name would unpack just as well - Shakespair}

\section{Abstract}

We propose to make \tcode{pair} constructibke from \tcode{tuple} and \tcode{std::array}
We mandate \tcode{tuple_cat} and friends to be compatible with these types, 
and associative containers more compatible with them.

\section{Revisions}

\subsection{R3}

Reduce the scope to types that have a \tcode{get} method in the \tcode{std::} namespace.
In effect only \tcode{tuple}, \tcode{pair}, \tcode{array} and \tcode{ranges::subrange} are \tcode{tuple-like}
with that definition.
The intent is to extend to user-provided types later once \tcode{std::get} or equivalent is defined as a customization-point.
Limiting to \tcode{std::get} allows to unconditionally use \tcode{std::tuple} as the reference type of \tcode{zip}, \tcode{cartesian_product} in C++23.

\begin{itemize}
\item Missing default template parameter types in added \tcode{std::map} constructor
\end{itemize}



\subsection{R2}

The scope and design have changed quite a bit since R1. First, R1 failed to account for most tuple-like things like \tcode{array}.
Second, R2 also modifies associative containers to accept tuple-like objects.

\subsection{R1}
\begin{itemize}
    \item The wording in R0 was non-sensical
    \item Add a note on deduction guide
    \item Modify \tcode{tuple_cat} to unconditionally support \tcode{tuple-like} entities
\end{itemize}


\section{Tony tables}
\begin{center}
\begin{tabular}{l|l}
Before & After\\ \hline

\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}

constexpr std::pair  p {1, 3.0};
constexpr std::tuple t {p}; // OK

std::pair<int, double> pp
             (get<0>(t), get<1>(t));
    
static_assert(std::tuple(p) == t);

static_assert(@\textcolor{red}{p == t}@);
static_assert(@\textcolor{red}{p <=> t == 0}@);

@\textcolor{red}{std::tuple<int,int> t = std::array \{1, 2\};}@




std::map m{
    std::pair{get<0>(t), get<1>(t)},
    std::pair{get<0>(u), get<1>(u)}
};


static_assert(same_as<std::tuple<int>,
    range_value_t<decltype(views::zip(v))>>);

static_assert(same_as<std::pair<int,int>,
    range_value_t<decltype(views::zip(v, v))>>);
    

// x is std::tuple<int, int> 
// because tuple is convertible from pair
auto x = true ? tuple{0,0} : pair{0,0}; 


\end{colorblock}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}

constexpr std::pair  p {1, 3.0};
constexpr std::tuple t {p}; // OK

std::pair<int, double> pp{t};


static_assert(std::tuple(p) == t);

static_assert(p == t);
static_assert(p <=> t == 0);

std::tuple<int,int> t = std::array {1, 2};

// not the same size: ill-formed
@\textcolor{red}{std::tuple<int> t = std::array \{1, 2\};}@

std::map m{t, u};



static_assert(<std::tuple<int>,
    range_value_t<decltype(views::zip(v))>>);

static_assert(same_as<std::tuple<int,int>,
    range_value_t<decltype(views::zip(v, v))>>);
    
    
    
    
// Both types are interconvertible,
// The expression is ambiguous an this is ill-formed
@\textcolor{red}{auto x = true ?  tuple\{0,0\} : pair\{0,0\};} 

\end{colorblock}
\end{minipage}
\\\\ \hline

\end{tabular}
\end{center}

\textcolor{red}{Red text is ill-formed}

\section{Motivation}

\tcode{pair}s are platonic tuples of 2 elements. \tcode{pair} and \tcode{tuple} share
most of their interface.

Notably, a tuple can be constructed and assigned from a pair, but the reverse is not true.
Tuple and pairs cannot be compared.

Having both types in the standard library is somewhat redundant - as noted in \paper{N2270} - a problem that \paper{N2533}
tried to address before C++, alas unsuccessfully.

We are not proposing to get rid of \tcode{pair}.
However, we are suggesting that maybe new facilities should use \tcode{tuple}, or when appropriate, a structure with named members.
The authors of \paper{N2270}, circa 2007, observed:

\begin{quoteblock}
There is very little reason, other than history, for the library to contain both \tcode{pair<T, U>} and \tcode{tuple<T, U>}. If we do deprecate pair, then we should change all interfaces in the library that use it, including the associative containers, to use \tcode{tuple} instead. This will be a source-incompatible change, but it need not be ABI-breaking.
\end{quoteblock}

As \tcode{pair} will continue to exist, it should still be possible for users of the standard library to ignore its existence, which can be achieved by making sure pairs are constructible from tuple, and types that are currently constructible from \tcode{pair} can be constructed from another kind of \tcode{tuple}.

For example, associative containers deal in pairs, and they do not allow construction from sequences of tuples. This has forced ranges (\tcode{zip}: \paper{P2321R1}, \tcode{carthesian_product}: \paper{P2374R0}) to deal in \tcode{pair} when dealing with tuples of 2 elements.

\tcode{view_of_tuples | to<map>} currently doesn't work, and we think it should.

%Lastly, while there is support for \tcode{enumerate} to have a reference type with named members, there is also a desire
%that \tcode{enumerate(container) | to<map>} should work.
%In general, it is ridiculously hard and costly to make simple structs that can be used as reference types of ranges.
%With the proposed changes, any named type that implements the tuple protocol shares a common reference with the corresponding tuple if the members themselves have a common reference.

%As such, only
%\begin{itemize}
%\item \tcode{tuple_element}
%\item \tcode{tuple_size}
%\item \tcode{get}
%\end{itemize}
%
%need to be provided for a range's reference's type to be any type, as long as the value type is a tuple.
%
%This paper takes care of providing a \tcode{basic_common_reference} and a \tcode{basic_common_type}
%between \tcode{tuple} and tuple-like entities.
%\paper{P1858R2} and \paper{P1096R0} explores ways to simplify further the tuple protocol.
%
Standard types supporting the tuple protocol include

\begin{itemize}
\item \tcode{pair}
\item \tcode{tuple}
\item \tcode{array}
\item \tcode{subrange}
\item the proposed \tcode{enumerate}'s \tcode{reference} type.
%\item \tcode{span} of static extent- \textbf{prior to \paper{P2116R0} which removed that support}
\end{itemize}

%\subsection{C arrays and aggregate}
%
%C arrays and aggregate are supported by structured bindings, but this mechanism does not use the tuple protocol.
%As such, these types will not be convertible to \tcode{tuple} with this paper.


\section{Design}

We introduce an exposition only concept \tcode{tuple-like} which can then be used in the definition of \tcode{tuple} and \tcode{pair} construction,
comparison and assignment operators.
%A type satisfies \tcode{\placeholder{tuple-like}} if it implements the tuple protocol (\tcode{std::get, std::tuple_element, std::tuple_size}).
%
%The concept is a generalization of the \placeholder{pair-like} exposition-only concept used by \tcode{subrange} and \tcode{views::values}/\tcode{views::keys}.

With that concept, we

\begin{itemize}
    \item Allow a \tcode{tuple} to be constructed, assigned and compared with any tuple-like object \textbf{of the same size}.
    \item Allow a \tcode{pair} to be constructed, assigned and compared with any tuple-like object of size 2.
    \item With \tcode{pair} constructible from any-tuple-like object, we allow associative containers (like map) construction and insertion from any tuple-like object.
    Note that these containers already support insertion/ emplacement from types that their value types is constructible from, so only construction from \tcode{std::initializer_list},
    deduction guides and maybe iterator constructors need change.
    \item Can use \tcode{tuple} in \tcode{zip} and similar views consistently, in the 2 views case.
    %\item Can design \tcode{enumerate} as proposed by \paper{P2164R5}.
\end{itemize}

\textbf{The intent of this paper is not to modify the behavior of tuple's and pair's members. In particular, it does not intend to change the behavior of well-formed existing code in regard
to the constraints, \tcode{noexcept} and \tcode{explicit} specifications placed on existing methods, but only to allow these same methods to work with more types that expose the same semantics as tuple and pair do.}

In comparisons, one of the 2 objects has to be a \tcode{tuple}, or a \tcode{pair}. This is done so that comparison operators can be made hidden friends, in order to avoid enormous overload sets.

We also make \tcode{tuple_cat} support any \tcode{\placeholder{tuple-like}} parameter.
This is conditionally supported by implementations already.
% (but may be restricted to pair and array, we generalize that).

%\subsection{Questions For LEWG}
%
%Should \tcode{tuple-like} and \tcode{pair-like} be named concepts (as opposition to exposition only) ?

\subsection{CTAD issues}

A previous version of this paper modified the deduction guides to using the tuple-like constructors for tuple-like objects.

But this would change the meaning of \tcode{tuple \{array<int, 2>\{\}\}}.
The current version does not add or modify deduction guides.
As such, \tcode{tuple \{boost::tuple<int, int>\{\}\}} is deduced as \tcode{std::tuple<boost::tuple<int, int>>}

This is obviously not ideal, but, it is a pre-exising problem in C++20. \tcode{tuple {pair<int, int> {}} } is currently deduced to \tcode{std::tuple<int, int>},
while other tuple-like objects T are deduced as \tcode{std::tuple<T>}, which may be surprising.
This is the same problem that all deduction guides involving wrapper types, and may require a more comprehensive fix, for example:

\begin{colorblock}
tuple {pair, pair } // ok
tuple {pair} // ill-formed / deprecated
tuple {std::of_value, pair }  // tuple<pair<foo, bar>>
tuple {std::of_elems, pair }  // tuple<foo, bar>
\end{colorblock}

While we could add a non-ambiguous guide for pair, we think it's better for \tcode{pair} and \tcode{tuple} to remain consistent.

\textbf{We do not propose modifications to CTAD constructors}


\subsection{\textcolor{Red}{Breaking API changes}}

Before this paper, \tcode{tuple} was constructible from \tcode{pair},
but the opposite was not true.

As such \tcode{expr ? apair : atuple} would resolve unambiguously to a tuple.

Because this changes makes both \tcode{pair} and \tcode{tuple} constructible from each other,
the expression is now ambiguous.

This proposal is therefore a breaking change.
However it is unlikely that this pattern exists in practice.
It can be resolved by casting either expression to the type of the other.

Similar expressions such as \tcode{true ? std::tuple\{0.\} : std::tuple\{0\}} are ill-formed in C++20 because they are ambiguous.


\subsection{Implementation}

This proposal has been implemented in libstdc++ \href{https://github.com/cor3ntin/gcc/tree/tuple_pair2}{[Github]}.

\section{Future work}

Tuple comparison operators are good candidates for hidden friends.

\section{Wording}


\rSec2[tuple.syn]{Header \tcode{<tuple>} synopsis}
\begin{codeblock}
#include <compare>              // see \ref{compare.syn}

namespace std {
// \ref{tuple.tuple}, class template \tcode{tuple}
template<class... Types>
class tuple;

\end{codeblock}
\begin{removedblock}
\begin{codeblock}
template<class... TTypes, class... UTypes, template<class> class TQual,
template<class> class UQual>
requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
    using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
};

template<class... TTypes, class... UTypes>
requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
struct common_type<tuple<TTypes...>, tuple<UTypes...>> {
    using type = tuple<common_type_t<TTypes, UTypes>...>;
};
\end{codeblock}
\end{removedblock}

\begin{addedblock}
\begin{codeblock}
template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
struct basic_common_reference<TTuple, UTuple, TQual, UQual>;

template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
struct basic_common_type<TTuple, UTuple, TQual, UQual>;
\end{codeblock}
\end{addedblock}
\begin{codeblock}

\end{codeblock}
\begin{addedblock}
\begin{codeblock}
template <typename T, std::size_t N>
concept  @\placeholder{is-tuple-element}@ = requires (T t) {  // \expos
    typename std::tuple_element_t<N, std::remove_const_t<T>>;
    { @\textbf{std::}@get<N>(t) } -> std::convertible_to<std::tuple_element_t<N, T>&>;
};


template <typename T>
concept @\placeholder{tuple-like}@ // \expos
= !is_reference_v<T> && requires  {
    typename tuple_size<T>::type;
    requires same_as<decltype(tuple_size_v<T>), size_t>;
} && []<std::size_t... I>(std::index_sequence<I...>)
{ return (@\placeholder{is-tuple-element}@<T, I> && ..); }(std::make_index_sequence<tuple_size_v<T>>{});

template <typename T>
concept @\placeholder{pair-like}@ // \expos
= @\placeholder{tuple-like}@<T> && std::tuple_size_v<T> == 2;
    
\end{codeblock}
\end{addedblock}
\begin{codeblock}

// \ref{tuple.creation}, tuple creation functions
inline constexpr @\unspec@ ignore;

template<class... TTypes>
constexpr tuple<unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&...);

template<class... TTypes>
constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&...) noexcept;

template<class... TTypes>
constexpr tuple<TTypes&...> tie(TTypes&...) noexcept;

template<@\changed{class}{\placeholder{tuple-like}}@... Tuples>
constexpr tuple<CTypes...> tuple_cat(Tuples&&...);

// \ref{tuple.apply}, calling a function with a tuple of arguments
template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t);

template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
constexpr T make_from_tuple(Tuple&& t);

// \ref{tuple.helper}, tuple helper classes
template<class T> struct tuple_size;                  // \notdef
template<class T> struct tuple_size<const T>;

template<class... Types> struct tuple_size<tuple<Types...>>;

template<size_t I, class T> struct tuple_element;     // \notdef
template<size_t I, class T> struct tuple_element<I, const T>;

template<size_t I, class... Types>
struct tuple_element<I, tuple<Types...>>;

template<size_t I, class T>
using tuple_element_t = typename tuple_element<I, T>::type;

// \ref{tuple.elem}, element access
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>& get(tuple<Types...>&) noexcept;
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&& get(tuple<Types...>&&) noexcept;
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>& get(const tuple<Types...>&) noexcept;
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>&& get(const tuple<Types...>&&) noexcept;
template<class T, class... Types>
constexpr T& get(tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr T&& get(tuple<Types...>&& t) noexcept;
template<class T, class... Types>
constexpr const T& get(const tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr const T&& get(const tuple<Types...>&& t) noexcept;

// [tuple.rel], relational operators
template<class... TTypes, class... UTypes>
constexpr bool operator==(const tuple<TTypes...>&, const UTuple&);\end{codeblock}
\begin{addedblock}
\begin{codeblock}
template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr bool operator==(const tuple<TTypes...>&, const UTuple&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}

template<class... TTypes, class... UTypes>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, UTypes...>
operator<=>(const tuple<TTypes...>&, const tuple<UTypes...>&);\end{codeblock}
\begin{addedblock}
\begin{codeblock}

template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, @\seebelow@...>
operator<=>(const tuple<TTypes...>&, const UTuple&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}

// \ref{tuple.traits}, allocator-related traits
template<class... Types, class Alloc>
struct uses_allocator<tuple<Types...>, Alloc>;

// \ref{tuple.special}, specialized algorithms
template<class... Types>
constexpr void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(@\seebelow@);
template<class... Types>
constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(@\seebelow@);

// \ref{tuple.helper}, tuple helper classes
template<class T>
inline constexpr size_t tuple_size_v = tuple_size<T>::value;
}
\end{codeblock}

\rSec2[tuple.tuple]{Class template \tcode{tuple}}
\indexlibraryglobal{tuple}%

\begin{codeblock}
namespace std {
template<class... Types>
class tuple {
    public:
    // \ref{tuple.cnstr}, \tcode{tuple} construction
    constexpr explicit(@\seebelow@) tuple();
    constexpr explicit(@\seebelow@) tuple(const Types&...); // only if \tcode{sizeof...(Types) >= 1}
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(UTypes&&...); // only if \tcode{sizeof...(Types) >= 1}
    
    tuple(const tuple&) = default;
    tuple(tuple&&) = default;
    
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(tuple<UTypes...>&);
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(const tuple<UTypes...>&);
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(tuple<UTypes...>&&);
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(const tuple<UTypes...>&&);
    
    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(pair<U1, U2>&);  // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>&); // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(pair<U1, U2>&&);   // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>&&); // only if \tcode{sizeof...(Types) == 2}
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(UTuple&);
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(const UTuple&);
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(UTuple&&);
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(UTuple&&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    // allocator-extended constructors
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a);
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class Alloc, @\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(allocator_arg_t, const Alloc& a, UTuple&);
    template<class Alloc, @\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(allocator_arg_t, const Alloc& a, const UTuple&);
    template<class Alloc, @\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(allocator_arg_t, const Alloc& a, UTuple&&);
    template<class Alloc, @\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(allocator_arg_t, const Alloc& a, const UTuple&&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    // \ref{tuple.assign}, \tcode{tuple} assignment
    constexpr tuple& operator=(const tuple&);
    constexpr const tuple& operator=(const tuple&) const;
    constexpr tuple& operator=(tuple&&) noexcept(@\seebelow@);
    constexpr const tuple& operator=(tuple&&) const;
    
    template<class... UTypes>
    constexpr tuple& operator=(const tuple<UTypes...>&);
    template<class... UTypes>
    constexpr const tuple& operator=(const tuple<UTypes...>&) const;
    template<class... UTypes>
    constexpr tuple& operator=(tuple<UTypes...>&&);
    template<class... UTypes>
    constexpr const tuple& operator=(tuple<UTypes...>&&) const;
    
    template<class U1, class U2>
    constexpr tuple& operator=(const pair<U1, U2>&);          // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr const tuple& operator=(const pair<U1, U2>&) const;
    // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr tuple& operator=(pair<U1, U2>&&);               // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr const tuple& operator=(pair<U1, U2>&&) const;   // only if \tcode{sizeof...(Types) == 2}
    
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr tuple& operator=(UTuple&);
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr const tuple& operator=(UTuple&) const;
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr tuple& operator=(UTuple&&);
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr const tuple& operator=(UTuple&&) const;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    
    // \ref{tuple.swap}, \tcode{tuple} swap
    constexpr void swap(tuple&) noexcept(@\seebelow@);
    constexpr void swap(const tuple&) const noexcept(@\seebelow@);
};

template<class... UTypes>
tuple(UTypes...) -> tuple<UTypes...>;
template<class T1, class T2>
tuple(pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;
template<class Alloc, class T1, class T2>
tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, tuple<UTypes...>) -> tuple<UTypes...>;
}
\end{codeblock}

\rSec3[tuple.cnstr]{Construction}

\pnum
In the descriptions that follow, let $i$ be in the range
\range{0}{sizeof...(Types)} in order, $\tcode{T}_i$
be the $i^\text{th}$ type in \tcode{Types}, and
$\tcode{U}_i$ be the $i^\text{th}$ type in a template parameter pack named \tcode{UTypes}, where indexing
is zero-based.

\pnum
For each \tcode{tuple} constructor, an exception is thrown only if the construction of
one of the types in \tcode{Types} throws an exception.

\pnum
The defaulted move and copy constructor, respectively, of
\tcode{tuple} is a constexpr function if and only if all
required element-wise initializations for move and copy, respectively,
would satisfy the requirements for a constexpr function. The
defaulted move and copy constructor of \tcode{tuple<>} are
constexpr functions.

\pnum
If \tcode{is_trivially_destructible_v<$\tcode{T}_i$>} is \tcode{true} for all $\tcode{T}_i$,
then the destructor of \tcode{tuple} is trivial.

\pnum
The default constructor of \tcode{tuple<>} is trivial.

\indexlibraryctor{tuple}%
\begin{itemdecl}
    constexpr explicit(@\seebelow@) tuple();
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \tcode{is_default_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
    
    \pnum
    \effects
    Value-initializes each element.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} evaluates to \tcode{true}
    if and only if $\tcode{T}_i$ is not
    copy-list-initializable from an empty list
    for at least one $i$.
    \begin{note}
        This behavior can be implemented with a trait that checks whether
        a \tcode{const $\tcode{T}_i$\&} can be initialized with \tcode{\{\}}.
    \end{note}
\end{itemdescr}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    constexpr explicit(@\seebelow@) tuple(const Types&...);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    $\tcode{sizeof...(Types)} \geq 1$ and
    \tcode{is_copy_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
    
    \pnum
    \effects
    Initializes each element with the value of the
    corresponding parameter.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !conjunction_v<is_convertible<const Types&, Types>...>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<class... UTypes> constexpr explicit(@\seebelow@) tuple(UTypes&&... u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Let \exposid{disambiguating-constraint} be:
    \begin{itemize}
        \item
        \tcode{negation<is_same<remove_cvref_t<$\tcode{U}_0$>, tuple>>}
        if \tcode{sizeof...(Types)} is 1;
        \item
        otherwise,
        \tcode{bool_constant<!is_same_v<remove_cvref_t<$\tcode{U}_0$>, allocator_arg_t> ||
            is_-\newline{}same_v<remove_cvref_t<$\tcode{T}_0$>, allocator_arg_t>>}
        if \tcode{sizeof...(Types)} is 2 or 3;
        \item
        otherwise, \tcode{true_type}.
    \end{itemize}
    
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)},
        \item
        $\tcode{sizeof...(Types)} \geq 1$, and
        \item
        \tcode{conjunction_v<\exposid{disambiguating-constraint},
            is_constructible<Types, UTypes>...>} is\newline \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Initializes the elements in the tuple with the
    corresponding value in \tcode{std::forward<UTypes>(u)}.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !conjunction_v<is_convertible<UTypes, Types>...>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    tuple(const tuple& u) = default;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    \tcode{is_copy_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
    
    \pnum
    \effects
    Initializes each element of \tcode{*this} with the
    corresponding element of \tcode{u}.
\end{itemdescr}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    tuple(tuple&& u) = default;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \tcode{is_move_constructible_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
    
    \pnum
    \effects
    For all $i$, initializes the $i^\text{th}$ element of \tcode{*this} with
    \tcode{std::forward<$\tcode{T}_i$>(get<$i$>(u))}.
\end{itemdescr}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<class... UTypes> constexpr explicit(@\seebelow@) tuple(tuple<UTypes...>& u);
    template<class... UTypes> constexpr explicit(@\seebelow@) tuple(const tuple<UTypes...>& u);
    template<class... UTypes> constexpr explicit(@\seebelow@) tuple(tuple<UTypes...>&& u);
    template<class... UTypes> constexpr explicit(@\seebelow@) tuple(const tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Let \tcode{I} be the pack \tcode{0, 1, ..., (sizeof...(Types) - 1)}.\newline
    Let \tcode{\exposid{FWD}(u)} be \tcode{static_cast<decltype(u)>(u)}.
    
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)}, and
        \item
        \tcode{(is_constructible_v<Types, decltype(get<I>(\exposid{FWD}(u)))> \&\& ...)}
        is \tcode{true}, and
        \item
        either \tcode{sizeof...(Types)} is not 1, or
        (when \tcode{Types...} expands to \tcode{T} and
        \tcode{UTypes...} expands to \tcode{U})
        \tcode{is_convertible_v<decltype(u), T>},
        \tcode{is_constructible_v<T, decltype(u)>}, and
        \tcode{is_same_v<T, U>} are all \tcode{false}.
    \end{itemize}
    
    \pnum
    \effects
    For all $i$, initializes the $i^\textrm{th}$ element of \tcode{*this}
    with \tcode{get<$i$>(\exposid{FWD}(u))}.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !(is_convertible_v<decltype(get<I>(@\exposid{FWD}@(u))), Types> && ...)
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(pair<U1, U2>& u);
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>& u);
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(pair<U1, U2>&& u);
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Let \tcode{\exposid{FWD}(u)} be \tcode{static_cast<decltype(u)>(u)}.
    
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} is 2,
        \item
        \tcode{is_constructible_v<$\tcode{T}_0$, decltype(get<0>(\exposid{FWD}(u)))>} is \tcode{true}, and
        \item
        \tcode{is_constructible_v<$\tcode{T}_1$, decltype(get<1>(\exposid{FWD}(u)))>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Initializes the first element with \tcode{get<0>(\exposid{FWD}(u))} and
    the second element with \tcode{get<1>(\exposid{FWD}(\brk{}u))}.
    
    \pnum
    \remarks
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<decltype(get<0>(@\exposid{FWD}@(u))), @$\tcode{T}_0$@> ||
        !is_convertible_v<decltype(get<1>(@\exposid{FWD}@(u))), @$\tcode{T}_1$@>
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple> constexpr explicit(@\seebelow@) tuple(UTuple & u);
    template<@\placeholder{tuple-like}@ UTuple> constexpr explicit(@\seebelow@) tuple(const UTuple & u);
    template<@\placeholder{tuple-like}@ UTuple> constexpr explicit(@\seebelow@) tuple(UTuple&& u);
    template<@\placeholder{tuple-like}@ UTuple> constexpr explicit(@\seebelow@) tuple(const UTuple&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{I} be the pack \tcode{0, 1, ..., (sizeof...(Types) - 1)}.\newline
Let \tcode{UTypes} be the pack \tcode{tuple_element_t<0, UTuple>, tuple_element_t<0, UTuple>, ..., tuple_element_t<tuple_size_v<UTuple> -1, UTuple>}.\newline
Let \tcode{\exposid{FWD}(u)} be \tcode{static_cast<decltype(u)>(u)}.

\pnum
\constraints
\begin{itemize}
    \item
    \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<UTuple>}, and
    \item
    \tcode{(is_constructible_v<Types, decltype(get<I>(\exposid{FWD}(u)))> \&\& ...)}
    is \tcode{true}, and
    \item
    either \tcode{sizeof...(Types)} is not 1, or
    (when \tcode{Types...} expands to \tcode{T} and
    \tcode{UTypes...} expands to \tcode{U})
    \tcode{is_convertible_v<decltype(u), T>},
    \tcode{is_constructible_v<T, decltype(u)>}, and
    \tcode{is_same_v<T, U>} are all \tcode{false}.
\end{itemize}

\pnum
\effects
For all $i$, initializes the $i^\textrm{th}$ element of \tcode{*this}
with \tcode{get<$i$>(\exposid{FWD}(u))}.

\pnum
\remarks
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
    !(is_convertible_v<decltype(get<I>(@\exposid{FWD}@(u))), Types> && ...)
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a);
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);
    @\added{template<class Alloc, \placeholder{tuple-like} UTuple>}@
    @\added{constexpr explicit(\seebelow) tuple(allocator_arg_t, const Alloc\& a, UTuple\&);}@
    @\added{template<class Alloc, \placeholder{tuple-like} UTuple>}@
    @\added{constexpr explicit(\seebelow) tuple(allocator_arg_t, const Alloc\& a, const UTuple\&);}@
    @\added{template<class Alloc, \placeholder{tuple-like} UTuple>}@
    @\added{constexpr explicit(\seebelow) tuple(allocator_arg_t, const Alloc\& a, UTuple\&\&);}@
    @\added{template<class Alloc, \placeholder{tuple-like} UTuple>}@
    @\added{constexpr explicit(\seebelow) tuple(allocator_arg_t, const Alloc\& a, const UTuple\&\&);}@
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \expects
    \tcode{Alloc} meets the
    \oldconcept{Allocator} requirements (\tref{cpp17.allocator}).
    
    \pnum
    \effects
    Equivalent to the preceding constructors except that each element is constructed with
    uses-allocator construction\iref{allocator.uses.construction}.
\end{itemdescr}

\rSec3[tuple.assign]{Assignment}

\pnum
For each \tcode{tuple} assignment operator, an exception is thrown only if the
assignment of one of the types in \tcode{Types} throws an exception.
In the function descriptions that follow, let $i$ be in the range \range{0}{sizeof...\brk{}(Types)}
in order, $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Types},
and $\tcode{U}_i$ be the $i^\text{th}$ type in a
template parameter pack named \tcode{UTypes}, where indexing is zero-based.

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    constexpr tuple& operator=(const tuple& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding
    element of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
    
    \pnum
    \remarks
    This operator is defined as deleted unless
    \tcode{is_copy_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    constexpr const tuple& operator=(const tuple& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \tcode{(is_copy_assignable_v<const Types> \&\& ...)} is \tcode{true}.
    
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding element of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    constexpr tuple& operator=(tuple&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \tcode{is_move_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
    
    \pnum
    \effects
    For all $i$, assigns \tcode{std::forward<$\tcode{T}_i$>(get<$i$>(u))} to
    \tcode{get<$i$>(*this)}.
    
    \pnum
    \returns
    \tcode{*this}.
    
    \pnum
    \remarks
    The exception specification is equivalent to the logical \tcode{AND} of the
    following expressions:
    
    \begin{codeblock}
        is_nothrow_move_assignable_v<@$\mathtt{T}_i$@>
    \end{codeblock}
    where $\mathtt{T}_i$ is the $i^\text{th}$ type in \tcode{Types}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    constexpr const tuple& operator=(tuple&& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \tcode{(is_assignable_v<const Types\&, Types> \&\& ...)} is \tcode{true}.
    
    \pnum
    \effects
    For all $i$,
    assigns \tcode{std::forward<T$_i$>(get<$i$>(u))} to \tcode{get<$i$>(*this)}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<class... UTypes> constexpr tuple& operator=(const tuple<UTypes...>& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, const $\tcode{U}_i$\&>} is \tcode{true} for all $i$.
    \end{itemize}
    
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding element
    of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<class... UTypes> constexpr const tuple& operator=(const tuple<UTypes...>& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
        \item
        \tcode{(is_assignable_v<const Types\&, const UTypes\&> \&\& ...)} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding element of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<class... UTypes> constexpr tuple& operator=(tuple<UTypes...>&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, $\tcode{U}_i$>} is \tcode{true} for all $i$.
    \end{itemize}
    
    \pnum
    \effects
    For all $i$, assigns \tcode{std::forward<$\tcode{U}_i$>(get<$i$>(u))} to
    \tcode{get<$i$>(*this)}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<class... UTypes> constexpr const tuple& operator=(tuple<UTypes...>&& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
        \item
        \tcode{(is_assignable_v<const Types\&, UTypes> \&\& ...)} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    For all $i$,
    assigns \tcode{std::forward<U$_i$>(get<$i$>(u))} to \tcode{get<$i$>(*this)}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\indexlibraryglobal{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr tuple& operator=(const pair<U1, U2>& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} is 2 and
        \item \tcode{is_assignable_v<$\tcode{T}_0$\&, const U1\&>} is \tcode{true}, and
        \item \tcode{is_assignable_v<$\tcode{T}_1$\&, const U2\&>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns \tcode{u.first} to the first element of \tcode{*this}
    and \tcode{u.second} to the second element of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<class U1, class U2> constexpr const tuple& operator=(const pair<U1, U2>& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} is 2,
        \item
        \tcode{is_assignable_v<const $\tcode{T}_0$\&, const U1\&>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<const $\tcode{T}_1$\&, const U2\&>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns \tcode{u.first} to the first element and
    \tcode{u.second} to the second element.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\indexlibraryglobal{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr tuple& operator=(pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} is 2 and
        \item \tcode{is_assignable_v<$\tcode{T}_0$\&, U1>} is \tcode{true}, and
        \item \tcode{is_assignable_v<$\tcode{T}_1$\&, U2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns \tcode{std::forward<U1>(u.first)} to the first
    element of \tcode{*this} and\\ \tcode{std::forward<U2>(u.second)} to the
    second element of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<class U1, class U2> constexpr const tuple& operator=(pair<U1, U2>&& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} is 2,
        \item
        \tcode{is_assignable_v<const $\tcode{T}_0$\&, U1>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<const $\tcode{T}_1$\&, U2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns \tcode{std::forward<U1>(u.first)} to the first element and\\
    \tcode{std::forward<U2>(u.second)} to the second element.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\begin{addedblock}
\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple> 
    constexpr tuple& operator=(const UTuple& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<UTuple>} and
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, const std::element_t<$i$, UTuple>\&>} is \tcode{true} for all $i$.
    \end{itemize}
    
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding element
    of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple> 
    constexpr const tuple& operator=(const UTuple& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<UTuple>} and
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, const std::element_t<$i$, UTuple>\&>} is \tcode{true} for all $i$.
    \end{itemize}
    
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding element of \tcode{*this}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr tuple& operator=(UTuple&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<UTuple>} and
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, std::element_t<$i$, UTuple>>} is \tcode{true} for all $i$..
    \end{itemize}
    
    \pnum
    \effects
    For all $i$, assigns \tcode{std::forward<$\tcode{U}_i$>(get<$i$>(u))} to
    \tcode{get<$i$>(*this)}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr const tuple& operator=(UTuple&& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<UTuple>} and
        \item \tcode{is_assignable_v<const $\tcode{T}_i$\&, std::element_t<$i$, UTuple>\&\&>} is \tcode{true} for all $i$.
    \end{itemize}
    
    \pnum
    \effects
    For all $i$,
    assigns \tcode{std::forward<U$_i$>(get<$i$>(u))} to \tcode{get<$i$>(*this)}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}
\end{addedblock}

\rSec3[tuple.swap]{\tcode{swap}}

\indexlibrarymember{swap}{tuple}%
\begin{itemdecl}
    constexpr void swap(tuple& rhs) noexcept(@\seebelow@);
    constexpr void swap(const tuple& rhs) const noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    \begin{itemize}
        \item
        For the first overload,
        \tcode{(is_swappable_v<Types> \&\& ...)} is \tcode{true}.
        \item
        For the second overload,
        \tcode{(is_swappable_v<const Types> \&\& ...)} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \expects
    Each element in \tcode{*this} is swappable with\iref{swappable.requirements}
    the corresponding element in \tcode{rhs}.
    
    \pnum
    \effects
    Calls \tcode{swap} for each element in \tcode{*this} and its
    corresponding element in \tcode{rhs}.
    
    \pnum
    \throws
    Nothing unless one of the element-wise \tcode{swap} calls throws an exception.
    
    \pnum
    \remarks
    The exception specification is equivalent to
    \begin{itemize}
        \item
        \tcode{(is_nothrow_swappable_v<Types> \&\& ...)} for the first overload and
        \item
        \tcode{(is_nothrow_swappable_v<const Types> \&\& ...)} for the second overload.
    \end{itemize}
\end{itemdescr}

\rSec2[tuple.creation]{Tuple creation functions}

\indexlibraryglobal{make_tuple}%
\indexlibrarymember{tuple}{make_tuple}%
\begin{itemdecl}
    template<class... TTypes>
    constexpr tuple<unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&... t);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \returns
    \tcode{tuple<unwrap_ref_decay_t<TTypes>...>(std::forward<TTypes>(t)...)}.
    
    \pnum
    \begin{example}
        \begin{codeblock}
            int i; float j;
            make_tuple(1, ref(i), cref(j))
        \end{codeblock}
        creates a tuple of type \tcode{tuple<int, int\&, const float\&>}.
    \end{example}
\end{itemdescr}

\indexlibraryglobal{forward_as_tuple}%
\indexlibrarymember{tuple}{forward_as_tuple}%
\begin{itemdecl}
    template<class... TTypes>
    constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&... t) noexcept;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Constructs a tuple of references to the arguments in \tcode{t} suitable
    for forwarding as arguments to a function. Because the result may contain references
    to temporary objects, a program shall ensure that the return value of this
    function does not outlive any of its arguments (e.g., the program should typically
    not store the result in a named variable).
    
    \pnum
    \returns
    \tcode{tuple<TTypes\&\&...>(std::forward<TTypes>(t)...)}.
\end{itemdescr}

\indexlibraryglobal{tie}%
\indexlibraryglobal{ignore}%
\indexlibrarymember{tuple}{tie}%
\begin{itemdecl}
    template<class... TTypes>
    constexpr tuple<TTypes&...> tie(TTypes&... t) noexcept;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \returns
    \tcode{tuple<TTypes\&...>(t...)}.  When an
    argument in \tcode{t} is \tcode{ignore}, assigning
    any value to the corresponding tuple element has no effect.
    
    \pnum
    \begin{example}
        \tcode{tie} functions allow one to create tuples that unpack
        tuples into variables. \tcode{ignore} can be used for elements that
        are not needed:
        \begin{codeblock}
            int i; std::string s;
            tie(i, ignore, s) = make_tuple(42, 3.14, "C++");
            // \tcode{i == 42}, \tcode{s == "C++"}
        \end{codeblock}
    \end{example}
\end{itemdescr}

\indexlibraryglobal{tuple_cat}
\begin{itemdecl}
    template<@\changed{class}{\placeholder{tuple-like}}@... Tuples>
    constexpr tuple<CTypes...> tuple_cat(Tuples&&... tpls);
\end{itemdecl}

\begin{itemdescr}  % NOCHECK: order
    \pnum
    In the following paragraphs, let $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Tuples},
    $\tcode{U}_i$ be \tcode{remove_reference_t<T$_i$>}, and $\tcode{tp}_i$ be the $i^\text{th}$
    parameter in the function parameter pack \tcode{tpls}, where all indexing is
    zero-based.
    
    \pnum
    \expects
    For all $i$, $\tcode{U}_i$ is the type
    $\cv_i$ \tcode{tuple<$\tcode{Args}_i$...>}, where $\cv_i$ is the (possibly empty) $i^\text{th}$
    \grammarterm{cv-qualifier-seq} and $\tcode{Args}_i$ is the template parameter pack representing the element
    types in $\tcode{U}_i$. Let $\tcode{A}_{ik}$ be the ${k}^\text{th}$ type in $\tcode{Args}_i$. For all
    $\tcode{A}_{ik}$ the following requirements are met:
    
    \ednote{Is "the template parameter pack representing the element types in $\tcode{U}_i$" clear enough?}
    
    
    \begin{itemize}
        \item If $\tcode{T}_i$ is deduced as an lvalue reference type, then
        \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&> == true}, otherwise
        \item \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&\&> == true}.
    \end{itemize}
    
    \pnum
    \remarks
    The types in \tcode{CTypes} are equal to the ordered
    sequence of the extended types
    \tcode{$\tcode{Args}_0$..., $\tcode{Args}_1$..., $\dotsc$, $\tcode{Args}_{n-1}$...},
    where $n$ is
    equal to \tcode{sizeof...(Tuples)}. Let \tcode{$\tcode{e}_i$...} be the $i^\text{th}$
    ordered sequence of tuple elements of the resulting \tcode{tuple} object
    corresponding to the type sequence $\tcode{Args}_i$.
    
    \pnum
    \returns
    A \tcode{tuple} object constructed by initializing the ${k_i}^\text{th}$
    type element $\tcode{e}_{ik}$ in \tcode{$\tcode{e}_i$...} with
    \begin{codeblock}
        get<@$k_i$@>(std::forward<@$\tcode{T}_i$@>(@$\tcode{tp}_i$@))
    \end{codeblock}
    for each valid $k_i$ and each group $\tcode{e}_i$ in order.
    
    \begin{removedblock}
    \begin{note}
        An implementation can support additional types in the template parameter
        pack \tcode{Tuples} that support the \tcode{tuple}-like protocol, such as
        \tcode{pair} and \tcode{array}.
    \end{note}        
    
    \end{removedblock}

    
\end{itemdescr}



\rSec2[tuple.apply]{Calling a function with a \tcode{tuple} of arguments}

\indexlibraryglobal{apply}%
\begin{itemdecl}
    template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
    constexpr decltype(auto) apply(F&& f, Tuple&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
namespace std {
    template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple, size_t... I>
    constexpr decltype(auto) @\placeholdernc{apply-impl}@(F&& f, Tuple&& t, index_sequence<I...>) {
        // \expos
        return @\placeholdernc{INVOKE}@(std::forward<F>(f), get<I>(std::forward<Tuple>(t))...);     // see \ref{func.require}
    }
}
\end{codeblock}
Equivalent to:
\begin{codeblock}
    return @\placeholdernc{apply-impl}@(std::forward<F>(f), std::forward<Tuple>(t),
    make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{make_from_tuple}%
\begin{itemdecl}
    template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
    constexpr T make_from_tuple(@\changed{class}{\placeholder{tuple-like}}@&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
namespace std {
    template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple, size_t... I>
    requires is_constructible_v<T, decltype(get<I>(declval<Tuple>()))...>
    constexpr T @\placeholdernc{make-from-tuple-impl}@(Tuple&& t, index_sequence<I...>) {   // \expos
        return T(get<I>(std::forward<Tuple>(t))...);
    }
}
\end{codeblock}
Equivalent to:
\begin{codeblock}
    return @\placeholdernc{make-from-tuple-impl}@<T>(
    std::forward<Tuple>(t),
    make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\begin{note}
    The type of \tcode{T} must be supplied
    as an explicit template parameter,
    as it cannot be deduced from the argument list.
\end{note}
\end{itemdescr}

\rSec2[tuple.rel]{Relational operators}

\indexlibrarymember{operator==}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
constexpr bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr bool operator==(const tuple<TTypes...>& t, const UTuple& u);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
    \pnum
    \mandates
    For all \tcode{i},
    where $0 \leq \tcode{i} < \tcode{sizeof...(TTypes)}$,
    \tcode{get<i>(t) == get<i>(u)} is a valid expression
    returning a type that is convertible to \tcode{bool}.
    \tcode{sizeof...(TTypes)} equals
    \tcode{\changed{sizeof...(UTypes)}{tuple_size_v<std::remove_cvref_t<decltype(u)>>}}.
    
    \pnum
    \returns
    \tcode{true} if \tcode{get<i>(t) == get<i>(u)} for all
    \tcode{i}, otherwise \tcode{false}.
    For any two zero-length tuples \tcode{e} and \tcode{f}, \tcode{e == f} returns \tcode{true}.
    
    \pnum
    \remarks
    The elementary comparisons are performed in order from the
    zeroth index upwards.  No comparisons or element accesses are
    performed after the first equality comparison that evaluates to
    \tcode{false}.
\end{itemdescr}

\indexlibrarymember{operator<=>}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, UTypes>...>
operator<=>(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, UTypes>...>
operator<=>(const tuple<TTypes...>& t, const UTuple& u);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
    \pnum
    \effects
    Performs a lexicographical comparison between \tcode{t} and \tcode{u}.
    For any two zero-length tuples \tcode{t} and \tcode{u},
    \tcode{t <=> u} returns \tcode{strong_ordering::equal}.
    Otherwise, equivalent to:
    \begin{codeblock}
        if (auto c = @\placeholder{synth-three-way}@(get<0>(t), get<0>(u)); c != 0) return c;
        return @$\tcode{t}_\mathrm{tail}$@ <=> @$\tcode{u}_\mathrm{tail}$@;
    \end{codeblock}
    where $\tcode{r}_\mathrm{tail}$ for some tuple \tcode{r}
    is a tuple containing all but the first element of \tcode{r}.
\end{itemdescr}

\pnum
\begin{note}
    The above definition does not require \tcode{t$_{\mathrm{tail}}$}
    (or \tcode{u$_{\mathrm{tail}}$}) to be constructed. It might not
    even be possible, as \tcode{t} and \tcode{u} are not required to be copy
    constructible. Also, all comparison operator functions are short circuited;
    they do not perform element accesses beyond what is required to determine the
    result of the comparison.
\end{note}


\begin{addedblock}
\rSec2[tuple.common_ref]{common_reference specialization}

\begin{addedblock}
    In the description that follow, let $i$ be in the range
    \range{0}{\tcode{tuple\char`_size\char`_v<TTuple>}} in order.
    
    Let $\tcode{T}_i$ be the type denoted by \tcode{tuple\char`_element\char`_t<$i$, TTuple> of a template parameter named \tcode{TTuple} satisfying \placeholder{tuple-like}. \tcode{TTypes} denotes a pack formed by the sequence of $\tcode{T}_i$}.
    
    Let $\tcode{U}_i$ be the type denoted by \tcode{tuple\char`_element\char`_t<$i$, UTuple> of of a template parameter named \tcode{UTuple} satisfying \placeholder{tuple-like}. \tcode{UTypes} denotes a pack formed by the sequence of $\tcode{U}_i$}.
\end{addedblock}

\begin{itemdecl}
    template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
    struct basic_common_reference<TTuple, UTuple, TQual, UQual> {
        using type = @\seebelow@;
    };
\end{itemdecl}

\begin{itemdescr}
    \constraints
    \begin{itemize}
        \item \tcode{TTuple} is a specialization of \tcode{tuple} or \tcode{UTuple} is a specialization of \tcode{tuple},
        \item \tcode{tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>} denotes a type.
    \end{itemize}
    
    \tcode{type} denotes the type \tcode{tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>}.
    
\end{itemdescr}

\begin{itemdecl}
    template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple>
    struct basic_common_type<TTuple, UTuple, TQual, UQual> {
        using type = @\seebelow@;
    };
\end{itemdecl}

\begin{itemdescr}
    \constraints
    \begin{itemize}
        \item \tcode{TTuple} is a specialization of \tcode{tuple} or \tcode{UTuple} is a specialization of \tcode{tuple},
        \item \tcode{tuple<common_type_t<TTypes, UTypes>...>} denotes a type.
    \end{itemize}
    
    \tcode{type} denotes the type \tcode{tuple<common_type_t<TTypes, UTypes>...>}.
    
\end{itemdescr}
\end{addedblock}


\rSec1[pairs]{Pairs}

\rSec2[pairs.general]{In general}

\pnum
The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction and several templates that provide access to \tcode{pair}
objects as if they were \tcode{tuple} objects (see~\ref{tuple.helper}
and~\ref{tuple.elem}).%
\indexlibraryglobal{pair}%
\indextext{\idxcode{pair}!tuple interface to}%
\indextext{\idxcode{tuple}!and pair@and \tcode{pair}}%

\rSec2[pairs.pair]{Class template \tcode{pair}}

\indexlibraryglobal{pair}%
\begin{codeblock}
namespace std {
    template<class T1, class T2>
    struct pair {
        using first_type  = T1;
        using second_type = T2;
        
        T1 first;
        T2 second;
        
        pair(const pair&) = default;
        pair(pair&&) = default;
        constexpr explicit(@\seebelow@) pair();
        constexpr explicit(@\seebelow@) pair(const T1& x, const T2& y);
        template<class U1 = T1, class U2 = T2>
        constexpr explicit(@\seebelow@) pair(U1&& x, U2&& y);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(pair<U1, U2>& p);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(const pair<U1, U2>& p);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(pair<U1, U2>&& p);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(const pair<U1, U2>&& p);\end{codeblock}
        \begin{addedblock}
        \begin{codeblock}
        template<@\placeholder{pair-like}@ P>
        constexpr explicit(@\seebelow@) pair(P& p);
        template<@\placeholder{pair-like}@ P>
        constexpr explicit(@\seebelow@) pair(const P& p);
        template<@\placeholder{pair-like}@ P>
        constexpr explicit(@\seebelow@) pair(P&& p);
        template<@\placeholder{pair-like}@ P>
        constexpr explicit(@\seebelow@) pair(const P&& p);
        \end{codeblock}
        \end{addedblock}
        \begin{codeblock}
        template<class... Args1, class... Args2>
        constexpr pair(piecewise_construct_t,
        tuple<Args1...> first_args, tuple<Args2...> second_args);
        
        constexpr pair& operator=(const pair& p);
        constexpr const pair& operator=(const pair& p) const;
        template<class U1, class U2>
        constexpr pair& operator=(const pair<U1, U2>& p);
        template<class U1, class U2>
        constexpr const pair& operator=(const pair<U1, U2>& p) const;
        constexpr pair& operator=(pair&& p) noexcept(@\seebelow@);
        constexpr const pair& operator=(pair&& p) const;
        template<class U1, class U2>
        constexpr pair& operator=(pair<U1, U2>&& p);
        template<class U1, class U2>
        constexpr const pair& operator=(pair<U1, U2>&& p) const;\end{codeblock}
        \begin{addedblock}
        \begin{codeblock}
        template<@\placeholder{pair-like}@ P>
        constexpr const pair& operator= pair(const P& p) const;
        template<@\placeholder{pair-like}@ P>
        constexpr pair& operator=(const P& p);
        template<@\placeholder{pair-like}@ P>
        constexpr pair& operator=(@\seebelow@) pair(P&& p);
        template<@\placeholder{pair-like}@ P>
        constexpr const pair& operator= pair(P&& p) const;
        \end{codeblock}
        \end{addedblock}
        \begin{codeblock}
        constexpr void swap(pair& p) noexcept(@\seebelow@);
        constexpr void swap(const pair& p) const noexcept(@\seebelow@);
    };
    
    template<class T1, class T2>
    pair(T1, T2) -> pair<T1, T2>;
}
\end{codeblock}

\pnum
Constructors and member functions of \tcode{pair} do not throw exceptions unless one of
the element-wise operations specified to be called for that operation
throws an exception.

\pnum
The defaulted move and copy constructor, respectively, of \tcode{pair}
is a constexpr function if and only if all required element-wise
initializations for move and copy, respectively, would satisfy the
requirements for a constexpr function.

\pnum
If \tcode{(is_trivially_destructible_v<T1> \&\& is_trivially_destructible_v<T2>)}
is \tcode{true}, then the destructor of \tcode{pair} is trivial.

\pnum
\tcode{pair<T, U>} is a structural type\iref{temp.param}
if \tcode{T} and \tcode{U} are both structural types.
Two values \tcode{p1} and \tcode{p2} of type \tcode{pair<T, U>}
are template-argument-equivalent\iref{temp.type} if and only if
\tcode{p1.first} and \tcode{p2.first} are template-argument-equivalent and
\tcode{p1.second} and \tcode{p2.second} are template-argument-equivalent.

\indexlibraryctor{pair}%
\begin{itemdecl}
    constexpr explicit(@\seebelow@) pair();
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_default_constructible_v<T1>} is \tcode{true} and
        \item \tcode{is_default_constructible_v<T2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Value-initializes \tcode{first} and \tcode{second}.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} evaluates to \tcode{true}
    if and only if either \tcode{T1} or
    \tcode{T2} is not implicitly default-constructible.
    \begin{note}
        This behavior can be implemented with a trait that checks
        whether a \tcode{const T1\&} or a \tcode{const T2\&}
        can be initialized with \tcode{\{\}}.
    \end{note}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    constexpr explicit(@\seebelow@) pair(const T1& x, const T2& y);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_copy_constructible_v<T1>} is \tcode{true} and
        \item \tcode{is_copy_constructible_v<T2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Initializes \tcode{first} with \tcode{x} and \tcode{second} with \tcode{y}.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<const T1&, T1> || !is_convertible_v<const T2&, T2>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<class U1 = T1, class U2 = T2> constexpr explicit(@\seebelow@) pair(U1&& x, U2&& y);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_constructible_v<T1, U1>} is \tcode{true} and
        \item \tcode{is_constructible_v<T2, U2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Initializes \tcode{first} with
    \tcode{std::forward<U1>(x)} and \tcode{second}
    with \tcode{std::forward<U2>(y)}.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<U1, T1> || !is_convertible_v<U2, T2>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(pair<U1, U2>& p);
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(const pair<U1, U2>& p);
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(pair<U1, U2>&& p);
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(const pair<U1, U2>&& p);
\end{itemdecl}\begin{addedblock}\begin{itemdecl}
    template<@\placeholder{pair-like}@ P> constexpr explicit(@\seebelow@) pair(P& p);
    template<@\placeholder{pair-like}@ P> constexpr explicit(@\seebelow@) pair(const P& p);
    template<@\placeholder{pair-like}@ P> constexpr explicit(@\seebelow@) pair(P&& p);
    template<@\placeholder{pair-like}@ P> constexpr explicit(@\seebelow@) pair(const P&& p);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
    \pnum
    Let \tcode{\exposid{FWD}(u)} be \tcode{static_cast<decltype(u)>(u)}.
    
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{is_constructible_v<T1, decltype(get<0>(\exposid{FWD}(p)))>}
        is \tcode{true} and
        \item
        \tcode{is_constructible_v<T2, decltype(get<1>(\exposid{FWD}(p)))>}
        is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Initializes \tcode{first} with \tcode{get<0>(\exposid{FWD}(p))} and
    \tcode{second} with \tcode{get<1>(\exposid{FWD}(p))}.
    
    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<decltype(get<0>(@\exposid{FWD}@(p))), T1> ||
        !is_convertible_v<decltype(get<1>(@\exposid{FWD}@(p))), T2>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<class... Args1, class... Args2>
    constexpr pair(piecewise_construct_t,
    tuple<Args1...> first_args, tuple<Args2...> second_args);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    \begin{itemize}
        \item \tcode{is_constructible_v<T1, Args1...>} is \tcode{true} and
        \item \tcode{is_constructible_v<T2, Args2...>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Initializes \tcode{first} with arguments of types
    \tcode{Args1...} obtained by forwarding the elements of \tcode{first_args}
    and initializes \tcode{second} with arguments of types \tcode{Args2...}
    obtained by forwarding the elements of \tcode{second_args}. (Here, forwarding
    an element \tcode{x} of type \tcode{U} within a \tcode{tuple} object means calling
    \tcode{std::forward<U>(x)}.) This form of construction, whereby constructor
    arguments for \tcode{first} and \tcode{second} are each provided in a separate
    \tcode{tuple} object, is called \defn{piecewise construction}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    constexpr pair& operator=(const pair& p);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Assigns \tcode{p.first} to \tcode{first} and \tcode{p.second} to \tcode{second}.
    
    \pnum
    \returns
    \tcode{*this}.
    
    \pnum
    \remarks
    This operator is defined as deleted unless
    \tcode{is_copy_assignable_v<T1>} is \tcode{true} and
    \tcode{is_copy_assignable_v<T2>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    constexpr const pair& operator=(const pair& p) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{is_copy_assignable<const T1>} is \tcode{true} and
        \item
        \tcode{is_copy_assignable<const T2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns \tcode{p.first} to \tcode{first} and \tcode{p.second} to \tcode{second}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
template<class U1, class U2> 
constexpr pair& operator=(const pair<U1, U2>& p);
@\added{template<\placeholder{pair-like} P> constexpr pair\& operator=(const P\& p);}
\end{itemdecl}

\begin{itemdescr}
    \added{Let \tcode{Type} be \tcode{remove\char`_cvref\char`_t<decltype(p)>}.}

    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_assignable_v<T1\&, const \changed{U1}{tuple_element_t<0, Type>}\&>} is \tcode{true} and
        \item \tcode{is_assignable_v<T2\&, const \changed{U2}{tuple_element_t<1, Type>}\&>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns \tcode{\changed{p.first}{std::get<0>(p)}} to \tcode{first} and 
    \tcode{\changed{p.second}{std::get<1>(p)}} to \tcode{second}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
template<class U1, class U2> constexpr const pair& operator=(const pair<U1, U2>& p) const;
@\added{template<\placeholder{pair-like} P> constexpr const pair\& operator=(const P\& p) const;}
\end{itemdecl}

\begin{itemdescr}
    \added{Let \tcode{Type} be \tcode{remove\char`_cvref\char`_t<decltype(p)>}.}
    
    
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{is_assignable_v<const T1\&, const \changed{U1}{tuple_element_t<0, Type>}\&>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<const T2\&, const \changed{U2}{tuple_element_t<1, Type>}\&>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    
    Assigns \tcode{\changed{p.first}{std::get<0>(p)}} to \tcode{first} and
    \tcode{\changed{p.second}{std::get<1>(p)}} to \tcode{second}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    constexpr pair& operator=(pair&& p) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_move_assignable_v<T1>} is \tcode{true} and
        \item \tcode{is_move_assignable_v<T2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns to \tcode{first} with \tcode{std::forward<T1>(p.first)}
    and to \tcode{second} with \tcode{std::forward<T2>(\brk{}p.second)}.
    
    \pnum
    \returns
    \tcode{*this}.
    
    \pnum
    \remarks
    The exception specification is equivalent to:
    \begin{codeblock}
        is_nothrow_move_assignable_v<T1> && is_nothrow_move_assignable_v<T2>
    \end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    constexpr const pair& operator=(pair&& p) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{is_assignable<const T1\&, T1>} is \tcode{true} and
        \item
        \tcode{is_assignable<const T2\&, T2>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
    Assigns \tcode{std::forward<T1>(p.first)} to \tcode{first} and
    \tcode{std::forward<T2>(p.second)} to \tcode{second}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr pair& operator=(pair<U1, U2>&& p);
    @\added{template<\placeholder{pair-like} P> constexpr pair\& operator=(P\&\& p);}
\end{itemdecl}

\begin{itemdescr}
     \added{Let \tcode{Type} be \tcode{remove\char`_cvref\char`_t<decltype(p)>}.}
    
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_assignable_v<T1\&, \changed{U1}{tuple_element_t<0, Type>}>} is \tcode{true} and
        \item \tcode{is_assignable_v<T2\&, \changed{U2}{tuple_element_t<1, Type>}>} is \tcode{true}.
    \end{itemize}
    
    \pnum
    \effects
   Assigns \tcode{\changed{std::forward<U1>(p.first)}{std::get<0>(std::forward<decltype(p)>(p))}} to \tcode{first} and
   \tcode{\changed{std::forward<U2>(p.second)}{std::get<1>(std::forward<decltype(p)>(p))}} to \tcode{second}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr const pair& operator=(pair<U1, U2>&& p) const;
    @\added{template<\placeholder{pair-like} P> constexpr const pair\& operator=(P\&\& p) const;}
\end{itemdecl}

\begin{itemdescr}
     \added{Let \tcode{Type} be \tcode{remove\char`_cvref\char`_t<decltype(p)>}.}
    
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{is_assignable_v<const T1\&, \changed{U1}{tuple_element_t<0, Type>}>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<const T2\&, \changed{U2}{tuple_element_t<1, Type>}>} is \tcode{true}.
    \end{itemize}
    
    \effects
    Assigns \tcode{\changed{std::forward<U1>(p.first)}{std::get<0>(std::forward<decltype(p)>(p))}} to \tcode{first} and
    \tcode{\changed{std::forward<U2>(p.second)}{std::get<1>(std::forward<decltype(p)>(p))}} to \tcode{second}.
    
    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\rSec2[pairs.spec]{Specialized algorithms}

\rSec2[pairs.spec]{Specialized algorithms}

\indexlibrarymember{operator==}{pair}%
\begin{itemdecl}
template<class T1, class T2>
constexpr bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
template<class T1, class T2, @\placeholder{pair-like}@ Pair>
requires same_as<T1, tuple_element_t<0, Pair>> && same_as<T2, tuple_element_t<1, Pair>
constexpr bool operator==(const pair<T1, T2>& x, const Pair& y);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
    \pnum
    \returns
    \tcode{x.first == \changed{y.first}{std::get<0>(y)} \&\& x.second == \changed{y.second}{std::get<1>(y)}}.
\end{itemdescr}

\indexlibrarymember{operator<=>}{pair}%
\begin{itemdecl}
template<class T1, class T2>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<T1>, @\placeholder{synth-three-way-result}@<T2>>
operator<=>(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
template<class T1, class T2, @\placeholder{pair-like}@ Pair>
requires same_as<T1, tuple_element_t<0, Pair>> && same_as<T2, tuple_element_t<1, Pair>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<T1>, @\placeholder{synth-three-way-result}@<T2>>
operator<=>(const pair<T1, T2>& x, const Pair& y);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        if (auto c = @\placeholdernc{synth-three-way}@(x.first, @\changed{y.first}{std::get<0>(y)}@); c != 0) return c;
        return @\placeholdernc{synth-three-way}@(x.second, @\changed{y.second}{std::get<1>(y)}@);
    \end{codeblock}
\end{itemdescr}

\rSec1[range.utility]{Range utilities}
\rSec2[range.subrange]{Sub-ranges}

\pnum
The \tcode{subrange} class template combines together an
iterator and a sentinel into a single object that models the
\libconcept{view} concept. Additionally, it models the
\libconcept{sized_range} concept when the final template parameter is
\tcode{subrange_kind::sized}.

\indexlibraryglobal{subrange}%
\begin{codeblock}
namespace std::ranges {
    template<class From, class To>
    concept @\defexposconcept{convertible-to-non-slicing}@ =                    // \expos
    convertible_to<From, To> &&
    !(is_pointer_v<decay_t<From>> &&
    is_pointer_v<decay_t<To>> &&
    @\exposconcept{not-same-as}@<remove_pointer_t<decay_t<From>>, remove_pointer_t<decay_t<To>>>);

\end{codeblock}
\begin{removedblock}
\begin{codeblock}
    template<class T>
    concept @\defexposconcept{pair-like}@ =                                     // \expos
    !is_reference_v<T> && requires(T t) {
        typename tuple_size<T>::type;                       // ensures \tcode{tuple_size<T>} is complete
        requires @\libconcept{derived_from}@<tuple_size<T>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<T>>;
        typename tuple_element_t<1, remove_const_t<T>>;
        { get<0>(t) } -> @\libconcept{convertible_to}@<const tuple_element_t<0, T>&>;
        { get<1>(t) } -> @\libconcept{convertible_to}@<const tuple_element_t<1, T>&>;
    };
\end{codeblock}
\end{removedblock}
\begin{codeblock}
    template<class T, class U, class V>
    concept @\defexposconcept{pair-like-convertible-from}@ =                    // \expos
    !@\libconcept{range}@<T> && @\exposconcept{pair-like}@<T> &&
    @\libconcept{constructible_from}@<T, U, V> &&
    @\exposconcept{convertible-to-non-slicing}@<U, tuple_element_t<0, T>> &&
    @\libconcept{convertible_to}@<V, tuple_element_t<1, T>>;
\end{codeblock}

\rSec2[range.elements]{Elements view}
\rSec3[range.elements.view]{Class template \tcode{elements_view}}

\indexlibraryglobal{elements_view}%
\indexlibrarymember{base}{elements_view}%
\indexlibrarymember{begin}{elements_view}%
\indexlibrarymember{end}{elements_view}%
\indexlibrarymember{size}{elements_view}%
\begin{codeblock}

namespace std::ranges {
    template<class T, size_t N>
    concept @\defexposconcept{has-tuple-element}@ =                   // \expos
    @\added{\exposconcept{tuple-like}<T> \&\& tuple_size_v<T> < N; }@
    @\removed{requires(T t) \{ }@
    @\removed{    typename tuple_size<T>::type;}@
    @\removed{    requires N < tuple_size_v<T>;}@
    @\removed{     typename tuple_element_t<N, T>;}@
    @\removed{     \{ get<N>(t) \} -> convertible_to<const tuple_element_t<N, T>\&>; }@
@\removed{ \}; }@
\end{codeblock}


\rSec3[range.zip.view]{Class template \tcode{zip_view}}

\ednote{Remove [range.zip.view]p1}

\begin{removedblock}
\pnum
Given some pack of types \tcode{Ts},
the alias template \exposid{tuple-or-pair} is defined as follows:
\begin{itemize}
    \item
    If \tcode{sizeof...(Ts)} is 2,
    \tcode{\exposid{tuple-or-pair}<Ts...>} denotes \tcode{pair<Ts...>}.
    \item
    Otherwise, \tcode{\exposid{tuple-or-pair}<Ts...>} denotes \tcode{tuple<Ts...>}.
\end{itemize}
\end{removedblock}

\ednote{Replace all usages of \exposid{tuple-or-pair} by \tcode{tuple} in the range clause.
This includes [range.zip], [range.adjacent.iterator] as well as [range.cartesian] if P2374 is adopted}


\rSec1[containers]{Containers}

\rSec1[associative]{Associative containers}

\ednote{We probably need to modify the requirements table, which I have found challenging as requirements apply equally to sets and maps.
In particular, we probably want to requiere \tcode{is_constructible<value_type, T>} where T is either the type passed to insert, or the \tcode{InputIterator}'s \tcode{value_type}.
Currently, we only seem to require \tcode{convertible_to}, which may not be sufficient?.
An alternative is to add explicit insert overloads for \tcode{pair-like} objects}.

\rSec2[associative.general]{In general}

\pnum
The header map defines the class templates \tcode{map} and
\tcode{multimap}; the header set defines the class templates
\tcode{set} and \tcode{multiset}.

\pnum
The following exposition-only alias templates may appear in deduction guides for associative containers:
\begin{codeblock}
    template<class InputIterator>
    using @\placeholder{iter-value-type}@ =
    typename iterator_traits<InputIterator>::value_type;                // \expos
    template<class InputIterator>
    using @\placeholder{iter-key-type}@ = remove_const_t<
    @\changed{typename iterator_traits<InputIterator>::value_type::first_type}{\\tuple_element_t<0, iterator_traits<InputIterator>::value_type>}@>;   // \expos
    template<class InputIterator>
    using @\placeholder{iter-mapped-type}@ =
    @\changed{typename iterator_traits<InputIterator>::value_type::second_type}{\\tuple_element_t<1, iterator_traits<InputIterator>::value_type>}@>;   // \expos
    template<class InputIterator>
    using @\placeholder{iter-to-alloc-type}@ = pair<
    add_const_t<@\changed{typename iterator_traits<InputIterator>::value_type::first_type}{\\tuple_element_t<0, iterator_traits<InputIterator>::value_type>}@>,
    @\changed{typename iterator_traits<InputIterator>::value_type::second_type}{\\tuple_element_t<1, iterator_traits<InputIterator>::value_type>}@>;  // \expos
\end{codeblock}

\rSec2[map]{Class template \tcode{map}}

\rSec3[map.overview]{Overview}

\indexlibraryglobal{map}%
\pnum
[...]
\indexlibrarymember{comp}{map::value_compare}%
\indexlibrarymember{operator()}{map::value_compare}%
\begin{codeblock}
namespace std {
    template<class Key, class T, class Compare = less<Key>,
    class Allocator = allocator<pair<const Key, T>>>
    class map {
        public:
        // types
        using key_type               = Key;
        using mapped_type            = T;
        using value_type             = pair<const Key, T>;
        using key_compare            = Compare;
        using allocator_type         = Allocator;
        using pointer                = typename allocator_traits<Allocator>::pointer;
        using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
        using reference              = value_type&;
        using const_reference        = const value_type&;
        using size_type              = @\impdefx{type of \tcode{map::size_type}}@; // see \ref{container.requirements}
        using difference_type        = @\impdefx{type of \tcode{map::difference_type}}@; // see \ref{container.requirements}
        using iterator               = @\impdefx{type of \tcode{map::iterator}}@; // see \ref{container.requirements}
        using const_iterator         = @\impdefx{type of \tcode{map::const_iterator}}@; // see \ref{container.requirements}
        using reverse_iterator       = std::reverse_iterator<iterator>;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using node_type              = @\unspec@;
        using insert_return_type     = @\placeholdernc{insert-return-type}@<iterator, node_type>;

        class value_compare {
            friend class map;
            protected:
            Compare comp;
            value_compare(Compare c) : comp(c) {}
            public:
            bool operator()(const value_type& x, const value_type& y) const {
                return comp(x.first, y.first);
            }
        };

        // \ref{map.cons}, construct/copy/destroy
        map() : map(Compare()) { }
        explicit map(const Compare& comp, const Allocator& = Allocator());
        template<class InputIterator>
        map(InputIterator first, InputIterator last,
        const Compare& comp = Compare(), const Allocator& = Allocator());
        map(const map& x);
        map(map&& x);
        explicit map(const Allocator&);
        map(const map&, const Allocator&);
        map(map&&, const Allocator&);
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        map(initializer_list<@\changed{value_type}{P}@>, const Compare& = Compare(), const Allocator& = Allocator());
        template<class InputIterator>
        map(InputIterator first, InputIterator last, const Allocator& a)
        : map(first, last, Compare(), a) { }
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        map(initializer_list<@\changed{value_type}{P}@> il, const Allocator& a)
        : map(il, Compare(), a) { }
        ~map();
        map& operator=(const map& x);
        map& operator=(map&& x)
        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        is_nothrow_move_assignable_v<Compare>);

        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        map& operator=(initializer_list<@\changed{value_type}{P}@>);
        allocator_type get_allocator() const noexcept;

        // iterators
        iterator               begin() noexcept;
        const_iterator         begin() const noexcept;
        iterator               end() noexcept;
        const_iterator         end() const noexcept;

        reverse_iterator       rbegin() noexcept;
        const_reverse_iterator rbegin() const noexcept;
        reverse_iterator       rend() noexcept;
        const_reverse_iterator rend() const noexcept;

        const_iterator         cbegin() const noexcept;
        const_iterator         cend() const noexcept;
        const_reverse_iterator crbegin() const noexcept;
        const_reverse_iterator crend() const noexcept;

        // capacity
        [[nodiscard]] bool empty() const noexcept;
        size_type size() const noexcept;
        size_type max_size() const noexcept;

        // \ref{map.access}, element access
        mapped_type& operator[](const key_type& x);
        mapped_type& operator[](key_type&& x);
        mapped_type&       at(const key_type& x);
        const mapped_type& at(const key_type& x) const;

        // \ref{map.modifiers}, modifiers
        template<class... Args> pair<iterator, bool> emplace(Args&&... args);
        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
        pair<iterator, bool> insert(const value_type& x);
        pair<iterator, bool> insert(value_type&& x);
        template<class P> pair<iterator, bool> insert(P&& x);
        iterator insert(const_iterator position, const value_type& x);
        iterator insert(const_iterator position, value_type&& x);
        template<class P>
        iterator insert(const_iterator position, P&&);
        template<class InputIterator>
        void insert(InputIterator first, InputIterator last);
        
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        void insert(initializer_list<@\changed{value_type}{P}@>);

        node_type extract(const_iterator position);
        node_type extract(const key_type& x);
        insert_return_type insert(node_type&& nh);
        iterator           insert(const_iterator hint, node_type&& nh);

        template<class... Args>
        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
        template<class... Args>
        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
        template<class... Args>
        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
        template<class... Args>
        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
        template<class M>
        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
        template<class M>
        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
        template<class M>
        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
        template<class M>
        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

        iterator  erase(iterator position);
        iterator  erase(const_iterator position);
        size_type erase(const key_type& x);
        iterator  erase(const_iterator first, const_iterator last);
        void      swap(map&)
        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        is_nothrow_swappable_v<Compare>);
        void      clear() noexcept;

        template<class C2>
        void merge(map<Key, T, C2, Allocator>& source);
        template<class C2>
        void merge(map<Key, T, C2, Allocator>&& source);
        template<class C2>
        void merge(multimap<Key, T, C2, Allocator>& source);
        template<class C2>
        void merge(multimap<Key, T, C2, Allocator>&& source);

        // observers
        key_compare key_comp() const;
        value_compare value_comp() const;

        // map operations
        iterator       find(const key_type& x);
        const_iterator find(const key_type& x) const;
        template<class K> iterator       find(const K& x);
        template<class K> const_iterator find(const K& x) const;

        size_type      count(const key_type& x) const;
        template<class K> size_type count(const K& x) const;

        bool           contains(const key_type& x) const;
        template<class K> bool contains(const K& x) const;

        iterator       lower_bound(const key_type& x);
        const_iterator lower_bound(const key_type& x) const;
        template<class K> iterator       lower_bound(const K& x);
        template<class K> const_iterator lower_bound(const K& x) const;

        iterator       upper_bound(const key_type& x);
        const_iterator upper_bound(const key_type& x) const;
        template<class K> iterator       upper_bound(const K& x);
        template<class K> const_iterator upper_bound(const K& x) const;

        pair<iterator, iterator>               equal_range(const key_type& x);
        pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
        template<class K>
        pair<iterator, iterator>             equal_range(const K& x);
        template<class K>
        pair<const_iterator, const_iterator> equal_range(const K& x) const;
    };

    template<class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>,
    class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
    map(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
    -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare, Allocator>;

    template<@\added{\placeholder{pair-like} T}@ @\removed{class Key, class T}@, class Compare = less<@\changed{Key}{tuple_element_t<0, T>}@>,
    class Allocator = allocator<pair<const @\changed{Key}{tuple_element_t<0, T>}@,  @\changed{T}{tuple_element_t<1, T>}@>>>
    map(initializer_list<@\changed{pair<Key, T>}{T}@>, Compare = Compare(), Allocator = Allocator())
    -> map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Compare, Allocator>;

    template<class InputIterator, class Allocator>
    map(InputIterator, InputIterator, Allocator)
    -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
    less<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
    map(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
    -> map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, less<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
}
\end{codeblock}


\rSec2[multimap]{Class template \tcode{multimap}}

\rSec3[multimap.overview]{Overview}

\pnum
\indexlibraryglobal{multimap}%
A
\tcode{multimap}
is an associative container that supports equivalent keys (possibly containing multiple copies of
the same key value) and provides for fast retrieval of values of another type
\tcode{T}
based on the keys.
The
\tcode{multimap}
class
supports bidirectional iterators.

\pnum
[...] 
\begin{codeblock}
namespace std {
template<class Key, class T, class Compare = less<Key>,
class Allocator = allocator<pair<const Key, T>>>
class multimap {
    public:
    // types
    using key_type               = Key;
    using mapped_type            = T;
    using value_type             = pair<const Key, T>;
    using key_compare            = Compare;
    using allocator_type         = Allocator;
    using pointer                = typename allocator_traits<Allocator>::pointer;
    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
    using reference              = value_type&;
    using const_reference        = const value_type&;
    using size_type              = @\impdefx{type of \tcode{multimap::size_type}}@; // see \ref{container.requirements}
    using difference_type        = @\impdefx{type of \tcode{multimap::difference_type}}@; // see \ref{container.requirements}
    using iterator               = @\impdefx{type of \tcode{multimap::iterator}}@; // see \ref{container.requirements}
    using const_iterator         = @\impdefx{type of \tcode{multimap::const_iterator}}@; // see \ref{container.requirements}
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using node_type              = @\unspec@;
    
    class value_compare {
        friend class multimap;
        protected:
        Compare comp;
        value_compare(Compare c) : comp(c) { }
        public:
        bool operator()(const value_type& x, const value_type& y) const {
            return comp(x.first, y.first);
        }
    };
    
    // \ref{multimap.cons}, construct/copy/destroy
    multimap() : multimap(Compare()) { }
    explicit multimap(const Compare& comp, const Allocator& = Allocator());
    template<class InputIterator>
    multimap(InputIterator first, InputIterator last,
    const Compare& comp = Compare(),
    const Allocator& = Allocator());
    multimap(const multimap& x);
    multimap(multimap&& x);
    explicit multimap(const Allocator&);
    multimap(const multimap&, const type_identity_t<Allocator>&);
    multimap(multimap&&, const type_identity_t<Allocator>&);
    
    @\added{template<\placeholder{pair-like} P = value_type>}@
    @\added{requires convertible_to<P, value_type>}@
    multimap(initializer_list<@\changed{value_type}{P}@>,
        const Compare& = Compare(),
        const Allocator& = Allocator());
    template<class InputIterator>
    multimap(InputIterator first, InputIterator last, const Allocator& a)
    : multimap(first, last, Compare(), a) { }
    @\added{template<\placeholder{pair-like} P = value_type>}@
    @\added{requires convertible_to<P, value_type>}@
    multimap(initializer_list<value_type> il, const Allocator& a)
    : multimap(il, Compare(), a) { }
    ~multimap();
    multimap& operator=(const multimap& x);
    multimap& operator=(multimap&& x)
    noexcept(allocator_traits<Allocator>::is_always_equal::value &&
    is_nothrow_move_assignable_v<Compare>);
    @\added{template<\placeholder{pair-like} P = value_type>}@
    @\added{requires convertible_to<P, value_type>}@
    multimap& operator=(initializer_list<@\changed{value_type}{P}@>);
    allocator_type get_allocator() const noexcept;
    
    // iterators
    iterator               begin() noexcept;
    const_iterator         begin() const noexcept;
    iterator               end() noexcept;
    const_iterator         end() const noexcept;
    
    reverse_iterator       rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    reverse_iterator       rend() noexcept;
    const_reverse_iterator rend() const noexcept;
    
    const_iterator         cbegin() const noexcept;
    const_iterator         cend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;
    
    // capacity
    [[nodiscard]] bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    
    // \ref{multimap.modifiers}, modifiers
    template<class... Args> iterator emplace(Args&&... args);
    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& x);
    iterator insert(value_type&& x);
    template<class P> iterator insert(P&& x);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    template<class P> iterator insert(const_iterator position, P&& x);
    template<class InputIterator>
    void insert(InputIterator first, InputIterator last);
    @\added{template<\placeholder{pair-like} P = value_type>}@
    @\added{requires convertible_to<P, value_type>}@
    void insert(initializer_list<@\changed{value_type}{P}@>);
    
    node_type extract(const_iterator position);
    node_type extract(const key_type& x);
    template<class K> node_type extract(K&& x);
    iterator insert(node_type&& nh);
    iterator insert(const_iterator hint, node_type&& nh);
    
    iterator  erase(iterator position);
    iterator  erase(const_iterator position);
    size_type erase(const key_type& x);
    template<class K> size_type erase(K&& x);
    iterator  erase(const_iterator first, const_iterator last);
    void      swap(multimap&)
    noexcept(allocator_traits<Allocator>::is_always_equal::value &&
    is_nothrow_swappable_v<Compare>);
    void      clear() noexcept;
    
    template<class C2>
    void merge(multimap<Key, T, C2, Allocator>& source);
    template<class C2>
    void merge(multimap<Key, T, C2, Allocator>&& source);
    template<class C2>
    void merge(map<Key, T, C2, Allocator>& source);
    template<class C2>
    void merge(map<Key, T, C2, Allocator>&& source);
    
    // observers
    key_compare key_comp() const;
    value_compare value_comp() const;
    
    // map operations
    iterator       find(const key_type& x);
    const_iterator find(const key_type& x) const;
    template<class K> iterator       find(const K& x);
    template<class K> const_iterator find(const K& x) const;
    
    size_type      count(const key_type& x) const;
    template<class K> size_type count(const K& x) const;
    
    bool           contains(const key_type& x) const;
    template<class K> bool contains(const K& x) const;
    
    iterator       lower_bound(const key_type& x);
    const_iterator lower_bound(const key_type& x) const;
    template<class K> iterator       lower_bound(const K& x);
    template<class K> const_iterator lower_bound(const K& x) const;
    
    iterator       upper_bound(const key_type& x);
    const_iterator upper_bound(const key_type& x) const;
    template<class K> iterator       upper_bound(const K& x);
    template<class K> const_iterator upper_bound(const K& x) const;
    
    pair<iterator, iterator>               equal_range(const key_type& x);
    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
    template<class K>
    pair<iterator, iterator>             equal_range(const K& x);
    template<class K>
    pair<const_iterator, const_iterator> equal_range(const K& x) const;
};

template<class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>,
class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
multimap(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
-> multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
Compare, Allocator>;

template<@\added{\placeholder{pair-like} T}@ @\removed{class Key, class T}@, class Compare = less<@\changed{Key}{tuple_element_t<0, T>}@>,
class Allocator = allocator<pair<const @\changed{Key}{tuple_element_t<0, T>}@,  @\changed{T}{tuple_element_t<1, T>}@>>>
multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, Compare = Compare(), Allocator = Allocator())
-> multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Compare, Allocator>;

template<class InputIterator, class Allocator>
multimap(InputIterator, InputIterator, Allocator)
-> multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
less<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

template<@\added{\placeholder{pair-like} T}@ @\removed{class Key, class T}@, class Allocator>
multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
-> multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, less<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
}
\end{codeblock}%
\indexlibrarymember{multimap}{operator==}%
\indexlibrarymember{multimap}{operator<}


\rSec2[unord.map]{Class template \tcode{unordered_map}}%
\indexlibraryglobal{unordered_map}

[...]
\indexlibraryglobal{unordered_map}%
\begin{codeblock}
namespace std {
    template<class Key,
    class T,
    class Hash = hash<Key>,
    class Pred = equal_to<Key>,
    class Allocator = allocator<pair<const Key, T>>>
    class unordered_map {
        public:
        // types
        using key_type             = Key;
        using mapped_type          = T;
        using value_type           = pair<const Key, T>;
        using hasher               = Hash;
        using key_equal            = Pred;
        using allocator_type       = Allocator;
        using pointer              = typename allocator_traits<Allocator>::pointer;
        using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
        using reference            = value_type&;
        using const_reference      = const value_type&;
        using size_type            = @\impdefx{type of \tcode{unordered_map::size_type}}@; // see \ref{container.requirements}
        using difference_type      = @\impdefx{type of \tcode{unordered_map::difference_type}}@; // see \ref{container.requirements}
        
        using iterator             = @\impdefx{type of \tcode{unordered_map::iterator}}@; // see \ref{container.requirements}
        using const_iterator       = @\impdefx{type of \tcode{unordered_map::const_iterator}}@; // see \ref{container.requirements}
        using local_iterator       = @\impdefx{type of \tcode{unordered_map::local_iterator}}@; // see \ref{container.requirements}
        using const_local_iterator = @\impdefx{type of \tcode{unordered_map::const_local_iterator}}@; // see \ref{container.requirements}
        using node_type            = @\unspec@;
        using insert_return_type   = @\placeholdernc{insert-return-type}@<iterator, node_type>;
        
        // \ref{unord.map.cnstr}, construct/copy/destroy
        unordered_map();
        explicit unordered_map(size_type n,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
        template<class InputIterator>
        unordered_map(InputIterator f, InputIterator l,
        size_type n = @\seebelow@,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
        unordered_map(const unordered_map&);
        unordered_map(unordered_map&&);
        explicit unordered_map(const Allocator&);
        unordered_map(const unordered_map&, const type_identity_t<Allocator>&);
        unordered_map(unordered_map&&, const type_identity_t<Allocator>&);
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_map(initializer_list<@\changed{value_type}{P}@> il,
        size_type n = @\seebelow@,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
        unordered_map(size_type n, const allocator_type& a)
        : unordered_map(n, hasher(), key_equal(), a) { }
        unordered_map(size_type n, const hasher& hf, const allocator_type& a)
        : unordered_map(n, hf, key_equal(), a) { }
        template<class InputIterator>
        unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_map(f, l, n, hasher(), key_equal(), a) { }
        template<class InputIterator>
        unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
        const allocator_type& a)
        : unordered_map(f, l, n, hf, key_equal(), a) { }
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_map(initializer_list<@\changed{value_type}{P}@> il, size_type n, const allocator_type& a)
        : unordered_map(il, n, hasher(), key_equal(), a) { }
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_map(initializer_list<@\changed{value_type}{P}@> il, size_type n, const hasher& hf,
        const allocator_type& a)
        : unordered_map(il, n, hf, key_equal(), a) { }
        ~unordered_map();
        unordered_map& operator=(const unordered_map&);
        unordered_map& operator=(unordered_map&&)
        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        is_nothrow_move_assignable_v<Hash> &&
        is_nothrow_move_assignable_v<Pred>);
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_map& operator=(initializer_list<@\changed{value_type}{P}@>);
        allocator_type get_allocator() const noexcept;
        
        // iterators
        iterator       begin() noexcept;
        const_iterator begin() const noexcept;
        iterator       end() noexcept;
        const_iterator end() const noexcept;
        const_iterator cbegin() const noexcept;
        const_iterator cend() const noexcept;
        
        // capacity
        [[nodiscard]] bool empty() const noexcept;
        size_type size() const noexcept;
        size_type max_size() const noexcept;
        
        // \ref{unord.map.modifiers}, modifiers
        template<class... Args> pair<iterator, bool> emplace(Args&&... args);
        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
        pair<iterator, bool> insert(const value_type& obj);
        pair<iterator, bool> insert(value_type&& obj);
        template<class P> pair<iterator, bool> insert(P&& obj);
        iterator       insert(const_iterator hint, const value_type& obj);
        iterator       insert(const_iterator hint, value_type&& obj);
        template<class P> iterator insert(const_iterator hint, P&& obj);
        template<class InputIterator> void insert(InputIterator first, InputIterator last);
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        void insert(initializer_list<@\changed{value_type}{P}@>);
        
        node_type extract(const_iterator position);
        node_type extract(const key_type& x);
        template<class K> node_type extract(K&& x);
        insert_return_type insert(node_type&& nh);
        iterator           insert(const_iterator hint, node_type&& nh);
        
        //[..]
    };
    
template<class InputIterator,
class Hash = hash<@\placeholder{iter-key-type}@<InputIterator>>,
class Pred = equal_to<@\placeholder{iter-key-type}@<InputIterator>>,
class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type = @\seebelow@,
Hash = Hash(), Pred = Pred(), Allocator = Allocator())
-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash, Pred,
Allocator>;

template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash = hash<Key>,
class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>,
typename @\seebelow@::size_type = @\seebelow@, Hash = Hash(),
Pred = Pred(), Allocator = Allocator())
-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, Pred, Allocator>;

template<class InputIterator, class Allocator>
unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
hash<@\placeholder{iter-key-type}@<InputIterator>>,
equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

template<class InputIterator, class Allocator>
unordered_map(InputIterator, InputIterator, Allocator)
-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
hash<@\placeholder{iter-key-type}@<InputIterator>>,
equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

template<class InputIterator, class Hash, class Allocator>
unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type, Hash, Allocator)
-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash,
equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type,
Allocator)
-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;

template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;

template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash, class Allocator>
unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type, Hash,
Allocator)
-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
}
\end{codeblock}

\rSec2[unord.multimap]{Class template \tcode{unordered_multimap}}%
\indexlibraryglobal{unordered_multimap}

\rSec3[unord.multimap.overview]{Overview}

[...]

\indexlibraryglobal{unordered_multimap}%
\begin{codeblock}
namespace std {
    template<class Key,
    class T,
    class Hash = hash<Key>,
    class Pred = equal_to<Key>,
    class Allocator = allocator<pair<const Key, T>>>
    class unordered_multimap {
        public:
        // types
        using key_type             = Key;
        using mapped_type          = T;
        using value_type           = pair<const Key, T>;
        using hasher               = Hash;
        using key_equal            = Pred;
        using allocator_type       = Allocator;
        using pointer              = typename allocator_traits<Allocator>::pointer;
        using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
        using reference            = value_type&;
        using const_reference      = const value_type&;
        using size_type            = @\impdefx{type of \tcode{unordered_multimap::size_type}}@; // see \ref{container.requirements}
        using difference_type      = @\impdefx{type of \tcode{unordered_multimap::difference_type}}@; // see \ref{container.requirements}
        
        using iterator             = @\impdefx{type of \tcode{unordered_multimap::iterator}}@; // see \ref{container.requirements}
        using const_iterator       = @\impdefx{type of \tcode{unordered_multimap::const_iterator}}@; // see \ref{container.requirements}
        using local_iterator       = @\impdefx{type of \tcode{unordered_multimap::local_iterator}}@; // see \ref{container.requirements}
        using const_local_iterator = @\impdefx{type of \tcode{unordered_multimap::const_local_it\-erator}}@; // see \ref{container.requirements}
        using node_type            = @\unspec@;
        
        // \ref{unord.multimap.cnstr}, construct/copy/destroy
        unordered_multimap();
        explicit unordered_multimap(size_type n,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
        template<class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l,
        size_type n = @\seebelow@,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
        unordered_multimap(const unordered_multimap&);
        unordered_multimap(unordered_multimap&&);
        explicit unordered_multimap(const Allocator&);
        unordered_multimap(const unordered_multimap&, const type_identity_t<Allocator>&);
        unordered_multimap(unordered_multimap&&, const type_identity_t<Allocator>&);
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_multimap(initializer_list<@\changed{value_type}{P}@> il,
        size_type n = @\seebelow@,
        const hasher& hf = hasher(),
        const key_equal& eql = key_equal(),
        const allocator_type& a = allocator_type());
        unordered_multimap(size_type n, const allocator_type& a)
        : unordered_multimap(n, hasher(), key_equal(), a) { }
        unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)
        : unordered_multimap(n, hf, key_equal(), a) { }
        template<class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
        : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
        template<class InputIterator>
        unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf,
        const allocator_type& a)
        : unordered_multimap(f, l, n, hf, key_equal(), a) { }
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_multimap(initializer_list<@\changed{value_type}{P}@> il, size_type n, const allocator_type& a)
        : unordered_multimap(il, n, hasher(), key_equal(), a) { }
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_multimap(initializer_list<@\changed{value_type}{P}@> il, size_type n, const hasher& hf,
        const allocator_type& a)
        : unordered_multimap(il, n, hf, key_equal(), a) { }
        ~unordered_multimap();
        unordered_multimap& operator=(const unordered_multimap&);
        unordered_multimap& operator=(unordered_multimap&&)
        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        is_nothrow_move_assignable_v<Hash> &&
        is_nothrow_move_assignable_v<Pred>);
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        unordered_multimap& operator=(initializer_list<@\changed{value_type}{P}@>);
        allocator_type get_allocator() const noexcept;
        
        // iterators
        iterator       begin() noexcept;
        const_iterator begin() const noexcept;
        iterator       end() noexcept;
        const_iterator end() const noexcept;
        const_iterator cbegin() const noexcept;
        const_iterator cend() const noexcept;
        
        // capacity
        [[nodiscard]] bool empty() const noexcept;
        size_type size() const noexcept;
        size_type max_size() const noexcept;
        
        // \ref{unord.multimap.modifiers}, modifiers
        template<class... Args> iterator emplace(Args&&... args);
        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
        iterator insert(const value_type& obj);
        iterator insert(value_type&& obj);
        template<class P> iterator insert(P&& obj);
        iterator insert(const_iterator hint, const value_type& obj);
        iterator insert(const_iterator hint, value_type&& obj);
        template<class P> iterator insert(const_iterator hint, P&& obj);
        template<class InputIterator> void insert(InputIterator first, InputIterator last);
        @\added{template<\placeholder{pair-like} P = value_type>}@
        @\added{requires convertible_to<P, value_type>}@
        void insert(initializer_list<@\changed{value_type}{P}@>);
        
        // [...]
    };
    
    template<class InputIterator,
    class Hash = hash<@\placeholder{iter-key-type}@<InputIterator>>,
    class Pred = equal_to<@\placeholder{iter-key-type}@<InputIterator>>,
    class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
    unordered_multimap(InputIterator, InputIterator,
    typename @\seebelow@::size_type = @\seebelow@,
    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
    Hash, Pred, Allocator>;
    
    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash = hash<Key>,
    class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>,
    typename @\seebelow@::size_type = @\seebelow@,
    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, Pred, Allocator>;
    
    template<class InputIterator, class Allocator>
    unordered_multimap(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
    hash<@\placeholder{iter-key-type}@<InputIterator>>,
    equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
    
    template<class InputIterator, class Allocator>
    unordered_multimap(InputIterator, InputIterator, Allocator)
    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
    hash<@\placeholder{iter-key-type}@<InputIterator>>,
    equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
    
    template<class InputIterator, class Hash, class Allocator>
    unordered_multimap(InputIterator, InputIterator, typename @\seebelow@::size_type, Hash,
    Allocator)
    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash,
    equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
    
    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type,
    Allocator)
    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
    
    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
    
    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash, class Allocator>
    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type,
    Hash, Allocator)
    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
}
\end{codeblock}

\section{Acknowledgments}

Thanks to Casey Carter, Alisdair Meredith, Christopher Di Bella and Tim Song for their invaluable feedbacks!

\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[N4885]{N4885}
Thomas Kppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}
\end{document}
