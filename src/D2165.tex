% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}

\title{Compatibility between \tcode{tuple}, \tcode{pair} and \placeholder{tuple-like} objects}
\docnumber{P2165R2}
\audience{LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle

\paperquote{A tuple by any other name would unpack just as well - Shakespair}

\section{Abstract}

We propose to make \tcode{pair}, \tcode{tuple}, \tcode{tuple_cat}, and associative containers more compatible with objects satisfying the tuple-protocol.

\section{Revisions}

\subsection{R2}

The scope and design have changed quite a bit since R1. First, R1 failed to account for most tuple-like things like \tcode{array}.
Second, R2 also modifies associative containers to accept tuple-like objects.

\subsection{R1}
\begin{itemize}
    \item The wording in R0 was non-sensical
    \item Add a note on deduction guide
    \item Modify \tcode{tuple_cat} to unconditionally support \tcode{tuple-like} entities
\end{itemize}


\section{Tony tables}
\begin{center}
\begin{tabular}{l|l}
Before & After\\ \hline

\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}

constexpr std::pair  p {1, 3.0};
constexpr std::tuple t {p}; // OK

std::pair<int, double> pp
             (get<0>(t), get<1>(t));
    
static_assert(std::tuple(p) == t);

static_assert(@\textcolor{red}{p == t}@);
static_assert(@\textcolor{red}{p <=> t == 0}@);

@\textcolor{red}{std::tuple<int,int> t = std::array \{1, 2\};}@




std::map m{
    std::pair{get<0>(t), get<1>(t)},
    std::pair{get<0>(u), get<1>(u)}
};


static_assert(same_as<std::tuple<int>,
    range_value_t<decltype(views::zip(v))>>);

static_assert(same_as<std::pair<int,int>,
    range_value_t<decltype(views::zip(v, v))>>);
    

// x is std::tuple<int, int> 
// because tuple is convertible from pair
auto x = true ? tuple{0,0} : pair{0,0}; 


\end{colorblock}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}

constexpr std::pair  p {1, 3.0};
constexpr std::tuple t {p}; // OK

std::pair<int, double> pp{t};


static_assert(std::tuple(p) == t);

static_assert(p == t);
static_assert(p <=> t == 0);

std::tuple<int,int> t = std::array {1, 2};

// not the same size: ill-formed
@\textcolor{red}{std::tuple<int> t = std::array \{1, 2\};}@

std::map m{t, u};



static_assert(<std::tuple<int>,
    range_value_t<decltype(views::zip(v))>>);

static_assert(same_as<std::tuple<int,int>,
    range_value_t<decltype(views::zip(v, v))>>);
    
    
    
    
// Both types are interconvertible,
// The expression is ambiguous an this is ill-formed
@\textcolor{red}{auto x = true ?  tuple\{0,0\} : pair\{0,0\};} 

\end{colorblock}
\end{minipage}
\\\\ \hline

\end{tabular}
\end{center}

\textcolor{red}{Red text is ill-formed}

\section{Motivation}

\tcode{pair}s are platonic tuples of 2 elements. \tcode{pair} and \tcode{tuple} share
most of their interface.

Notably, a tuple can be constructed and assigned from a pair, but the reverse is not true.
Tuple and pairs cannot be compared.

Having both types in the standard library is somewhat redundant - as noted in \paper{N2270} - a problem that \paper{N2533}
tried to address before C++, alas unsuccessfully.

We are not proposing to get rid of \tcode{pair}.
However, we are suggesting that maybe new facilities should use \tcode{tuple}, or when appropriate, a structure with named members.
The authors of \paper{N2270}, circa 2007, observed:

\begin{quoteblock}
There is very little reason, other than history, for the library to contain both \tcode{pair<T, U>} and \tcode{tuple<T, U>}. If we do deprecate pair, then we should change all interfaces in the library that use it, including the associative containers, to use \tcode{tuple} instead. This will be a source-incompatible change, but it need not be ABI-breaking.
\end{quoteblock}

As \tcode{pair} will continue to exist, it should still be possible for users of the standard library to ignore its existence, which can be achieved by making sure pairs are constructible from tuple-like objects, and types that are currently constructible from \tcode{pair} can be constructed from another kind of \tcode{tuple}.

For example, associative containers deal in pairs, and they do not allow construction from sequences of tuples. This has forced ranges (\tcode{zip}: \paper{P2321R1}, \tcode{carthesian_product}: \paper{P2374R0}) to deal in \tcode{pair} when dealing with tuples of 2 elements.

\tcode{view_of_tuples | to<map>} currently doesn't work, and we think it should.

Lastly, while there is support for \tcode{enumerate} to have a reference type with named members, there is also a desire
that \tcode{enumerate(container) | to<map>} should work.
In general, it is ridiculously hard and costly to make simple structs that can be used as reference types of ranges.
With the proposed changes, any named type that implements the tuple protocol shares a common reference with the corresponding tuple if the members themselves have a common reference.

As such, only
\begin{itemize}
\item \tcode{tuple_element}
\item \tcode{tuple_size}
\item \tcode{get}
\end{itemize}

need to be provided for a range's reference's type to be any type, as long as the value type is a tuple.

This paper takes care of providing a \tcode{basic_common_reference} and a \tcode{basic_common_type}
between \tcode{tuple} and tuple-like entities.
\paper{P1858R2} and \paper{P1096R0} explores ways to simplify further the tuple protocol.

Standard types supporting the tuple protocol include

\begin{itemize}
\item \tcode{pair}
\item \tcode{tuple}
\item \tcode{array}
\item \tcode{subrange}
\item the proposed \tcode{enumerate}'s \tcode{reference} type.
\item \tcode{span} of static extent- \textbf{prior to \paper{P2116R0} which removed that support}
\end{itemize}

\subsection{C arrays and aggregate}

C arrays and aggregate are supported by structured bindings, but this mechanism does not use the tuple protocol.
As such, these types will not be convertible to \tcode{tuple} with this paper.


\section{Design}

We introduce an exposition only concept \tcode{tuple-like} which can then be used in the definition of \tcode{tuple} and \tcode{pair} construction,
comparison and assignment operators.
A type satisfies \tcode{\placeholder{tuple-like}} if it implements the tuple protocol (\tcode{std::get, std::tuple_element, std::tuple_size}).

The concept is a generalization of the \placeholder{pair-like} exposition-only concept used by \tcode{subrange} and \tcode{views::values}/\tcode{views::keys}.

With that concept, we

\begin{itemize}
    \item Allow a \tcode{tuple} to be constructed, assigned and compared with any tuple-like object \textbf{of the same size}.
    \item Allow a \tcode{pair} to be constructed, assigned and compared with any tuple-like object of size 2.
    \item With \tcode{pair} constructible from any-tuple-like object, we allow associative containers (like map) construction and insertion from any tuple-like object.
    Note that these containers already support insertion/ emplacement from types that their value types is constructible from, so only construction from \tcode{std::initializer_list},
    deduction guides and maybe iterator constructors need change.
    \item Can use \tcode{tuple} in \tcode{zip} and similar views consistently, in the 2 views case.
    \item Can design \tcode{enumerate} as proposed by \paper{P2164R5}.
\end{itemize}

\textbf{The intent of this paper is not to modify the behavior of tuple's and pair's members. In particular, it does not intend to change the behavior of well-formed existing code in regard
to the constraints, \tcode{noexcept} and \tcode{explicit} specifications placed on existing methods, but only to allow these same methods to work with more types that expose the same semantics as tuple and pair do.}

In comparisons, one of the 2 objects has to be a \tcode{tuple}, or a \tcode{pair}. This is done so that comparison operators can be made hidden friends, in order to avoid enormous overload sets.

We also make \tcode{tuple_cat} support any \tcode{\placeholder{tuple-like}} parameter.
This is conditionally supported by implementations already (but may be restricted to pair and array, we generalize that).

\subsection{Questions For LEWG}

Should \tcode{tuple-like} and \tcode{pair-like} be named concepts (as opposition to exposition only) ?

\subsection{CTAD issues}

A previous version of this paper modified the deduction guides to using the tuple-like constructors for tuple-like objects.

But this would change the meaning of \tcode{tuple \{array<int, 2>\{\}\}}.
The current version does not add or modify deduction guides.
As such, \tcode{tuple \{boost::tuple<int, int>\{\}\}} is deduced as \tcode{std::tuple<boost::tuple<int, int>>}

This is obviously not ideal, but, it is a pre-exising problem in C++20. \tcode{tuple {pair<int, int> {}} } is currently deduced to \tcode{std::tuple<int, int>},
while other tuple-like objects T are deduced as \tcode{std::tuple<T>}, which may be surprising.
This is the same problem that all deduction guides involving wrapper types, and may require a more comprehensive fix, for example:

\begin{colorblock}
tuple {pair, pair } // ok
tuple {pair} // ill-formed / deprecated
tuple {std::of_value, pair }  // tuple<pair<foo, bar>>
tuple {std::of_elems, pair }  // tuple<foo, bar>
\end{colorblock}

While we could add a non-ambiguous guide for pair, we think it's better for \tcode{pair} and \tcode{tuple} to remain consistent.

\textbf{We do not propose modifications to CTAD constructors}


\subsection{\textcolor{Red}{Breaking API changes}}

Before this paper, \tcode{tuple} was constructible from \tcode{pair},
but the opposite was not true.

As such \tcode{expr ? apair : atuple} would resolve unambiguously to a tuple.

Because this changes makes both \tcode{pair} and \tcode{tuple} constructible from each other,
the expression is now ambiguous.

This proposal is therefore a breaking change.
However it is unlikely that this pattern exists in practice.
It can be resolved by casting either expression to the type of the other.

Similar expressions such as \tcode{true ? std::tuple\{0.\} : std::tuple\{0\}} are ill-formed in C++20 because they are ambiguous.

\subsection{ABI}

This paper removes the existing \tcode{pair} overloads in \tcode{tuple}, and modify other overloads.
They can be kept by an implementation for mangling purposes if necessary.

\subsection{Implementation}

This proposal has been implemented in libstdc++ \href{https://github.com/cor3ntin/gcc/tree/tuple_pair2}{[Github]}.

\section{Future work}

Tuple comparison operators are good candidates for hidden friends.

\section{Wording}


\rSec2[tuple.syn]{Header \tcode{<tuple>} synopsis}

\ednote{The wording directly below is relative to P2321R1}

\begin{removedblock}
\begin{codeblock}
template<class... TTypes, class... UTypes, template<class> class TQual, template<class> class UQual>
requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
    using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
};

template<class... TTypes, class... UTypes>
requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
truct common_type<tuple<TTypes...>, tuple<UTypes...>> {
    using type = tuple<common_type_t<TTypes, UTypes>...>;
};
\end{codeblock}
\end{removedblock}

\begin{addedblock}
\begin{codeblock}
template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
struct basic_common_reference<TTuple, UTuple, TQual, UQual>;

template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
struct basic_common_type<TTuple, UTuple, TQual, UQual>;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
[...]


// \ref{tuple.creation}, tuple creation functions
inline constexpr @\unspec@ ignore;

template<class... TTypes>
constexpr tuple<unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&...);

template<class... TTypes>
constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&...) noexcept;

template<class... TTypes>
constexpr tuple<TTypes&...> tie(TTypes&...) noexcept;

template<@\changed{class}{\placeholder{tuple-like}}@... Tuples>
constexpr tuple<CTypes...> tuple_cat(Tuples&&...);

// \ref{tuple.apply}, calling a function with a tuple of arguments
template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t);

template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
constexpr T make_from_tuple(Tuple&& t);

// \ref{tuple.helper}, tuple helper classes
template<class T> struct tuple_size;                  // \notdef
template<class T> struct tuple_size<const T>;

template<class... Types> struct tuple_size<tuple<Types...>>;

[...]

template<class T, class... Types>
constexpr const T& get(const tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr const T&& get(const tuple<Types...>&& t) noexcept;
\end{codeblock}

\begin{addedblock}
\begin{codeblock}

template <typename T, std::size_t N>
concept  @\placeholder{is-tuple-element}@ = requires (T t) {  // \expos
    typename std::tuple_element_t<N, std::remove_const_t<T>>;
    { get<N>(t) } -> std::convertible_to<std::tuple_element_t<N, T>&>;
};


template <typename T>
concept @\placeholder{tuple-like}@ // \expos
    = !is_reference_v<T> && requires  {
    typename tuple_size<T>::type;
    requires same_as<decltype(tuple_size_v<T>), size_t>;
} && []<std::size_t... I>(std::index_sequence<I...>)
    { return (@\placeholder{is-tuple-element}@<T, I> && ..); }(std::make_index_sequence<tuple_size_v<T>>{});

template <typename T>
concept @\placeholder{pair-like}@ // \expos
    = @\placeholder{tuple-like}@<T> && std::tuple_size_v<T> == 2;

\end{codeblock}
\end{addedblock}


\begin{codeblock}
// [tuple.rel], relational operators
template<class... TTypes, @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
constexpr bool operator==(const tuple<TTypes...>&, const @\changed{tuple<UTypes...>}{UTuple}@&);

template<class... TTypes, @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, @\changed{UTypes}{\seebelow>}@...>
operator<=>(const tuple<TTypes...>&, const @\changed{tuple<UTypes...>}{UTuple}@&);

// [tuple.traits], allocator-related traits
template<class... Types, class Alloc>
struct uses_allocator<tuple<Types...>, Alloc>;

}
\end{codeblock}



\begin{codeblock}
namespace std {
template<class... Types>
class tuple {
    public:
    // \ref{tuple.cnstr}, \tcode{tuple} construction
    constexpr explicit(@\seebelow@) tuple();
    constexpr explicit(@\seebelow@) tuple(const Types&...);
     // only if \tcode{sizeof...(Types) >= 1}
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(UTypes&&...);
    // only if \tcode{sizeof...(Types) >= 1}

    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template<@\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr explicit(@\seebelow@) tuple(const @\changed{tuple<UTypes...>}{UTuple}@&);
    template<@\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr explicit(@\seebelow@) tuple(@\changed{tuple<UTypes...>}{UTuple}@&&);
\end{codeblock}


\begin{removedblock}
\begin{codeblock}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(const pair<U1, U2>&);   // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(pair<U1, U2>&&);        // only if \tcode{sizeof...(Types) == 2}
\end{codeblock}
\end{removedblock}
\begin{codeblock}

    // allocator-extended constructors
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a);
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);

    template<class Alloc, @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const @\changed{tuple<UTypes...>}{UTuple}@&);

    template<class Alloc, @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, @\changed{tuple<UTypes...>}{UTuple}@&&);
\end{codeblock}
\begin{removedblock}
\begin{codeblock}
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
\end{codeblock}
\end{removedblock}
\begin{codeblock}
    // \ref{tuple.assign}, \tcode{tuple} assignment
    constexpr tuple& operator=(const tuple&);
    constexpr tuple& operator=(tuple&&) noexcept(@\seebelow@);

    template<@\changed{class... UTypes}{\placeholder{tuple-like} T}@>
    constexpr tuple& operator=(const @\changed{tuple<UTypes...>}{T}@&);
    template<@\changed{class... UTypes}{\placeholder{tuple-like} T}@>
    constexpr tuple& operator=(@\changed{tuple<UTypes...>}{T}@&&);
\end{codeblock}
\begin{removedblock}
\begin{codeblock}
    template<class U1, class U2>
    constexpr tuple& operator=(const pair<U1, U2>&);
     // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr tuple& operator=(pair<U1, U2>&&);
    // only if \tcode{sizeof...(Types) == 2}
\end{codeblock}
\end{removedblock}
\begin{codeblock}

    // \ref{tuple.swap}, \tcode{tuple} swap
    constexpr void swap(tuple&) noexcept(@\seebelow@);
};


\end{codeblock}

%template<class... UTypes>
%tuple(UTypes...) -> tuple<UTypes...>;
%template<@\changed{class T1, class T2}{typename... Utypes, template<typename...> typename T}@>
%@\added{requires \placeholder{tuple-like}<T<UTypes...>>}@
%tuple(@\changed{pair<T1, T2>}{T<UTypes..>}@) -> tuple<@\changed{T1, T2}{UTypes...}@>;
%template<class Alloc, class... UTypes>
%tuple(allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;
%@\removed{template<class Alloc, class T1, class T2>}@
%@\removed{tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;}@
%template<class Alloc, class... UTypes@\added{, template<typename...> typename T}@>
%@\added{requires \placeholder{tuple-like}<T<UTypes...>>}@
%tuple(allocator_arg_t, Alloc, @\changed{tuple}{T}@<UTypes...>) -> tuple<UTypes...>;
%}

\rSec3[tuple.cnstr]{Construction}

\pnum
In the descriptions that follow, let $i$ be in the range
\range{0}{sizeof...(Types)} in order, $\tcode{T}_i$
be the $i^\text{th}$ type in \tcode{Types}, and
$\tcode{U}_i$ be \changed{the $i^\text{th}$ type in a template parameter pack named \tcode{UTypes}, where indexing
is zero-based}{the type denoted by \tcode{tuple\char`_element\char`_t<$i$, UTuple>} of a template parameter named \tcode{UTuple} satisfying \placeholder{tuple-like}. \tcode{UTypes} denotes a pack formed of the sequence of $\tcode{U}_i$}.

\pnum
For each \tcode{tuple} constructor, an exception is thrown only if the construction of
one of the types in \tcode{Types} throws an exception.

[...]


\indexlibraryctor{tuple}%
\begin{itemdecl}
template<@\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
constexpr explicit(@\seebelow@) tuple(const @\changed{tuple<UTypes...>}{UTuple}@& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \changed{\tcode{sizeof...(UTypes)}}{\tcode{tuple\char`_size\char`_v<UTuple>}} and

        \item
        \tcode{is_constructible_v<$\tcode{T}_i$, const $\tcode{U}_i$\&>} is \tcode{true} for all $i$, and

        \item
        either
        \tcode{sizeof...(Types)} is not 1, or
        (when \tcode{Types...} expands to \tcode{T} and \tcode{UTypes...} expands to \tcode{U})
        \tcode{is_convertible_v<const tuple<U>\&, T>}, \tcode{is_constructible_v<T, const tuple<U>\&>}, and \tcode{is_same_v<T, U>} are all \tcode{false}.
    \end{itemize}

    \pnum
    \effects
    Initializes each element of \tcode{*this}
    with the corresponding element of \tcode{u}.

    \pnum
    \remarks
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !conjunction_v<is_convertible<const UTypes&, Types>...>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{tuple}%
\begin{itemdecl}
template<@\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
constexpr explicit(@\seebelow@) tuple(@\changed{tuple<UTypes...>}{UTuple}@&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} equals \changed{\tcode{sizeof...(UTypes)}}{\tcode{tuple\char`_size\char`_v<UTuple>}}, and

        \item
        \tcode{is_constructible_v<$\tcode{T}_i$, $\tcode{U}_i$>} is \tcode{true} for all $i$, and

        \item
        either
        \tcode{sizeof...(Types)} is not 1, or
        (when \tcode{Types...} expands to \tcode{T} and \tcode{UTypes...} expands to \tcode{U})
        \tcode{is_convertible_v<\changed{tuple<U>}{UTuple}, T>}, \tcode{is_constructible_v<T, \changed{tuple<U>}{UTuple}>},
        and \tcode{is_same_v<T, U>} are all \tcode{false}.
    \end{itemize}

    \pnum
    \effects
    For all $i$,
    initializes the $i^\text{th}$ element of \tcode{*this} with
    \tcode{std::forward<$\tcode{U}_i$>(get<$i$>(u))}.

    \pnum
    \remarks
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !conjunction_v<is_convertible<UTypes, Types>...>
    \end{codeblock}
\end{itemdescr}

\begin{removedblock}
\indexlibraryctor{tuple}%
\indexlibraryglobal{pair}%
\begin{itemdecl}
template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} is 2,
        \item \tcode{is_constructible_v<$\tcode{T}_0$, const U1\&>} is \tcode{true}, and
        \item \tcode{is_constructible_v<$\tcode{T}_1$, const U2\&>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes the first element with \tcode{u.first} and the
    second element with \tcode{u.second}.

    \pnum
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<const U1&, @$\tcode{T}_0$@> || !is_convertible_v<const U2&, @$\tcode{T}_1$@>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{tuple}%
\indexlibraryglobal{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} is 2,
        \item \tcode{is_constructible_v<$\tcode{T}_0$, U1>} is \tcode{true}, and
        \item \tcode{is_constructible_v<$\tcode{T}_1$, U2>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes the first element with
    \tcode{std::forward<U1>(u.first)} and the
    second element with \tcode{std::forward<U2>(u.second)}.

    \pnum
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<U1, @$\tcode{T}_0$@> || !is_convertible_v<U2, @$\tcode{T}_1$@>
    \end{codeblock}
\end{itemdescr}

\end{removedblock}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a);
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template<class Alloc, @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const @\changed{tuple<UTypes...>}{UTuple}@&);
    template<class Alloc,  @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a,@\changed{tuple<UTypes...>}{UTuple}@&&);

\end{itemdecl}
\begin{removedblock}
\begin{itemdecl}
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
\end{itemdecl}
\end{removedblock}

\begin{itemdescr}
    \pnum
    \expects
    \tcode{Alloc} meets the
    \oldconcept{Allocator} requirements (\tref{cpp17.allocator}).

    \pnum
    \effects
    Equivalent to the preceding constructors except that each element is constructed with
    uses-allocator construction\iref{allocator.uses.construction}.
\end{itemdescr}

\rSec3[tuple.assign]{Assignment}

\pnum
For each \tcode{tuple} assignment operator, an exception is thrown only if the
assignment of one of the types in \tcode{Types} throws an exception.
In the function descriptions that follow, let $i$ be in the range \range{0}{sizeof...\brk{}(Types)}
in order, $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Types},
and $\tcode{U}_i$ be \changed{the $i^\text{th}$ type in a template parameter pack named \tcode{UTypes}, where indexing
is zero-based}{the type denoted by \tcode{tuple\char`_element\char`_t<$i$, UTuple>} of a template parameter named \tcode{UTuple} satisfying \placeholder{tuple-like}. \tcode{UTypes} denotes a pack formed of the sequence of $\tcode{U}_i$}.

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    constexpr tuple& operator=(const tuple& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding
    element of \tcode{*this}.

    \pnum
    \remarks
    This operator is defined as deleted unless
    \tcode{is_copy_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    constexpr tuple& operator=(tuple&& u) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \tcode{is_move_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.

    \pnum
    \effects
    For all $i$, assigns \tcode{std::forward<$\tcode{T}_i$>(get<$i$>(u))} to
    \tcode{get<$i$>(*this)}.

    \pnum
    \remarks
    The expression inside \tcode{noexcept} is equivalent to the logical \textsc{and} of the
    following expressions:

    \begin{codeblock}
        is_nothrow_move_assignable_v<@$\mathtt{T}_i$@>
    \end{codeblock}
    where $\mathtt{T}_i$ is the $i^\text{th}$ type in \tcode{Types}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr tuple& operator=(const @\changed{tuple<UTypes...>}{UTuple}@& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} equals \changed{\tcode{sizeof...(UTypes)}}{\tcode{tuple\char`_size\char`_v<UTuple>}} and
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, const $\tcode{U}_i$\&>} is \tcode{true} for all $i$.
    \end{itemize}

    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding element
    of \tcode{*this}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
    constexpr tuple& operator=(@\changed{tuple<UTypes...>}{UTuple}@&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} equals \changed{\tcode{sizeof...(UTypes)}}{\tcode{tuple\char`_size\char`_v<UTuple>}} and
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, $\tcode{U}_i$>} is \tcode{true} for all $i$.
    \end{itemize}

    \pnum
    \effects
    For all $i$, assigns \tcode{std::forward<$\tcode{U}_i$>(get<$i$>(u))} to
    \tcode{get<$i$>(*this)}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\begin{removedblock}

\indexlibrarymember{operator=}{tuple}%
\indexlibraryglobal{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr tuple& operator=(const pair<U1, U2>& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} is 2 and
        \item \tcode{is_assignable_v<$\tcode{T}_0$\&, const U1\&>} is \tcode{true}, and
        \item \tcode{is_assignable_v<$\tcode{T}_1$\&, const U2\&>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Assigns \tcode{u.first} to the first element of \tcode{*this}
    and \tcode{u.second} to the second element of \tcode{*this}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\indexlibraryglobal{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr tuple& operator=(pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{sizeof...(Types)} is 2 and
        \item \tcode{is_assignable_v<$\tcode{T}_0$\&, U1>} is \tcode{true}, and
        \item \tcode{is_assignable_v<$\tcode{T}_1$\&, U2>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Assigns \tcode{std::forward<U1>(u.first)} to the first
    element of \tcode{*this} and\\ \tcode{std::forward<U2>(u.second)} to the
    second element of \tcode{*this}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\end{removedblock}

\rSec2[tuple.creation]{Tuple creation functions}


\indexlibraryglobal{tuple_cat}
\begin{itemdecl}
template<@\changed{class}{\placeholder{tuple-like}}@... Tuples>
constexpr tuple<CTypes...> tuple_cat(Tuples&&... tpls);
\end{itemdecl}

\begin{itemdescr}
\pnum
In the following paragraphs, let $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Tuples},
$\tcode{U}_i$ be \tcode{remove_reference_t<T$_i$>}, and $\tcode{tp}_i$ be the $i^\text{th}$
parameter in the function parameter pack \tcode{tpls}, where all indexing is
zero-based.

\pnum
\expects
For all $i$, $\tcode{U}_i$ is the type
$\cv_i$ \tcode{tuple<$\tcode{Args}_i$...>}, where $\cv_i$ is the (possibly empty) $i^\text{th}$
\grammarterm{cv-qualifier-seq} and $\tcode{Args}_i$ is the template parameter pack representing the element
types in $\tcode{U}_i$. Let $\tcode{A}_{ik}$ be the ${k}^\text{th}$ type in $\tcode{Args}_i$. For all
$\tcode{A}_{ik}$ the following requirements are met:

\ednote{Is "the template parameter pack representing the element types in $\tcode{U}_i$" clear enough?}

\begin{itemize}
    \item If $\tcode{T}_i$ is deduced as an lvalue reference type, then
    \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&> == true}, otherwise
    \item \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&\&> == true}.
\end{itemize}

\pnum
\remarks
The types in \tcode{CTypes} are equal to the ordered
sequence of the extended types
\tcode{$\tcode{Args}_0$..., $\tcode{Args}_1$..., $\dotsc$, $\tcode{Args}_{n-1}$...},
where $n$ is
equal to \tcode{sizeof...(Tuples)}. Let \tcode{$\tcode{e}_i$...} be the $i^\text{th}$
ordered sequence of tuple elements of the resulting \tcode{tuple} object
corresponding to the type sequence $\tcode{Args}_i$.

\pnum
\returns
A \tcode{tuple} object constructed by initializing the ${k_i}^\text{th}$
type element $\tcode{e}_{ik}$ in \tcode{$\tcode{e}_i$...} with
\begin{codeblock}
    get<@$k_i$@>(std::forward<@$\tcode{T}_i$@>(@$\tcode{tp}_i$@))
\end{codeblock}
for each valid $k_i$ and each group $\tcode{e}_i$ in order.

\pnum
\begin{removedblock}
\begin{note}
    An implementation may support additional types in the template parameter
    pack \tcode{Tuples} that support the \tcode{tuple}-like protocol, such as
    \tcode{pair} and \tcode{array}.
\end{note}
\end{removedblock}


\rSec2[tuple.apply]{Calling a function with a \tcode{tuple} of arguments}

\indexlibraryglobal{apply}%
\begin{itemdecl}
template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
    template<class F, class Tuple, size_t... I>
    constexpr decltype(auto) @\placeholdernc{apply-impl}@(F&& f, Tuple&& t, index_sequence<I...>) {
        // \expos
        return @\placeholdernc{INVOKE}@(std::forward<F>(f), std::get<I>(std::forward<Tuple>(t))...);  // see \ref{func.require}
    }
\end{codeblock}
Equivalent to:
\begin{codeblock}
    return @\placeholdernc{apply-impl}@(std::forward<F>(f), std::forward<Tuple>(t),
    make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\end{itemdescr}


\indexlibraryglobal{make_from_tuple}%
\begin{itemdecl}
    template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
    constexpr T make_from_tuple(Tuple&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
    template<class T, class Tuple, size_t... I>
    requires is_constructible_v<T, decltype(get<I>(declval<Tuple>()))...>
    constexpr T @\placeholdernc{make-from-tuple-impl}@(Tuple&& t, index_sequence<I...>) {     // \expos
        return T(get<I>(std::forward<Tuple>(t))...);
    }
\end{codeblock}
Equivalent to:
\begin{codeblock}
    return @\placeholdernc{make-from-tuple-impl}@<T>(
    std::forward<Tuple>(t),
    make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\begin{note}
    The type of \tcode{T} must be supplied
    as an explicit template parameter,
    as it cannot be deduced from the argument list.
\end{note}
\end{itemdescr}

\end{itemdescr}
\rSec2[tuple.rel]{Relational operators}

\begin{itemdecl}
template<class... TTypes, @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
constexpr bool operator==(const tuple<TTypes...>& t, @\changed{tuple<UTypes...>}{UTuple}@& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    For all \tcode{i},
    where $0 \leq \tcode{i} < \tcode{sizeof...(TTypes)}$,
    \tcode{get<i>(t) == get<i>(u)} is a valid expression
    returning a type that is convertible to \tcode{bool}.
    \tcode{sizeof...(TTypes)} equals
    \changed{\tcode{sizeof...(UTypes)}}{\tcode{tuple\char`_size\char`_v<UTuple>}}.

    \pnum
    \returns
    \tcode{true} if \tcode{get<i>(t) == get<i>(u)} for all
    \tcode{i}, otherwise \tcode{false}.
    For any two zero-length tuples \tcode{e} and \tcode{f}, \tcode{e == f} returns \tcode{true}.

    \pnum
    \effects
    The elementary comparisons are performed in order from the zeroth index upwards.  No comparisons or element accesses are
    performed after the first equality comparison that evaluates to
    \tcode{false}.
\end{itemdescr}

\begin{addedblock}
In the description that follow, let $i$ be in the range
\range{0}{\tcode{tuple\char`_size\char`_v<UTuple>}} in order, $\tcode{U}_i$ {the type denoted by \tcode{tuple\char`_element\char`_t<$i$, UTuple>} of a template parameter named \tcode{UTuple} satisfying \placeholder{tuple-like}. \tcode{UTypes} denotes a pack formed of the sequence of $\tcode{U}_i$}.
\end{addedblock}


\indexlibrarymember{operator<=>}{tuple}%
\begin{itemdecl}
template<class... TTypes, @\changed{class... UTypes}{\placeholder{tuple-like} UTuple}@>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, UTypes>...>
operator<=>(const tuple<TTypes...>& t, const @\changed{tuple<UTypes...>}{UTuple}@& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Performs a lexicographical comparison between \tcode{t} and \tcode{u}.
    For any two zero-length tuples \tcode{t} and \tcode{u},
    \tcode{t <=> u} returns \tcode{strong_ordering::equal}.
    Otherwise, equivalent to:
    \begin{codeblock}
        if (auto c = @\placeholder{synth-three-way}@(get<0>(t), get<0>(u)); c != 0) return c;
        return @$\tcode{t}_\mathrm{tail}$@ <=> @$\tcode{u}_\mathrm{tail}$@;
    \end{codeblock}
    where $\tcode{r}_\mathrm{tail}$ for some tuple \tcode{r}
    is a tuple containing all but the first element of \tcode{r}.
\end{itemdescr}

\pnum
\begin{note}
    The above definition does not require \tcode{t$_{\mathrm{tail}}$}
    (or \tcode{u$_{\mathrm{tail}}$}) to be constructed. It may not
    even be possible, as \tcode{t} and \tcode{u} are not required to be copy
    constructible. Also, all comparison functions are short circuited;
    they do not perform element accesses beyond what is required to determine the
    result of the comparison.
\end{note}

[...]

\begin{addedblock}
\rSec2[tuple.common_ref]{common_reference specialization}

\begin{addedblock}
In the description that follow, let $i$ be in the range
\range{0}{\tcode{tuple\char`_size\char`_v<TTuple>}} in order.

Let $\tcode{T}_i$ be the type denoted by \tcode{tuple\char`_element\char`_t<$i$, TTuple> of a template parameter named \tcode{TTuple} satisfying \placeholder{tuple-like}. \tcode{TTypes} denotes a pack formed of the sequence of $\tcode{T}_i$}.

Let $\tcode{U}_i$ be the type denoted by \tcode{tuple\char`_element\char`_t<$i$, UTuple> of of a template parameter named \tcode{UTuple} satisfying \placeholder{tuple-like}. \tcode{UTypes} denotes a pack formed of the sequence of $\tcode{U}_i$}.
\end{addedblock}

\begin{itemdecl}
template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
struct basic_common_reference<TTuple, UTuple, TQual, UQual> {
    using type = @\seebelow@;
};
\end{itemdecl}

\begin{itemdescr}
\constraints
\begin{itemize}
\item \tcode{TTuple} is a specialization of \tcode{tuple} or \tcode{UTuple} is a specialization of \tcode{tuple},
\item \tcode{tuple_size_v<TTuple> == tuple_size_v<UTuple>} is \tcode{true} and,
\item \tcode{tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>} denotes a type.
\end{itemize}

\tcode{type} denotes the type \tcode{tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>}.

\end{itemdescr}

\begin{itemdecl}
template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple>
struct basic_common_type<TTuple, UTuple, TQual, UQual> {
    using type = @\seebelow@;
};
\end{itemdecl}

\begin{itemdescr}
\constraints
\begin{itemize}
    \item \tcode{TTuple} is a specialization of \tcode{tuple} or \tcode{UTuple} is a specialization of \tcode{tuple},
    \item \tcode{tuple_size_v<TTuple> == tuple_size_v<UTuple>} is \tcode{true} and,
    \item \tcode{tuple<common_type_t_t<TTypes, UTypes>...>} denotes a type.
\end{itemize}

\tcode{type} denotes the type \tcode{tuple<common_type_t_t<TTypes, UTypes>...>}.

\end{itemdescr}
\end{addedblock}

\rSec1[pairs]{Pairs}

\rSec2[pairs.general]{In general}

\pnum
The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction and several templates that provide access to \tcode{pair}
objects as if they were \tcode{tuple} objects (see~\ref{tuple.helper}
and~\ref{tuple.elem}).%
\indexlibraryglobal{pair}%
\indextext{\idxcode{pair}!tuple interface to}%
\indextext{\idxcode{tuple}!and pair@and \tcode{pair}}%

\rSec2[pairs.pair]{Class template \tcode{pair}}

\indexlibraryglobal{pair}%
\begin{codeblock}
    namespace std {
        template<class T1, class T2>
        struct pair {
            using first_type  = T1;
            using second_type = T2;

            T1 first;
            T2 second;

            pair(const pair&) = default;
            pair(pair&&) = default;
            constexpr explicit(@\seebelow@) pair();
            constexpr explicit(@\seebelow@) pair(const T1& x, const T2& y);
            template<class U1, class U2>
            constexpr explicit(@\seebelow@) pair(U1&& x, U2&& y);
            template<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
            constexpr explicit(@\seebelow@) pair(const @\changed{pair<U1, U2>}{U}@& p);
            template<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
            constexpr explicit(@\seebelow@) pair(@\changed{pair<U1, U2>}{U}@&& p);
            template<class... Args1, class... Args2>
            constexpr pair(piecewise_construct_t,
            tuple<Args1...> first_args, tuple<Args2...> second_args);

            constexpr pair& operator=(const pair& p);
            template<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
            constexpr pair& operator=(const @\changed{pair<U1, U2>}{U}@& p);
            constexpr pair& operator=(pair&& p) noexcept(@\seebelow@);
            template<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
            constexpr pair& operator=(@\changed{pair<U1, U2>}{U}@&& p);

            constexpr void swap(pair& p) noexcept(@\seebelow@);
        };

        template<class T1, class T2>
        pair(T1, T2) -> pair<T1, T2>;
    }
\end{codeblock}

[....]


\indexlibraryctor{pair}%
\begin{itemdecl}
    template<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
    constexpr explicit(@\seebelow@) pair(const @\changed{pair<U1, U2>}{U}@& p);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_constructible_v<first_type, const \changed{U1}{tuple_element_t<0, remove_cvref_t<U>>}\&>} is \tcode{true} and
        \item \tcode{is_constructible_v<second_type, const \changed{U2}{tuple_element_t<1, remove_cvref_t<U>>}\&>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    \removed{Initializes members from the corresponding members of the argument}.

    \begin{addedblock}
        Initializes \tcode{first} with \tcode{get<0>(p)}
        and \tcode{second} with \tcode{\tcode{get<1>(p)}}.
    \end{addedblock}

    \pnum
    \remarks
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<const @\changed{U1}{tuple_element_t<0, remove_cvref_t<U>>}@&, first_type>
        || !is_convertible_v<const @\changed{U2}{tuple_element_t<1, remove_cvref_t<U>>}@&, second_type>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
    constexpr explicit(@\seebelow@) pair( @\changed{pair<U1, U2>}{U}@&& p);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_constructible_v<first_type, \changed{U1}{tuple_element_t<0, remove_cvref_t<U>>}>} is \tcode{true} and
        \item \tcode{is_constructible_v<second_type,\changed{U2}{tuple_element_t<1, remove_cvref_t<U>>}>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    \begin{removedblock}
        Initializes \tcode{first} with
        \tcode{std::forward<U1>(p.first)}\\
        and \tcode{second} with
        \tcode{std::forward<U2>(\brk{}p.second)}.
    \end{removedblock}

    \begin{addedblock}
        Initializes \tcode{first} with \tcode{get<0>(std::forward<U>(p))}\\
        and \tcode{second} with \tcode{\tcode{get<1>(std::forward<U>(p))}}.
    \end{addedblock}

    \pnum
    \remarks
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<@\changed{U1}{tuple_element_t<0, remove_cvref_t<U>>}@, first_type>
        || !is_convertible_v<@\changed{U2}{tuple_element_t<1, remove_cvref_t<U>>}@, second_type>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<class... Args1, class... Args2>
    constexpr pair(piecewise_construct_t,
    tuple<Args1...> first_args, tuple<Args2...> second_args);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    \begin{itemize}
        \item \tcode{is_constructible_v<first_type, Args1...>} is \tcode{true} and
        \item \tcode{is_constructible_v<second_type, Args2...>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes \tcode{first} with arguments of types
    \tcode{Args1...} obtained by forwarding the elements of \tcode{first_args}
    and initializes \tcode{second} with arguments of types \tcode{Args2...}
    obtained by forwarding the elements of \tcode{second_args}. (Here, forwarding
    an element \tcode{x} of type \tcode{U} within a \tcode{tuple} object means calling
    \tcode{std::forward<U>(x)}.) This form of construction, whereby constructor
    arguments for \tcode{first} and \tcode{second} are each provided in a separate
    \tcode{tuple} object, is called \defn{piecewise construction}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    constexpr pair& operator=(const pair& p);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Assigns \tcode{p.first} to \tcode{first} and \tcode{p.second} to \tcode{second}.

    \pnum
    \returns
    \tcode{*this}.

    \pnum
    \remarks
    This operator is defined as deleted unless
    \tcode{is_copy_assignable_v<first_type>} is \tcode{true} and
    \tcode{is_copy_assignable_v<second_type>} is \tcode{true}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    template<<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
    constexpr pair& operator=(const @\changed{pair<U1, U2>}{U}@>& p);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_assignable_v<first_type\&, const \changed{U1}{tuple_element_t<0, remove_cvref_t<U>>}\&>} is \tcode{true} and
        \item \tcode{is_assignable_v<second_type\&, const \changed{U2}{tuple_element_t<1, remove_cvref_t<U>>}\&>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Assigns \changed{\tcode{p.first}}{\tcode{get<0>(p)}} to \tcode{first} \\
    and \changed{\tcode{p.second}}{\tcode{get<1>(p)}} to \tcode{second}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    constexpr pair& operator=(pair&& p) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_move_assignable_v<first_type>} is \tcode{true} and
        \item \tcode{is_move_assignable_v<second_type>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Assigns to \tcode{first} with \tcode{std::forward<first_type>(p.first)}
    and to \tcode{second} with\\ \tcode{std::forward<second_type>(p.second)}.

    \pnum
    \returns
    \tcode{*this}.

    \pnum
    \remarks
    The exception specification is equivalent to:
    \begin{codeblock}
        is_nothrow_move_assignable_v<T1> && is_nothrow_move_assignable_v<T2>
    \end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator=}{pair}%
\begin{itemdecl}
    template<<@\changed{class U1, class U2}{\placeholder{pair-like} U}@>
    constexpr pair& operator=(@\changed{pair<U1, U2>}{U}@&& p);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_assignable_v<first_type\&, \changed{U1}{tuple_element_t<0, remove_cvref_t<U>>}>} is \tcode{true} and
        \item \tcode{is_assignable_v<second_type\&, \changed{U2}{tuple_element_t<1, remove_cvref_t<U>>}>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Assigns to \tcode{first} with \changed{\tcode{std::forward<U1>(p.first)}}{\tcode{get<0>(std::forward<U>(p))}}
    and to \tcode{second} with\\ \changed{\tcode{std::forward<U2>(p.second)}}{\tcode{get<1>(std::forward<U>(p))}}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{swap}{pair}%
\begin{itemdecl}
    constexpr void swap(pair& p) noexcept(@\seebelow@);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \expects
    \tcode{first} is swappable with\iref{swappable.requirements} \tcode{p.first} and
    \tcode{second} is swappable with \tcode{p.second}.

    \pnum
    \effects
    Swaps
    \tcode{first} with \tcode{p.first} and
    \tcode{second} with \tcode{p.second}.

    \pnum
    \remarks
    The exception specification is equivalent to:
    \begin{codeblock}
        is_nothrow_swappable_v<first_type> && is_nothrow_swappable_v<second_type>
    \end{codeblock}
\end{itemdescr}

\rSec2[pairs.spec]{Specialized algorithms}

\indexlibrarymember{operator==}{pair}%
\begin{itemdecl}
    template<class T1, class T2>
    constexpr bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \returns
    \tcode{x.first == y.first \&\& x.second == y.second}.
\end{itemdescr}

\indexlibrarymember{operator<=>}{pair}%
\begin{itemdecl}
    template<class T1, class T2@\added{, \placeholder{pair-like} Pair}@>
    @\added{requires same_as<T1, tuple_element_t<0, Pair>> \&\&  same_as<T2, tuple_element_t<1, Pair>}@
    constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<T1>,
    @\placeholder{synth-three-way-result}@<T2>>
    operator<=>(const pair<T1, T2>& x, const @\changed{pair<T1, T2>}{Pair}@& y);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Equivalent to:
    \begin{codeblock}
        if (auto c = @\placeholdernc{synth-three-way}@(x.first, @\changed{y.first}{get<0>(y)}@); c != 0) return c;
        return @\placeholdernc{synth-three-way}@(x.second, @\changed{y.second}{get<1>(y)}@);
    \end{codeblock}
\end{itemdescr}

\rSec1[range.utility]{Range utilities}
\rSec2[range.subrange]{Sub-ranges}

\pnum
The \tcode{subrange} class template combines together an
iterator and a sentinel into a single object that models the
\libconcept{view} concept. Additionally, it models the
\libconcept{sized_range} concept when the final template parameter is
\tcode{subrange_kind::sized}.

\indexlibraryglobal{subrange}%
\begin{codeblock}
namespace std::ranges {
    template<class From, class To>
    concept @\defexposconcept{convertible-to-non-slicing}@ =                    // \expos
    convertible_to<From, To> &&
    !(is_pointer_v<decay_t<From>> &&
    is_pointer_v<decay_t<To>> &&
    @\exposconcept{not-same-as}@<remove_pointer_t<decay_t<From>>, remove_pointer_t<decay_t<To>>>);

\end{codeblock}
\begin{removedblock}
\begin{codeblock}
    template<class T>
    concept @\defexposconcept{pair-like}@ =                                     // \expos
    !is_reference_v<T> && requires(T t) {
        typename tuple_size<T>::type;                       // ensures \tcode{tuple_size<T>} is complete
        requires @\libconcept{derived_from}@<tuple_size<T>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<T>>;
        typename tuple_element_t<1, remove_const_t<T>>;
        { get<0>(t) } -> @\libconcept{convertible_to}@<const tuple_element_t<0, T>&>;
        { get<1>(t) } -> @\libconcept{convertible_to}@<const tuple_element_t<1, T>&>;
    };
\end{codeblock}
\end{removedblock}
\begin{codeblock}
    template<class T, class U, class V>
    concept @\defexposconcept{pair-like-convertible-from}@ =                    // \expos
    !@\libconcept{range}@<T> && @\exposconcept{pair-like}@<T> &&
    @\libconcept{constructible_from}@<T, U, V> &&
    @\exposconcept{convertible-to-non-slicing}@<U, tuple_element_t<0, T>> &&
    @\libconcept{convertible_to}@<V, tuple_element_t<1, T>>;
\end{codeblock}

\rSec2[range.elements]{Elements view}
\rSec3[range.elements.view]{Class template \tcode{elements_view}}

\indexlibraryglobal{elements_view}%
\indexlibrarymember{base}{elements_view}%
\indexlibrarymember{begin}{elements_view}%
\indexlibrarymember{end}{elements_view}%
\indexlibrarymember{size}{elements_view}%
\begin{codeblock}

namespace std::ranges {
    template<class T, size_t N>
    concept @\defexposconcept{has-tuple-element}@ =                   // \expos
    @\added{\exposconcept{tuple-like}<T> \&\& tuple_size_v<T> < N; }@
    @\removed{requires(T t) \{ }@
    @\removed{    typename tuple_size<T>::type;}@
    @\removed{    requires N < tuple_size_v<T>;}@
    @\removed{     typename tuple_element_t<N, T>;}@
    @\removed{     \{ get<N>(t) \} -> convertible_to<const tuple_element_t<N, T>\&>; }@
@\removed{ \}; }@
\end{codeblock}

\rSec1[containers]{Containers}

\rSec1[associative]{Associative containers}

\ednote{We probably need to modify the requirements table, which I have found challenging as requirements apply equally to sets and maps.
In particular, we probably want to requiere \tcode{is_constructible<value_type, T>} where T is either the type passed to insert, or the \tcode{InputIterator}'s \tcode{value_type}.
Currently, we only seem to require \tcode{convertible_to}, which may not be sufficient?.
An alternative is to add explicit insert overloads for \tcode{pair-like} objects}.

\rSec2[associative.general]{In general}

\pnum
The header map defines the class templates \tcode{map} and
\tcode{multimap}; the header set defines the class templates
\tcode{set} and \tcode{multiset}.

\pnum
The following exposition-only alias templates may appear in deduction guides for associative containers:
\begin{codeblock}
    template<class InputIterator>
    using @\placeholder{iter-value-type}@ =
    typename iterator_traits<InputIterator>::value_type;                // \expos
    template<class InputIterator>
    using @\placeholder{iter-key-type}@ = remove_const_t<
    @\changed{typename iterator_traits<InputIterator>::value_type::first_type}{\\tuple_element_t<0, iterator_traits<InputIterator>::value_type>}@>;   // \expos
    template<class InputIterator>
    using @\placeholder{iter-mapped-type}@ =
    @\changed{typename iterator_traits<InputIterator>::value_type::second_type}{\\tuple_element_t<1, iterator_traits<InputIterator>::value_type>}@>;   // \expos
    template<class InputIterator>
    using @\placeholder{iter-to-alloc-type}@ = pair<
    add_const_t<@\changed{typename iterator_traits<InputIterator>::value_type::first_type}{\\tuple_element_t<0, iterator_traits<InputIterator>::value_type>}@>,
    @\changed{typename iterator_traits<InputIterator>::value_type::second_type}{\\tuple_element_t<1, iterator_traits<InputIterator>::value_type>}@>;  // \expos
\end{codeblock}

\rSec2[map]{Class template \tcode{map}}

\rSec3[map.overview]{Overview}

\indexlibraryglobal{map}%
\pnum
A \tcode{map} is an associative container that
supports unique keys (contains at most one of each key-value) and
provides for fast retrieval of values of another type \tcode{T} based
on the keys. The \tcode{map} class supports bidirectional iterators.

\pnum
A
\tcode{map}
meets all of the requirements of a container, of a reversible container\iref{container.requirements}, of
an associative container\iref{associative.reqmts}, and of an allocator-aware container (\tref{container.alloc.req}).
A
\tcode{map}
also provides most operations described in~\ref{associative.reqmts}
for unique keys.
This means that a
\tcode{map}
supports the
\tcode{a_uniq}
operations in~\ref{associative.reqmts}
but not the
\tcode{a_eq}
operations.
For a
\tcode{map<Key,T>}
the
\tcode{key_type}
is
\tcode{Key}
and the
\tcode{value_type}
is
\tcode{pair<const Key,T>}.
Descriptions are provided here only for operations on
\tcode{map}
that are not described in one of those tables
or for operations where there is additional semantic information.

\indexlibrarymember{comp}{map::value_compare}%
\indexlibrarymember{operator()}{map::value_compare}%
\begin{codeblock}
namespace std {
    template<class Key, class T, class Compare = less<Key>,
    class Allocator = allocator<pair<const Key, T>>>
    class map {
        public:
        // types
        using key_type               = Key;
        using mapped_type            = T;
        using value_type             = pair<const Key, T>;
        using key_compare            = Compare;
        using allocator_type         = Allocator;
        using pointer                = typename allocator_traits<Allocator>::pointer;
        using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
        using reference              = value_type&;
        using const_reference        = const value_type&;
        using size_type              = @\impdefx{type of \tcode{map::size_type}}@; // see \ref{container.requirements}
        using difference_type        = @\impdefx{type of \tcode{map::difference_type}}@; // see \ref{container.requirements}
        using iterator               = @\impdefx{type of \tcode{map::iterator}}@; // see \ref{container.requirements}
        using const_iterator         = @\impdefx{type of \tcode{map::const_iterator}}@; // see \ref{container.requirements}
        using reverse_iterator       = std::reverse_iterator<iterator>;
        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
        using node_type              = @\unspec@;
        using insert_return_type     = @\placeholdernc{insert-return-type}@<iterator, node_type>;

        class value_compare {
            friend class map;
            protected:
            Compare comp;
            value_compare(Compare c) : comp(c) {}
            public:
            bool operator()(const value_type& x, const value_type& y) const {
                return comp(x.first, y.first);
            }
        };

        // \ref{map.cons}, construct/copy/destroy
        map() : map(Compare()) { }
        explicit map(const Compare& comp, const Allocator& = Allocator());
        template<class InputIterator>
        map(InputIterator first, InputIterator last,
        const Compare& comp = Compare(), const Allocator& = Allocator());
        map(const map& x);
        map(map&& x);
        explicit map(const Allocator&);
        map(const map&, const Allocator&);
        map(map&&, const Allocator&);
        @\added{template<\placeholder{pair-like} P>}@
        @\added{requires is_constructible_v<value_type, P>}@
        map(initializer_list<@\changed{value_type}{P}@>, const Compare& = Compare(), const Allocator& = Allocator());
        template<class InputIterator>
        map(InputIterator first, InputIterator last, const Allocator& a)
        : map(first, last, Compare(), a) { }
        @\added{template<\placeholder{pair-like} P>}@
        @\added{requires is_constructible_v<value_type, P>}@
        map(initializer_list<@\changed{value_type}{P}@> il, const Allocator& a)
        : map(il, Compare(), a) { }
        ~map();
        map& operator=(const map& x);
        map& operator=(map&& x)
        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        is_nothrow_move_assignable_v<Compare>);

        @\added{template<\placeholder{pair-like} P>}@
        @\added{requires is_constructible_v<value_type, P>}@
        map& operator=(initializer_list<@\changed{value_type}{P}@>);
        allocator_type get_allocator() const noexcept;

        // iterators
        iterator               begin() noexcept;
        const_iterator         begin() const noexcept;
        iterator               end() noexcept;
        const_iterator         end() const noexcept;

        reverse_iterator       rbegin() noexcept;
        const_reverse_iterator rbegin() const noexcept;
        reverse_iterator       rend() noexcept;
        const_reverse_iterator rend() const noexcept;

        const_iterator         cbegin() const noexcept;
        const_iterator         cend() const noexcept;
        const_reverse_iterator crbegin() const noexcept;
        const_reverse_iterator crend() const noexcept;

        // capacity
        [[nodiscard]] bool empty() const noexcept;
        size_type size() const noexcept;
        size_type max_size() const noexcept;

        // \ref{map.access}, element access
        mapped_type& operator[](const key_type& x);
        mapped_type& operator[](key_type&& x);
        mapped_type&       at(const key_type& x);
        const mapped_type& at(const key_type& x) const;

        // \ref{map.modifiers}, modifiers
        template<class... Args> pair<iterator, bool> emplace(Args&&... args);
        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
        pair<iterator, bool> insert(const value_type& x);
        pair<iterator, bool> insert(value_type&& x);
        template<class P> pair<iterator, bool> insert(P&& x);
        iterator insert(const_iterator position, const value_type& x);
        iterator insert(const_iterator position, value_type&& x);
        template<class P>
        iterator insert(const_iterator position, P&&);
        template<class InputIterator>
        void insert(InputIterator first, InputIterator last);
        void insert(initializer_list<value_type>);

        node_type extract(const_iterator position);
        node_type extract(const key_type& x);
        insert_return_type insert(node_type&& nh);
        iterator           insert(const_iterator hint, node_type&& nh);

        template<class... Args>
        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
        template<class... Args>
        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
        template<class... Args>
        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
        template<class... Args>
        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
        template<class M>
        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
        template<class M>
        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
        template<class M>
        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
        template<class M>
        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);

        iterator  erase(iterator position);
        iterator  erase(const_iterator position);
        size_type erase(const key_type& x);
        iterator  erase(const_iterator first, const_iterator last);
        void      swap(map&)
        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        is_nothrow_swappable_v<Compare>);
        void      clear() noexcept;

        template<class C2>
        void merge(map<Key, T, C2, Allocator>& source);
        template<class C2>
        void merge(map<Key, T, C2, Allocator>&& source);
        template<class C2>
        void merge(multimap<Key, T, C2, Allocator>& source);
        template<class C2>
        void merge(multimap<Key, T, C2, Allocator>&& source);

        // observers
        key_compare key_comp() const;
        value_compare value_comp() const;

        // map operations
        iterator       find(const key_type& x);
        const_iterator find(const key_type& x) const;
        template<class K> iterator       find(const K& x);
        template<class K> const_iterator find(const K& x) const;

        size_type      count(const key_type& x) const;
        template<class K> size_type count(const K& x) const;

        bool           contains(const key_type& x) const;
        template<class K> bool contains(const K& x) const;

        iterator       lower_bound(const key_type& x);
        const_iterator lower_bound(const key_type& x) const;
        template<class K> iterator       lower_bound(const K& x);
        template<class K> const_iterator lower_bound(const K& x) const;

        iterator       upper_bound(const key_type& x);
        const_iterator upper_bound(const key_type& x) const;
        template<class K> iterator       upper_bound(const K& x);
        template<class K> const_iterator upper_bound(const K& x) const;

        pair<iterator, iterator>               equal_range(const key_type& x);
        pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
        template<class K>
        pair<iterator, iterator>             equal_range(const K& x);
        template<class K>
        pair<const_iterator, const_iterator> equal_range(const K& x) const;
    };

    template<class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>,
    class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
    map(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
    -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare, Allocator>;

    template<@\added{\placeholder{pair-like} T}@ @\removed{class Key, class T}@, class Compare = less<@\changed{Key}{tuple_element_t<0, T>}@>,
    class Allocator = allocator<pair<const @\changed{Key}{tuple_element_t<0, T>}@, T>>>
    map(initializer_list<@\changed{pair<Key, T>}{T}@>, Compare = Compare(), Allocator = Allocator())
    -> map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Compare, Allocator>;

    template<class InputIterator, class Allocator>
    map(InputIterator, InputIterator, Allocator)
    -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
    less<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;

    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
    map(initializer_list<<@\changed{pair<Key, T>}{T}@>, Allocator)
    -> map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, less<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
}
\end{codeblock}


\ednote{TODO: \tcode{multimap}, \tcode{unordered_map}, \tcode{unordered_multimap}}


\section{Impact on \tcode{zip} \& \tcode{carthesian_product} wordings}

In \paper{P2374R0} and \paper{P2321R1}

\ednote{TODO: Write actual wording when these papers get merged}

\begin{itemize}
\item Remove the exposition-only \tcode{tuple-or-pair} declaration
\item Replace all use of \tcode{tuple-or-pair} by \tcode{tuple}
\end{itemize}

\section{Acknowledgments}

Thanks to Alisdair Meredith, Christopher Di Bella and Tim Song for their invaluable feedbacks!

\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[N4885]{N4885}
Thomas Kppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}
\end{document}
