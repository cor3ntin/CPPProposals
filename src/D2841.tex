% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{Concept and variable-template template-parameters}
\docnumber{P2841R3}
\audience{EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Gašper Ažman}{gasper.azman@gmail.com}
\usepackage[dvipsnames]{xcolor}


\begin{document}
\maketitle

\section{Abstract}

C++ allows passing templates as template parameters.
However, they are forced to be typenames (either type alias templates or class templates).
Variable templates or concepts are not supported.
This is a hole in the template facilities and is the topic of this paper.

We introduce a way to pass concepts and variable templates as template parameters.

Example:

\begin{colorblock}
template<
   template <typename T> concept C,
   template <typename T> auto C
>
struct S{};

template <typename T>
concept Concept = true;

template <typename T>
constexpr auto Var = 42;

S<Concept, Var> s;
\end{colorblock}

Note: this paper is a subset of the larger \paper{P1985R3} (Universal Template Parameters); the authors felt this topic is subtle enough to warrant its own paper.

\section{Revisions}


\subsection{R3}

\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{R2}

\begin{itemize}
\item Alter the design so that partial ordering remains independent of template arguments, following guidance given in Kona.
\item Add a section on the deduction of template parameters from the arguments of a variable template/concept specialization
\end{itemize}


\subsection{R1}

\begin{itemize}
\item Add examples, motivation
\item Wording improvement
\end{itemize}

\subsection{R0}

\begin{itemize}
    \item{Initial revision}
\end{itemize}



\section{Motivation}

Template template-parameters allow for higher-order templates and greater composability.
They can be used, for example, to parametrize a function that operates on any container of any type or to write CRTP-based interfaces.

C++23 limits template template-parameters to be class templates or alias templates.
A variable template (C++14) or a concept (concepts are themselves templates) cannot be passed as a template argument in C++23.

The motivation for passing a concept as a template argument is very much the same as our reason for supporting class templates as template arguments: to allow higher-level constructs.

While there are workarounds - for example by wrapping a variable in a struct with a \tcode{value} member that can then be passed as a type template template parameter, these workarounds
all suffer the same limitations:

\begin{itemize}
    \item They have terrible ergonomics
    \item They have a noticeable impact on performance - instantiating types is expensive
    \item They do not allow to take advantage of nice concept properties such as terse syntax and subsumption.
\end{itemize}

All of these limitations of available patterns are additional motivations for this proposal.


Being able to define a concept adaptor, for instance, would be very nice:

\begin{colorblock}
template <typename T, template <typename> concept C>
concept decays_to = C<decay_t<T>>;
\end{colorblock}

Being able to use it with any concept constraint would also be helpful:

\begin{colorblock}
template <decays_to<copyable> T>
auto f(T&& x);
\end{colorblock}


Other such constructs might, for example, include the following.
\begin{itemize}
\item \tcode{range_of<Concept>}\\
    Many algorithms can operate on a sequence of integer or string-like types and while it is possible to express
    \tcode{range<T> \&\& SomeConcept<ranges::range_reference_t<R>>}, some codebases do that enough that they might want to have a shorter way to express that idea,
    one that would let them use the abbreviated syntax in more cases.

\item \tcode{tuple_of<Concept>} \\
    This follows the same idea, but expressing this idea in the require clause of each function or class that might need it would be an exercise in frustration and a maintenance nightmare. We explore a \tcode{tuple_of} concept later in this paper.
    Representing vectors as tuples-like things of numbers is common in the scientific community, and these scientific libraries have no ideal way to express these constraints.

\item Avoiding duplication.\\
    In his \href{https://brevzin.github.io/c++/2019/01/09/concept-templates/}{blog post} on this very topic, Barry Revzin observed that \tcode{std::ranges} defines a handful of concepts that are very
    similar to one another except they use different concepts internally. Concept template parameters can reduce a lot of duplication.
    Compare the \href{https://eel.is/c++draft/indirectcallable.indirectinvocable}{definitions in the Standard} and \href{https://godbolt.org/z/ohKsoKh9G}{the implementation with our proposal}.
\end{itemize}

To quote Barry's aforementioned blog post

\begin{quoteblock}
I’d rather write a one-line definition per metaconcept, not a one-line definition per metaconcept instantiation.
\end{quoteblock}

So part of the motivation for concept template-parameters is the same as for having functions, templates, and classes:
We want to be able to reuse code and to make it less repetitive and error-prone.


We also demonstrated how this feature can be leveraged to provide better diagnostics when a concept is not satisfied \href{https://compiler-explorer.com/z/sPz5faEbP}{[Compiler Explorer]}.


There is community interest in these features.
\begin{itemize}
\item \href{https://stackoverflow.com/questions/63098070/is-it-possible-to-pass-a-concept-as-a-template-parameter}{Is it possible to pass a concept as a template parameter?}
\item \href{https://stackoverflow.com/questions/72488554/concept-to-assert-an-argument-is-another-concept-with-whatever-parameters}{Concept to assert an argument is another concept, with whatever parameters}
\item \href{https://stackoverflow.com/questions/58875829/passing-a-concept-to-a-function}{Passing a concept to a function}
\item \href{https://stackoverflow.com/questions/61664468/how-to-pass-a-variable-template-as-template-argument}{How to pass a variable template as template argument}
\item \href{https://stackoverflow.com/questions/58592312/can-a-variable-template-be-passed-as-a-template-template-argument}{Can a variable template be passed as a template template argument?}
\end{itemize}

Unfortunately, this is one of those features that truly shows its power on large examples that don't tend to fit into papers.

\subsection{Variable-template template-parameters}

Variable-template template-parameters (previously proposed in \paper{P2008R0}) are useful by themselves.
They can be emulated with a template class with a static public \tcode{value} data member.
Most standard type traits are defined as a type and have an equivalent \tcode{_v} variable:

\begin{colorblock}
template <typename T, typename U>
constexpr bool is_same_v = is_same<T, U>::value;
\end{colorblock}

But this is not compile-time efficient: a class has to be instantiated in addition to generating the value for the constant, which is strictly more work than just producing the constant.
For a `bool` constant, for instance, the difference is substantial; on Apple clang15, it's about 60\% (so, less than half the time).
The memory footprint is more difficult to gauge, but it seems around a 40\% difference.

This performance issue is also explored in more detail in \paper{P1715R1}.

In other microbenchmarks, Gašper has observed a minimum of 30\% speedup by not instantiating class bodies, and a 50\% memory usage reduction for programs with heavy traits usage, specifically when implementing P2300-like classes.

Also, if one has multiple metaprogramming libraries, relying on idioms like \tcode{::value} is fundamentally less composable than a value just being a value.
Similarly, if you have a concept in your codebase, you shouldn't have to wrap it into a static constexpr \tcode{::value} member of a type to pass it to a metafunction.

Wrapping variables in class templates also adds complexity for users: The main reason we expose both a variable template and a class template for every boolean trait is that the language does not support variable-template template-parameters. (Note that we are aware of some codebases using traits as tags for dispatch but this is far from the common case.)

For instance, counting elements that satisfy a specific predicate could be done as

\begin{colorblock}
template <template <typename> auto p, typename... Ts>
constexpr std::size_t count_if_v = (... + p<Ts>);
\end{colorblock}

We could do the same thing with a type, but it incurs a class template instantiation for each element:

\begin{colorblock}
template <template <typename> typename p, typename... Ts>
constexpr std::size_t count_if_v = (... + p<Ts>::value);
\end{colorblock}

It will always be more work for the compiler to instantiate a whole class together with its body (not just its declaration) to allow access to the inner value member than just instantiating a variable template, no matter how much we try to optimize this pattern. \paper{p1715r1} makes the same case.

\section{Additional examples}

The authors have use cases that don't fit in the paper (typical for the most \emph{interesting} use cases) where type-based vs variable-based metaprogramming means the difference of 300s compile-times per unit vs. more than an hour (currently by textually duplicating definitions that could have been genericized if variable template template-parameters were available).

%\pagebreak
%
%\subsection{Filter meta-function}
%
%
%
%\begin{colorblock}
%constexpr bool _is_set_value(...) { return false; };
%template <typename... Args>
%constexpr bool _is_set_value(set_value_t(*)(Args...)) { return true; };
%
%template <typename sig>
%concept a_set_value = _is_set_value(static_cast<sig>(nullptr));
%
%template <typename CompletionSignatureTypelist>
%using value_channel_notification_type =
%  CompletionSignatureTypelist
%  ::template filter<a_set_value>
%  ::template transform<get_args>
%  ::template transform<std::tuple>>
%  ::template apply<std::variant>;
%
%template <typename Sender>
%struct my_receiver {
%  template <typename... Args>
%  void set_value(Args&&...args) {
%    storage = std::tuple<Args>(FWD(args)...);
%  }
%
%  // pretend senders have ::completion_signatures and that they are a type list with nested metafunctions
%  value_channel_notification_type<Sender::completion_signatures> storage;
%};
%
%\end{colorblock}
%

\pagebreak

\subsection{Terse syntax, overloading, and reusing existing concepts}

The following example, simplified from production code shows multiple interesting properties of concept template parameters.
\tcode{with_values_t} takes a function and a predicate, and calls the function with all the arguments satisfying this predicate.

Here we demonstrate the function with \tcode{either} and \tcode{maybe}, but in reality, this is used with receiver types - which are also monadic.
The call operator applies \tcode{f} to all engaged arguments. But all the arguments must be of the same shape (all optionals, all expected), etc.

To do that, we here use the abbreviated function template syntax with \tcode{type-constraints}, which is only possible with concept template parameters.

\begin{colorblock}
template <typename T>
struct maybe;
template <typename L, typename R>
struct either;

template <typename T>
concept a_maybe = /*...*/;
template <typename T>
concept an_either = /*...*/;

template <template <typename> concept C>
struct _with_values_t {
  static constexpr auto operator()(auto&& f, C auto&& e, C auto&& ... es) -> decltype(auto) {
    if (is_active<C>(e)) {       // does the active type in the variant satisfy C
        return _with_values_t{}(bind_front(f, *v), FWD(vs)...);
    } else {
        return _with_values_t{}(f, FWD(vs)...);
    }
  }
};

// have to enforce it's the same monad or it doesn't make any sense
inline constexpr struct with_values_t : _with_values_t<a_maybe>, _with_values_t<an_either> {
  using _with_values_t<a_maybe>::operator();
  using _with_values_t<an_either>::operator();
} with_values {};
\end{colorblock}


It would be technically possible to use a type instead here

\begin{colorblock}
template <typename T>
struct an_either_t {
    static constexpr bool value = an_either<T>;
};

struct _with_values_t {
    template <typename First, typename... Tail>
    requires (an_either_t<First>::value && (an_either_t<Tail>::value && ...))
    static constexpr auto operator()(auto&& f, C auto&& e, C auto&& ... es) -> decltype(auto);
};
\end{colorblock}

But again:
\begin{itemize}
\item This is much less ergonomic as it forces users to wrap their concepts in types which is not intuitive (ie we have found that difficult to teach).
\item The necessity of introducing new names for the same predicate - just exposed as a type, concept, or variable - adds unnecessary complexity to APIs
\item Composability only works by convention.
\item Creating types has a significant performance impact on compile times
\item Diagnostic messages are slightly worse than they could be because of the added layers of wrapping and because compilers will decompose concepts in diagnostic messages.
\end{itemize}


% when_all_nmap(handle_successes, handle_failures, senders...); // we're *actually* doing this on result<> types, not optionals. result = variant<set_value(...)..., set_error(...)..., set_stopped()>

\subsection{When life gives you Lambdas}

To work around the lack of concept parameters, users have started to use generic lambdas

\begin{colorblock}
template <typename T, auto ConceptWrapperLambda>
concept decays_to = requires {
    ConceptWrapperLambda.template operator()<std::decay_t<T>>();
};
template <class T>
requires decays_to<T, ([]<std::copyable>(){})>
auto f(T&& x) {}
\end{colorblock}

Here the concepts we want to parametrize on are passed as a constrained generic lambda - which we then try to call when checking our higher-level concepts.
This allows not to have to create a new type for each concept, so it might be slightly easier to use, although the reader will agree that it particularly arcane.
In addition to the usability concerns, lambdas are never a solution to compile times performance.

All the existing work arounds suffer similar performance and usability concerns, and of course none support subsumption.
Yet, many such workarounds have been developed and a number of them have been deployed in production.
Daisy Hollman provided an \href{https://p2841.godbolt.org/z/efYK1crb3}{entire collection of such workarounds}.

\pagebreak

\subsection{Mixins}

In this other example adapted from production code, We have a mixin container that has a \tcode{get_mixin<concept>} utility that
returns the reference to the mixed-in type that implements that concept. Currently, we emulate it with the horrible constrained lambda trick.

\begin{colorblock}
template <typename facade>
struct utils {
  auto& self() & { return static_cast<facade&>(*this); }

  template <template <typename> concept C>
  auto _get_mixin() -> auto& {
    return this->facade::template _get_mixin<C>();
  }
};

template <typename... Mixins>
struct facade : Mixins<utils<facade>>... {
  template <template <typename> concept C>
  auto& _get_mixin() {
    using return_t = select_first_t<C, Mixins...>;
    return static_cast<return_t&>(*this);
  }
};

// and you want users to do stuff like
template <typename X>
concept exchange_handler = requires (X x, order o) {
  x.send_order(o);
  { x.decode_order(std::byte const*); } -> an_order;
};
\end{colorblock}

There is no way to turn this concept into a type-trait in this mixin library, and there's no way to teach users to make concepts like \tcode{exchange_handler},
unless we teach them that they have to lift the type themselves, with a different name.

\subsection{Previous work}

Variable-template template-parameters were proposed in \paper{P2008R0} and were part of the original design for variable templates \paper{N3615}.
Concept template-parameters have been described by Barry Revzin (back when Concept names were uppercase) in his blog \href{https://brevzin.github.io/c++/2019/01/09/concept-templates/}{here} and \href{https://brevzin.github.io/c++/2019/03/24/concept-templates-2/}{here}.
We mentioned them in \paper{P2632R0} and \paper{P1985R3}.

\subsection{Universal template-parameters}

The fact that variable-template template-parameters and concept template-parameters appear in the same papers is not accidental.
For a universal template-parameter to be universal, we need to make sure it covers the set of entities we could want to use as template-parameters.
There is, therefore, an important order of operations.
If we were to add universal template-parameters before concept template-parameters and variable-template template-parameters, we would be in a situation where either
\begin{itemize}
\item we can't ever add concept template-parameters and variable-template template-parameters
\item "universal template-parameters would not be truly universal"
\item we would feel forced to come up with some kind of "more universal template-parameter" syntax
\end{itemize}

None of these outcomes seems desirable; therefore, the best course of action is to ensure that we
support as best we can the full set of entities we might ever want to support as template-parameters, before adding support for universal template-parameters.

\section{Design}

\subsection{Syntax}

We propose the following syntax for the declaration of a template head accepting a concept as a parameter:

\begin{colorblock}
template<
    template <@\placeholder{template-parameter-list}@> concept C
>
\end{colorblock}

We propose the following syntax for the declaration of a template head accepting a variable template as parameter:

\begin{colorblock}
template<
    template <@\placeholder{template-parameter-list}@> auto C
>
\end{colorblock}

This forms a natural, somewhat intuitive extension of the existing syntax for template extension:
\begin{colorblock}
template<
    typename T,
    auto V,
    template <@\placeholder{template-parameter-list}@> typename TT,
    template <@\placeholder{template-parameter-list}@> auto VT,
    template <@\placeholder{template-parameter-list}@> concept C,
>
\end{colorblock}

\subsection{Default Arguments}

Like type template template parameters, concepts, and variable template template
parameters can have a default argument that is a concept name or the name of a variable template respectively.
Packs can't be defaulted. (That's a separate paper!)

\subsection{Usage}

Within the definition of a templated entity, a concept template-parameter
can be used anywhere a concept name can be used, including as a type constraint, in the requires clause, and so forth.

For example, the following should be valid:

\begin{colorblock}
template <template <typename T> concept C>
struct S {
    void f(C auto);

};
\end{colorblock}

\subsection{Concept template-parameters and subsumption}

Consider:
\begin{colorblock}
template <typename T>
requires view<T> && input_range<T>
void f(); // #1

template <typename T>
requires view<T> && contiguous_range<T>
void f(); // #2
\end{colorblock}

We expect \#2 to be more specialized than \#1 because \tcode{contiguous_range} subsumes\\
\tcode{input_range}.

Now, consider:

\begin{colorblock}
template <typename T>
requires all_of<T, view, input_range>
void f(); // #1

template <typename T>
requires all_of<T, view, contiguous_range>
void f(); // #2
\end{colorblock}

[\href{https://compiler-explorer.com/z/71qjW1WWP}{Run this example on Compiler Explorer}]

This example ought to be isomorphic to the previous one, and \#2 should still be more specialized than \#1.
To do that, we need to be able to substitute concept template arguments in constraint expressions when normalizing constraints.

When establishing subsumption, we have historically not substituted template arguments, instead establishing a mapping of template parameters to arguments for each
constraint and comparing those mappings.

But to establish subsumption rules for concept template-parameters, we need to depart from that somewhat.

Concepts have the particularity of never being explicitly specialized, deduced, dependent, or even instantiated.
Substituting a concept template argument is only a matter of replacing the corresponding template parameter with the list of constraints of the substituted
concept, recursively.

As such, subsumption for concept template-parameters does not violate the guiding principle of subsumption.

For example, a \tcode{range_of_integrals} defined as follow:

\begin{colorblock}
template<typename T>
concept range_of_integrals = std::ranges::range<T> && @\textbf{std::integral}@<std::remove_cvref_t<std::ranges::range_reference_t<T>>>;
\end{colorblock}

Can be mechanically lifted:

\begin{colorblock}
template<typename T, template <typename...> concept C>
concept range_of = std::ranges::range<T> && @\textbf{C}@<std::remove_cvref_t<std::ranges::range_reference_t<T>>>;
template<typename T>
concept range_of_integrals = range_of<T, @\textbf{std::integral}@>;
\end{colorblock}

Note that this transformation does not change any other behavior of normalization, i.e., concept template-parameters that appear within other atomic constraints
are not substituted, and arguments that are not concept names are not substituted either.

\subsection{Fold expressions involving concept template-parameters}

Our proposed design allow for subsumption in the the presence of fold expressions whose pattern is a concept.
(For the non-concept case, see \paper{P2963R0})


\begin{colorblock}
template <
    typename T,
    template <typename...> concept... C>
concept all_of = (C<T> && ...);
\end{colorblock}

Once substituted, the sequence of binary \tcode{\&\&} or \tcode{||} is normalized,
\tcode{all_of}, \tcode{any_of}, and so on can then be implemented in a way that supports subsumption.

One very important case where this facility is absolutely essential is constraining tuples (and other algebraic data-types) by dimension:

\begin{colorblock}
template <typename X, template <typename> concept... C>
concept product_type_of = (... && C<std::tuple_element_t<C...[?], X>>);
//   index-of-current-element, not proposed, but needed  ~~~~~~~
\end{colorblock}

\paper{P2632R0} discusses alternatives to the awful index-of-current-element syntax above.

\subsection{ADL}

Similar to variables, variable templates and concepts are not associated entities when performing argument-dependent lookup.
This is consistent with previous work (for example \paper{N3595} and \paper{P0934R0}) and the general consensus toward ADL.

\subsection{Deduction of concept and template parameters}

Variable and concept template-parameters should be deducible from a template argument of a class template, used in the argument list of a function.

\begin{colorblock}
template <template <class> auto V, template <class> concept C>
struct A {}; // A takes a variable template template argument

template <template <class T> auto V, template <class> concept C>
void foo(A<V, C>);  // can accept any specialization of A; V and C are deduced

template <class T>
auto Var = 0;

template <class T>
concept Concept = true;

void test() {
    foo(A<Var, Concept>{});
}
\end{colorblock}

[\href{https://compiler-explorer.com/z/66dr6fnKj}{Run this example on Compiler Explorer}]

\section{Partial ordering of function templates involving concept template parameters}

Let us introduce three concepts that refine eachother \tcode{A}, \tcode{B}, and \tcode{C},
as well as a class template \tcode{S} that carries a concept \tcode{X} and a type \tcode{T}.

If we then define an overload set of two functions where one deduces the concept,
we get into an interesting situation where if concept parameters are allowed participate in partial ordering, the choice of template arguments of \tcode{S} can change the subsumption order.

\begin{colorblock}
template <template <typename T> concept X, typename T>
struct S {};
template <typename T>
concept A = true;
template <typename T>
concept B = true && A<T>;
template <typename T>
concept C = true && B<T>;

template <template <typename T>  concept X, typename T>
int answer(S<X, T>) requires B<T> { return 42; }
template <template <typename T> concept X, typename T>
int answer(S<X, T>) requires X<T> { return 43; }

answer(S<A, int>{});
answer(S<C, int>{});
answer(S<B, int>{});

\end{colorblock}


In a previous version of this proposal, we proposed that the concept template argument (\tcode{A}, \tcode{B}, \tcode{C} respectively)
would be substituted in each viable \tcode{answer overload} before determining partial ordering.

However, historically, it was always possible to determine the partial ordering of two function templates before substitution, and independently
of any template argument. This has notably allowed compilers to cache partial orderings of function templates, and even though the compiler isn't confused, one might legitimately be concerned that the users might be.
On the face of it, it seems valuable for a C++ programmer to be able to partially order function templates in their head,
and this feature seems to allow a corner-case where that is impossible before substitution.

It was always the position of the authors that use cases where concepts are deduced from functions arguments were contrived but
we did not want to outright limit the set of places were a concept template parameter could be used,
and it took us a while to find a reasonable way to resolve these opposite design goals.

Ultimately we found a solution that preserves all the uses cases this feature was designed for,
while not making partial ordering dependent on arguments.

The rule we are proposing is:

\textbf{Given a template declaration \tcode{D} with a concept parameter \tcode{C}, if \tcode{C} appears in the associated constraints of \tcode{D}, then \tcode{D} is never at least as constrained as another constrained declaration.}
In the example above, the 3 calls to \tcode{answer} are, with is rule, ambiguous.

This rule makes any overload that references a concept template parameter in its requires clause unorderable solely based on subsumption.


We think this has nice properties:
\begin{itemize}
    \item It's fairly straightforward to teach
    \item It's easy to produce a good diagnosis for.
    \item It leaves the design space open.
\end{itemize}

Consider this slightly different example:

\begin{colorblock}
template <template <typename> concept C>
concept A = C<int>;
template <template <typename> concept C>
concept B = true && A<C>;

template <template <typename T> concept X>
void f() {}; // #1
template <template <typename T> concept X>
void f() requires A<X> {} // #2
template <template <typename T> concept X>
void f() requires B<X> {} // #3

template <typename T>
concept Foo = true;

f<Foo>(); // #4 (ambiguous between 2 and 3)
\end{colorblock}

Here, \#2 and \#3 are more specialized than \#1 (because they are constrained and \#1 is not).

With the rule proposed above, neither \#2 or \#3 are as least as constrained as each other (as they refer to a concept templaste parameter \tcode{X}).
As such \#2 is not more specialized than \#3 and \#3 is not more specialized than \#2, and the call \#4 is ambiguous.

We could conceive an alternative design instead, such that we would \textbf{consider dependent \tcode{concept-id} (ie dependent on a concept template parameter of the function template) to be atomic constraints} (option 2).

With that alternative design, for the example above the associated constraints of \#2 would be, after normalization \tcode{C<int>} (where \tcode{C<int>} is an atomic constraint and \tcode{C} refers to some invented template argument), and the associated constraints of \#3 would be, after normalization \tcode{true \&\& C<int>} (where \tcode{C<int>} is the same expression as \#2's).

In that model, \#3 subsumes \#2 and the call is not ambiguous.
The key observation is that, the nature of \tcode{C} does not affect subsumption whether it would be substituted or not.

Not looking at template arguments (and considering dependent \tcode{concept-id}) can lead to situations where
overloads are ambiguous, when they would not be if the concept argument was written verbatim and not passed via a parameter.

\begin{colorblock}
template <typename T>
concept Foo = true;

template <template <typename> concept C>
concept B = true && C<int>;

template <template <typename T> concept X>
void f() requires Foo<int>{}; // #1

template <template <typename T> concept X>
void f() requires B<X> {} // #2

f<Foo>(); // ambiguous between #1 and #2
\end{colorblock}

The opposite is not possible.

There is a compromise between these two options. We could consider
that a concept that appears (either as concept-id, or as concept template argument of another concept-id) in a subexpression of \tcode{\&\&} or \tcode{||}
makes that subexpression atomic (and that subexpression only).

\begin{colorblock}
template <template <typename> concept X>
concept AlwaysTrue = true; // X is not used
template <typename T>
concept A = true;
template <typename T, template <typename> concept C>
void f(T) requires
A<T>
|| C<int>  // atomic (depends on C)
|| AlwaysTrue<T, C> {}  // atomic (depends on C, even if C is never used by AlwaysTrue)
\end{colorblock}

This would be less restrictive than Option 1, and less precise than Option 2, but easier to implement.
Lets refer to this option as 1B.

In no case do we expand concept template arguments when considering subsumption; the question is merely about how much subsumption depth we want to preserve, that is, how much rope for resolving ambiguity do we want to give users.

Ultimately, while whe have a slight preference for option 1.

In the previous revision of this paper, EWG was asked to choose between these options:

\begin{itemize}
\item Option  1: Don't try to determine a more constrained overload at all in the presence of a referenced concept template parameter.
\item Option 1B: Before normalization (ie at the top level), if a concept template parameter is referenced in the subexpression of of a logical \&\& or ||, consider that subexpression atomic
\item Option 2:  After normalization of non-dependent concept-id, consider concept-id refering to a concept template parameter to be atomic constraints.
(Option 1 and 1B can be evolved into option 2 later, the opposite would be a breaking change.)
\end{itemize}

\textbf{EWG choose the first option.}


\subsection{Deduction of template parameters from the argument list of a variable template argument}

This is not proposed.

Consider:

\begin{colorblock}
    template<template <typename...> auto, auto>
    inline constexpr bool is_specialization_of_v = false;

    template<
    template <typename...> auto v,
    typename... Args
    >
    inline constexpr bool is_specialization_of_v<v, v<Args...>> = true; // #2

    template <typename T>
    constexpr int i = 42;

    static_assert(is_specialization_of_v<i, i<int>>); // #3
\end{colorblock}

\href{https://godbolt.org/z/sqTfEojh4}{[Compiler Explorer]}


Should we be able to deduce \tcode{Args} from \tcode{int}?
Some existing implementations will eagerly substitute \tcode{i<int>} by its value (here, \tcode{42}),
such that there is subsequently nothing left to deduce \tcode{Args} against.

While it would be possible to make that work, the implementation effort is non-negligible and the benefits limited,
as we could only deduce the arguments of entities that are valid template arguments - which sounds obvious but that means that the
above example can only work on a subset of variables (constexpr variables template specialization of structural types).

We would also need to decide whether \tcode{is_specialization_of_v<i, i<int>>} behaves differently from \tcode{is_specialization_of_v<i, (i<int>)>}
and how that generalizes to arbitrary subexpressions involving variable template specializations.

So, for now, arguments of variable template template parameters are not deduced.
instead, we should make \#2 ill-formed, so that we have the opportunity to extend that at a later time if we find sufficient motivation for it.

There are existing cases where we make non-deductible partial specializations ill-formed (see \href{https://eel.is/c++draft/temp.spec.partial#match-3}{[temp.spec.partial.match])},
however in the general case we don't seem to (\href{https://gcc.godbolt.org/z/fv1e8nnsf}{for example here is an example with a non-deducible pack})


\subsection{Equivalence of atomic constraints}

One interesting concept to consider is \tcode{tuple_of}, which would e.g., allow constraining a function on a \placeholder{tuple-like}
of integrals, a frequent use case in scientific computation.

In the absence of member and alias packs, a \tcode{tuple_like} concept could look like

\begin{colorblock}
template <typename T, int N>
constexpr bool __tuple_check_elements = [] {
    if constexpr (N == 0)
      return true;
    else if constexpr(requires (T t) {
        typename std::tuple_element_t<N-1, T>;
        { std::get<N-1>(t) };
    })
      return  __tuple_check_elements<T, N-1>;
    return false;
}();

template <typename T>
concept tuple_like = requires {
    typename std::tuple_size<T>::type;
} &&  __tuple_check_elements<T, std::tuple_size_v<T>>;
\end{colorblock}

Here, we use a constexpr variable template to check the constraint on individual elements.
We can trivially adapt this code to take a concept argument:

\begin{colorblock}
template <typename T, template <typename> concept C>
concept decays_to = C<std::decay_t<T>>;

template <typename T, int N, template <typename> concept C>
constexpr bool __tuple_check_elements = [] {
    if constexpr (N == 0)
      return true;
    else if constexpr(requires (T t) {
        typename std::tuple_element_t<N-1, T>;
        { std::get<N-1>(t) } -> decays_to<C>;
    })
      return  __tuple_check_elements<T, N-1, C>;
    return false;
}();

template <typename T, template <typename> concept C>
concept tuple_of = requires {
    typename std::tuple_size<T>::type;
} &&  __tuple_check_elements<T, std::tuple_size_v<T>, C>;
\end{colorblock}

And this works fine, but \tcode{__tuple_check_elements} is an atomic constraint, so we cannot
establish a subsumption relationship for this concept.

With a sufficient number of pack features, we could probably write a concept that checks all elements with a single constraint,
i.e.,

\begin{colorblock}
template <typename T, typename E, int N, template <typename> concept C>
concept __tuple_of_element = requires (T t) {
    typename std::tuple_element_t<N, T>;
    { std::get<N>(t) } -> decays_to<C>;
} &&  C<std::tuple_element_t<0, T>>;

template <typename T, template <typename> concept C>
concept tuple_of = requires {
    typename std::tuple_size<T>::type;
} &&  (__tuple_of_element<T, T::[:], current_expansion_index_magic(), C> && ...);
\end{colorblock}

But in addition to relying on imaginary features, this is pretty inefficient since ordering complexity would be proportional to the square of the number of tuple elements.

Fortunately, while checking satisfaction does require looking at every element, we can look at just one element to establish subsumption in this particular case.

We can rewrite our concept as

\begin{colorblock}
template <typename T, int N, template <typename> concept C>
concept __tuple_of_element = requires (T t) {
    typename std::tuple_element_t<N, T>;
    { std::get<N>(t) } -> decays_to<C>;
} &&  C<std::tuple_element_t<0, T>>;

template <typename T, int N, template <typename> concept C>
constexpr bool __check_tuple_elements = [] {
    if constexpr (N == 1)
        return true;
    else if constexpr(__tuple_of_element<T, N-1, C>)
        return  __check_tuple_elements<T, N-1, C>;
    return false;
}();

template <typename T, template <typename> concept C>
concept tuple_of = requires {
    typename std::tuple_size<T>::type;
} &&  (std::tuple_size_v<T>  == 0 || (
         // Check the first element with a concept to establish subsumption
        __tuple_of_element<T, 0, C> &&
        // Check constraint satisfaction for subsequent elements
        __check_tuple_elements<T, std::tuple_size_v<T>, C>
));
\end{colorblock}

[\href{https://compiler-explorer.com/z/n6nsdj37j}{Run this example on Compiler Explorer}]

For this to work, the concept template-parameter C needs to be substituted
in the concept \tcode{__tuple_of_element} but not in the atomic constraint
\tcode{__check_tuple_elements<T, std::tuple_size_v<T>, C>}.

Atomic constraints also need to ignore concept template-parameters for the purpose
of comparing their template arguments when establishing atomic constraint equivalence during subsumption.


\section{Status of this proposal and further work}

Our main priority should be to make progress on some form of universal template parameters.

This paper has been implemented in an experimental version of clang, available on godbolt.

Before that, we need to ensure concepts and variable-template template-parameters are supported features so that universal
template-parameters support the gamut of entities that could reasonably be used as template-parameters.

As part of that, subsumption for concept template-parameters, as proposed in this paper, as well as subsumption of fold expressions
should be considered an integral part of the design since adding them later might be somewhat challenging, although it should not affect existing valid code.

\section{Things to be careful about}

Concepts have carefully designed limitations aimed to make subsumption possible and reasonably efficient.
Care has to be taken not to change that.

In particular, specialization of concepts is not allowed nor is declaring concepts in classes or other non-global (potentially dependent)
contexts.

Concept template-parameters need to be substituted when evaluating constraints, but other arguments do not.
Efficient memoization is still possible by caching concept template arguments (and only concept template arguments) along the concept.

Concept template-parameters do not allow a concept to refer to itself, i.e., recursion.
Universal template-parameters may allow recursion.

\begin{colorblock}
template <typename T, __any C, typename...Args>
concept Y = C<C, Args...>;

template <typename T, template <typename...> Concept , typename...Args>
concept Foo = Concept<T, Args...>;

Y<int, Foo>;
\end{colorblock}

This will need careful consideration, but we have options, such as preventing the same concept name from appearing multiple times
or having an implementation-defined limit for how many concepts can be replaced during subsumption.

\section{Implementation}


The paper as proposed has been implemented in a fork of Clang and is available on compiler-explorer.
The implementation revealed no particular challenge. In particular, we confirmed that the proposed changes
do not prevent memoization for subsumption and satisfiability, i.e., a concept and the set of its concept parameters
are what needs to be cached.

\section{Wording}

\subsection{\textcolor{noteclr}{1. Add a grammar production for qualified \grammarterm{concept-name}{s}}}


\rSec2[temp.concept]{Concept definitions}

\begin{bnf}
    \nontermdef{concept-definition}\br
    \keyword{concept} concept-name \opt{attribute-specifier-seq} \terminal{=} constraint-expression \terminal{;}
\end{bnf}

\begin{addedblock}
\begin{bnf}
    \nontermdef{qualified-concept-name}\br
    \opt{nested-name-specifier} concept-name
\end{bnf}
\end{addedblock}

\begin{bnf}
    \nontermdef{concept-name}\br
    identifier
\end{bnf}

\ednote{In [temp.param], use the new production}

\begin{bnf}
    \nontermdef{type-parameter-key}\br
    \keyword{class}\br
    \keyword{typename}
\end{bnf}

\begin{bnf}
    \nontermdef{type-constraint}\br
    \changed{\opt{nested-name-specifier} concept-name}{qualified-concept-name}\br
    \changed{\opt{nested-name-specifier} concept-name}{qualified-concept-name} \terminal{<} \opt{template-argument-list} \terminal{>}
\end{bnf}


\subsection{\textcolor{noteclr}{2. Unifying existing terminology}}

\begin{edblock}
The introduction of new non-type, non non-type template parameters might lead to confusion given the state of the current terminology.
Beside actually specifying the behavior of concept parameters and variable template parameters, we recommend renaming non-type template parameters
and distinguising type template parameters from type-parameters that are not types.

\subsubsection{If it is not a type, what is is?}

A non-type template parameter is neither an expression nor an object. It might be a variable but a non-type template argument is not.
"value template parameter" might work, but we talk in a few places of the "value of a template parameter", and talking about the
"value of a value template-parameter" might be a new source of confusion.
Ultimately, we propose "constant template parameter".

This gives us:

\begin{tabular}{|l|l|}
    \hline
    Grammar&Prose \\
    \hline
    \grammarterm{type-parameter} & type template parameter \\
    \hline
    \grammarterm{parameter-declaration}&  constant template parameter \\
    \hline
    \grammarterm{type-template-parameter}& type template template parameter  \\
    \hline
    \grammarterm{variable-template-parameter}& variable template template parameter\\
    \hline
    \grammarterm{concept-template-parameter}& concept template parameter\\
    \hline
\end{tabular}

\end{edblock}

%We also perform a few cleanups
%
%\end{edblock}
%
%\rSec3[dcl.type.elab]{Elaborated type specifiers}%
%
%\pnum
%If the \grammarterm{identifier} or \grammarterm{simple-template-id}
%in an \grammarterm{elaborated-type-specifier}
%resolves to a \grammarterm{class-name} or
%\grammarterm{enum-name}, the \grammarterm{elaborated-type-specifier}
%introduces it into the declaration the same way a
%\grammarterm{simple-type-specifier} introduces
%its \grammarterm{type-name}\iref{dcl.type.simple}.
%If the \grammarterm{identifier} or \grammarterm{simple-template-id} resolves to a
%\grammarterm{typedef-name}\iref{dcl.typedef,temp.names},
%the \grammarterm{elaborated-type-specifier} is ill-formed.
%\begin{note}
%This implies that, within a class template with a template
%\changed{\grammarterm{type-parameter}}{type parameter} \tcode{T}, the declaration
%\begin{codeblock}
%    friend class T;
%\end{codeblock}
%is ill-formed. However, the similar declaration \tcode{friend T;} is well-formed.\iref{class.friend}.
%\end{note}
%
%\rSec3[temp.dep.type]{Dependent types}
%
%\pnum
%A template argument that is equivalent to a template
%parameter can be used in place of that
%template parameter in a reference to the current instantiation.
%For a template \changed{\grammarterm{type-parameter}}{type parameter},
%a template argument is equivalent to a template parameter
%if it denotes the same type.
%For a non-type template parameter,
%a template argument is equivalent to a template parameter
%if it is an \grammarterm{identifier} that names a variable
%that is equivalent to the template parameter.
%
%
%\rSec3[temp.deduct.type]{Deducing template arguments from a type}
%
%\pnum
%A
%\grammarterm{template-argument}
%can be deduced from a function, pointer to function, or
%pointer-to-member-function type.
%
%\begin{example}
%\begin{codeblock}
%    template<class T> void f(void(*)(T,int));
%    template<class T> void foo(T,int);
%    void g(int,int);
%    void g(char,int);
%
%    void h(int,int,int);
%    void h(char,int);
%    int m() {
%        f(&g);            // error: ambiguous
%        f(&h);            // OK, void \tcode{h(char,int)} is a unique match
%        f(&foo);          // error: type deduction fails because \tcode{foo} is a template
%    }
%\end{codeblock}
%\end{example}
%
%\pnum
%A template
%\grammarterm{type-parameter}
%cannot be deduced from the type of a function default argument.


\subsection{\textcolor{noteclr}{3. Wording for variable-template and concept template parameters}}


\rSec1[basic.pre]{Preamble}

\pnum
Every name is introduced by a \defn{declaration}, which is a
\begin{itemize}
    \item
    \grammarterm{name-declaration},
    \grammarterm{block-declaration}, or
    \grammarterm{member-declaration} \iref{dcl.pre,class.mem},
    \item
    \grammarterm{init-declarator} \iref{dcl.decl},
    \item
    \grammarterm{identifier}
    in a structured binding declaration \iref{dcl.struct.bind},
    \item
    \grammarterm{init-capture} \iref{expr.prim.lambda.capture},
    \item
    \grammarterm{condition} with a \grammarterm{declarator} \iref{stmt.pre},
    \item
    \grammarterm{member-declarator} \iref{class.mem},
    \item
    \grammarterm{using-declarator} \iref{namespace.udecl},
    \item
    \grammarterm{parameter-declaration} \iref{dcl.fct},
    \item
    \grammarterm{type-parameter} \iref{temp.param},
    \begin{addedblock}
    \item \grammarterm{type-template-parameter} \iref{temp.param},
    \item \grammarterm{variable-template-parameter} \iref{temp.param},
    \item \grammarterm{concept-parameter} \iref{temp.param},
    \end{addedblock}
    \item
    \grammarterm{elaborated-type-specifier}
    that introduces a name \iref{dcl.type.elab},
    \item
    \grammarterm{class-specifier} \iref{class.pre},
    \item
    \grammarterm{enum-specifier} or
    \grammarterm{enumerator-definition} \iref{dcl.enum},
    \item
    \grammarterm{exception-declaration} \iref{except.pre}, or
    \item
    implicit declaration of an injected-class-name \iref{class.pre}.
\end{itemize}


\rSec2[basic.lookup.argdep]{Argument-dependent name lookup}

\pnum
When the \grammarterm{postfix-expression} in
a function call\iref{expr.call} is an \grammarterm{unqualified-id},
and unqualified lookup\iref{basic.lookup.unqual}
for the name in the \grammarterm{unqualified-id} does not find any
\begin{itemize}
    \item
    declaration of a class member, or
    \item
    function declaration inhabiting a block scope, or
    \item
    declaration not of a function or function template
\end{itemize}
then lookup for the name also includes the result of
\defnadj{argument-dependent}{lookup} in a set of associated namespaces
that depends on the types of the arguments
(and for \added{type} template template arguments, the namespace of the template argument),
as specified below.

\textcolor{noteclr}{[...]}

\pnum
For each argument type \tcode{T} in the function call,
there is a set of zero or more \defnx{associated entities}{entity!associated}
to be considered.
The set of entities is determined entirely by
the types of the function arguments
(and any \changed{template}{\grammarterm{type template}
} template arguments).
Any \grammarterm{typedef-name}s and \grammarterm{using-declaration}{s}
used to specify the types
do not contribute to this set.
The set of entities
is determined in the following way:
\begin{itemize}
    \item If \tcode{T} is a fundamental type, its associated set of
    entities is empty.

    \item If \tcode{T} is a class type (including unions),
    its associated entities are:
    the class itself;
    the class of which it is a member, if any;
    and its direct and indirect base classes.
    Furthermore, if \tcode{T} is a class template specialization,
    its associated entities also include:
    the entities
    associated with the types of the template arguments
    provided for template type parameters;
    the templates used as \added{type} template template arguments; and
    the classes of which any member templates used as  \added{type} template template
    arguments are members.
    \begin{note}
        \changed{Non-type}{constant} template arguments\added{, variable template template arguments and concept template arguments} do not
        contribute to the set of associated entities.
    \end{note}

    \item If \tcode{T} is an enumeration type,
    its associated entities are \tcode{T}
    and, if it is a class member, the member's class.

    \item If \tcode{T} is a pointer to \tcode{U} or an array of \tcode{U},
    its associated entities are those associated with \tcode{U}.

    \item If \tcode{T} is a function type, its associated
    entities are those associated with the function parameter types and those
    associated with the return type.

    \item If \tcode{T} is a pointer to a member function of a class
    \tcode{X}, its associated entities are those associated
    with the function parameter types and return type, together with those
    associated with \tcode{X}.

    \item If \tcode{T} is a pointer to a data member of class \tcode{X}, its
    associated entities are those associated with the member
    type together with those associated with \tcode{X}.
\end{itemize}
In addition, if the argument is an overload set or the address of such a set,
its associated entities
are the union of those associated with each of the
members of the set, i.e., the entities associated with its
parameter types and return type.
Additionally, if the aforementioned overload set is named with
a \grammarterm{template-id}, its associated entities also include
its template \grammarterm{template-argument}{s} \added{denoting a class template} and
those associated with its type \grammarterm{template-argument}s.

\pnum
The \term{associated namespaces} for a call are
the innermost enclosing non-inline namespaces for its associated entities
as well as every element of the inline namespace set \iref{namespace.def}
of those namespaces.
Argument-dependent lookup finds
all declarations of functions and function templates that
\begin{itemize}
    \item
    are found by a search of any associated namespace, or
    \item
    are declared as a friend \iref{class.friend} of any class
    with a reachable definition in the set of associated entities, or
    \item
    are exported,
    are attached to a named module \tcode{M} \iref{module.interface},
    do not appear in the translation unit containing the point of the lookup, and
    have the same innermost enclosing non-inline namespace scope as
    a declaration of an associated entity attached to \tcode{M} \iref{basic.link}.
\end{itemize}
If the lookup is for a dependent name \iref{temp.dep,temp.dep.candidate},
the above lookup is also performed
from each point in the instantiation context \iref{module.context} of the lookup,
additionally ignoring any declaration that
appears in another translation unit,
is attached to the global module, and
is either discarded \iref{module.global.frag} or has internal linkage.

\rSec2[lex.ext]{User-defined literals}

\pnum
If \placeholder{L} is a \grammarterm{user-defined-string-literal},
let \placeholder{str} be the literal without its \grammarterm{ud-suffix}
and let \placeholder{len} be the number of code units in \placeholder{str}
(i.e., its length excluding the terminating null character).
If \placeholder{S} contains a literal operator template with
a \changed{non-type}{constant} template parameter for which \placeholder{str} is
a well-formed \grammarterm{template-argument},
the literal \placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator ""@\placeholder{X}@<@\placeholder{str}{}@>()
\end{codeblock}
Otherwise, the literal \placeholder{L} is treated as a call of the form
\begin{codeblock}
    operator ""@\placeholder{X}@(@\placeholder{str}{}@, @\placeholder{len}{}@)
\end{codeblock}

\rSec1[expr.const]{Constant expressions}%

\pnum
A \defnadj{converted constant}{expression}
of type \tcode{T} is an
expression, implicitly converted to type \tcode{T}, where
the converted expression is a constant expression and the
implicit conversion sequence contains only
\begin{itemize}
    \item user-defined conversions,
    \item \textcolor{noteclr}{[...]}
    \item function pointer conversions\iref{conv.fctptr},
\end{itemize}
and where the reference binding (if any) binds directly.
\begin{note}
    Such expressions can be used in \keyword{new}
    expressions\iref{expr.new}, as case expressions\iref{stmt.switch},
    as enumerator initializers if the underlying type is
    fixed\iref{dcl.enum}, as array bounds\iref{dcl.array}, and
    as \changed{non-type}{constant} template
    arguments\iref{temp.arg}.
\end{note}


\rSec2[dcl.typedef]{The \keyword{typedef} specifier}%


\pnum
\indextext{class name!\idxcode{typedef}}%
A \grammarterm{simple-template-id} is only a \grammarterm{typedef-name}
if its \grammarterm{template-name} names
an alias template or \changed{a template \grammarterm{template-parameter}}{a \grammarterm{type-template-parameter}}.
\begin{note}
    A \grammarterm{simple-template-id} that names a class template specialization
    is a \grammarterm{class-name} \iref{class.name}.
    If a \grammarterm{typedef-name} is used to identify the subject of an
    \grammarterm{elaborated-type-specifier} \iref{dcl.type.elab}, a class
    definition \iref{class}, a constructor
    declaration \iref{class.ctor}, or a destructor
    declaration \iref{class.dtor}, the program is ill-formed.
\end{note}

\rSec3[dcl.type.decltype]{Decltype specifiers}%
\indextext{type specifier!\idxcode{decltype}}%

\indextext{type specifier!\idxcode{decltype}}%
For an expression $E$, the type denoted by \tcode{decltype($E$)} is defined as follows:
\begin{itemize}
\item if $E$ is an unparenthesized \grammarterm{id-expression}
naming a structured binding\iref{dcl.struct.bind},
\tcode{decltype($E$)} is the referenced type as given in
the specification of the structured binding declaration;

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression}
naming a \changed{non-type}{constant} \grammarterm{template-parameter}\iref{temp.param},
\tcode{decltype($E$)} is the type of the \grammarterm{template-parameter}
after performing any necessary
type deduction\iref{dcl.spec.auto,dcl.type.class.deduct};

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression} or
an unparenthesized
class
member access\iref{expr.ref}, \tcode{decltype($E$)} is the
type of the entity named by $E$.
If there is no such entity, the program is ill-formed;

\item otherwise, if $E$ is
an xvalue, \tcode{decltype($E$)} is \tcode{T\&\&}, where \tcode{T} is the type
of $E$;

\item otherwise, if $E$ is an lvalue, \tcode{decltype($E$)}
is \tcode{T\&}, where \tcode{T} is the type of $E$;

\item otherwise, \tcode{decltype($E$)} is the type of $E$.
\end{itemize}

\rSec3[dcl.type.auto.deduct]{Placeholder type deduction}
\indextext{deduction!placeholder type}%

\pnum
\defnx{Placeholder type deduction}{placeholder type deduction}
is the process by which
a type containing a placeholder type
is replaced by a deduced type.

\pnum
A type \tcode{T} containing a placeholder type,
and a corresponding \grammarterm{initializer-clause} $E$,
are determined as follows:
\begin{itemize}
\item
For a non-discarded \tcode{return} statement that occurs
in a function declared with a return type
that contains a placeholder type,
\tcode{T} is the declared return type.

\item \textcolor{noteclr}{[...]}

\item
For a \changed{non-type}{constant} template parameter declared with a type
that contains a placeholder type,
\tcode{T} is the declared type of the \changed{non-type}{constant} template parameter
and $E$ is the corresponding template argument.
\end{itemize}


\rSec1[dcl.struct.bind]{Structured binding declarations}%

\pnum
Otherwise, if
the \grammarterm{qualified-id} \tcode{std::tuple_size<E>}
names a complete class type with a member named \tcode{value},
the expression \tcode{std::tuple_size<E>::value}
shall be a well-formed integral constant expression
and
the number of elements in
the \grammarterm{attributed-identifier-list} shall be equal to the value of that
expression.
Let \tcode{i} be an index prvalue of type \tcode{std::size_t}
corresponding to $\tcode{v}_i$.
If a search for the name \tcode{get}
in the scope of \tcode{E}\iref{class.member.lookup}
finds at least one declaration
that is a function template whose first template parameter
is a \changed{non-type}{constant template} parameter,
the initializer is
\tcode{\exposidnc{e}.get<i>()}. Otherwise, the initializer is \tcode{get<i>(\exposid{e})},
where \tcode{get} undergoes argument-dependent lookup\iref{basic.lookup.argdep}.

\rSec1[over.over]{Address of an overload set}%

\pnum
An \grammarterm{id-expression}
whose terminal name refers to an overload set $S$ and
that appears without arguments
is resolved to
a function,
a pointer to function, or
a pointer to member function
for a specific function
that is chosen from a set of functions selected from $S$
determined based on the target type required in the context (if any),
as described below.
The target can be
\begin{itemize}
    \item
    an object or reference being initialized \iref{dcl.init,dcl.init.ref,dcl.init.list},
    \item \textcolor{noteclr}{[...]}
    \item
    a \changed{non-type}{constant}
    \grammarterm{template-parameter} \iref{temp.arg.nontype}.
\end{itemize}
The \grammarterm{id-expression} can be preceded by the \tcode{\&} operator.

\rSec1[over.literal]{User-defined literals}%

\pnum
A \defnx{numeric literal operator template}{literal!operator!template numeric}
is a literal operator template whose \grammarterm{template-parameter-list}
has a single \grammarterm{template-parameter}
that is a \changed{non-type}{constant} template parameter pack\iref{temp.variadic}
with element type \tcode{char}.
A \defnx{string literal operator template}{literal!operator!template string}
is a literal operator template whose \grammarterm{template-parameter-list}
comprises
a single \changed{non-type}{constant} \grammarterm{template-parameter} of class type.
The declaration of a literal operator template
shall have an empty \grammarterm{parameter-declaration-clause}
and shall declare either a numeric literal operator template
or a string literal operator template.


\rSec1[temp.param]{Template parameters}


\pnum
The syntax for
\grammarterm{template-parameter}{s}
is:

\begin{bnf}
    \nontermdef{template-parameter}\br
    type-parameter\br
    parameter-declaration\br
\begin{addedblock}
    type-template-parameter \br
    variable-template-parameter \br
    concept-parameter
\end{addedblock}
\end{bnf}

\begin{bnf}
    \nontermdef{type-parameter}\br
    type-parameter-key \opt{\terminal{...}} \opt{identifier}\br
    type-parameter-key \opt{identifier} \terminal{=} type-id\br
    type-constraint \opt{\terminal{...}} \opt{identifier}\br
    type-constraint \opt{identifier} \terminal{=} type-id\br
    \removed{template-head type-parameter-key \opt{\terminal{...}} \opt{identifier}\br}
    \removed{template-head type-parameter-key \opt{identifier} \terminal{=} id-expression}
\end{bnf}

\begin{bnf}
    \nontermdef{type-parameter-key}\br
    \keyword{class}\br
    \keyword{typename}
\end{bnf}

\begin{bnf}
    \nontermdef{type-constraint}\br
    qualified-concept-name \br
    qualified-concept-name \terminal{<} \opt{template-argument-list} \terminal{>}
\end{bnf}

\begin{addedblock}

\begin{bnf}
\nontermdef{type-template-parameter}\br
template-head type-parameter-key \opt{\terminal{...}} \opt{identifier}\br
template-head type-parameter-key \opt{identifier} \terminal{=} id-expression
\end{bnf}

\begin{bnf}
    \nontermdef{variable-template-parameter}\br
    template-head \terminal{auto} \opt{\terminal{...}} \opt{identifier}\br
    template-head \terminal{auto} \opt{identifier} \terminal{=} id-expression
\end{bnf}

\begin{bnf}
    \nontermdef{concept-parameter}\br
    template < template-parameter-list > \terminal{concept} \opt{\terminal{...}} \opt{identifier}\br
    template < template-parameter-list > \terminal{concept} \opt{identifier} \terminal{=} qualified-concept-name
\end{bnf}

A \defn{template template parameter} refers to either a \grammarterm{type-template-parameter}, a \grammarterm{variable-template-parameter},  or \grammarterm{concept-parameter}. A \defn{constant template parameter} is a template parameter introduced by a \grammarterm{parameter-declaration}.

\end{addedblock}

\indextext{component name}%
The component names of a \grammarterm{type-constraint} are
its \grammarterm{concept-name} and
those of its \grammarterm{nested-name-specifier} (if any).
\begin{note}
    The \tcode{>} token following the
    \grammarterm{template-parameter-list} of a
    \changed{\grammarterm{type-parameter}}{template template parameter}
    can be the product of replacing a
    \tcode{>>} token by two consecutive \tcode{>}
    tokens \iref{temp.names}.
\end{note}

\pnum
There is no semantic difference between
\keyword{class}
and
\keyword{typename}
in a
\grammarterm{type-parameter-key}.
\keyword{typename}
followed by an
\grammarterm{unqualified-id}
names a template type parameter.
\keyword{typename}
followed by a
\grammarterm{qualified-id}
denotes the type in a \removed{non-type \grammarterm{parameter-declaration}}\added{constant template parameter}.

\ednote{Remove the footnote}

\begin{removedblock}
\begin{wfootnote}
    \removed{Since template
    \grammarterm{template-parameter}{s}
    and template
    \grammarterm{template-argument}{s}
    are treated as types for descriptive purposes, t}he terms
    \term{non-type parameter}
    and
    \term{non-type argument}
    are used to refer to non-type, non-template parameters and arguments.
\end{wfootnote}
\end{removedblock}

A \grammarterm{template-parameter} of the form
\keyword{class} \grammarterm{identifier} is a \grammarterm{type-parameter}.
\begin{example}
    \begin{codeblock}
        class T { /*...*/ };
        int i;

        template<class T, T i> void f(T t) {
            T t1 = i;         // template-parameters \tcode{T} and \tcode{i}
            ::T t2 = ::i;     // global namespace members \tcode{T} and \tcode{i}
        }
    \end{codeblock}
    Here, the template \tcode{f} has a \grammarterm{type-parameter}
    called \tcode{T}, rather than an unnamed \changed{non-type}{constant}
    \grammarterm{template-parameter} of class \tcode{T}.
\end{example}
A storage class shall not be specified in a
\grammarterm{template-parameter}
declaration.
Types shall not be defined in a \grammarterm{template-parameter}
declaration.

\pnum
The \grammarterm{identifier} in a \grammarterm{type-parameter} is not looked up.
A \grammarterm{type-parameter}
whose \grammarterm{identifier} does not follow an ellipsis
defines its
\grammarterm{identifier}
to be a
\grammarterm{typedef-name}
\removed{(if declared without
\keyword{template})
or
\grammarterm{template-name}
(if declared with
\keyword{template})}
in the scope of the template declaration.

\begin{addedblock}
The \grammarterm{identifier} in a \grammarterm{template-template-parameter} is not looked up.
A template template parameter \tcode{P} whose \grammarterm{identifier} does not follow an ellipsis defines its
\grammarterm{identifier} to be a \grammarterm{concept-name} \tcode{T} if \tcode{P} is a \grammarterm{concept-parameter}
or a \grammarterm{template-name} \tcode{T} otherwise.
\tcode{T} is declared in the scope of the template declaration.
\end{addedblock}

\begin{note}
A template argument can be a class template or alias template.
For example,

\begin{codeblock}
    template<class T> class myarray { /*...*/ };

    template<class K, class V, template<class T> class C = myarray>
    class Map {
        C<K> key;
        C<V> value;
    };
\end{codeblock}
\end{note}


\textcolor{noteclr}{[...]}

\pnum
A \changed{non-type}{constant} \grammarterm{template-parameter}
shall have one of the following (possibly cv-qualified) types:
\begin{itemize}
    \item a structural type (see below),
    \item a type that contains a placeholder type\iref{dcl.spec.auto}, or
    \item a placeholder for a deduced class type\iref{dcl.type.class.deduct}.
\end{itemize}
The top-level
\grammarterm{cv-qualifier}{s}
on the
\grammarterm{template-parameter}
are ignored when determining its type.

\pnum
\label{term.structural.type}%
A \defnadj{structural}{type} is one of the following:
\begin{itemize}
\item a scalar type, or
\item an lvalue reference type, or
\item a literal class type with the following properties:
\begin{itemize}
    \item
    all base classes and non-static data members are public and non-mutable and
    \item
    the types of all bases classes and non-static data members are
    structural types or (possibly multidimensional) array thereof.
\end{itemize}
\end{itemize}

\pnum
An \grammarterm{id-expression} naming
a \changed{non-type}{constant} \grammarterm{template-parameter} of class type \tcode{T}
denotes a static storage duration object of type \tcode{const T},
known as a \defn{template parameter object},
which is template-argument-equivalent\iref{temp.type} to
the corresponding template argument
after it has been converted
to the type of the \grammarterm{template-parameter}\iref{temp.arg.nontype}.
No two template parameter objects are template-argument-equivalent.
\begin{note}
    If an \grammarterm{id-expression} names
    a \removed{non-type} non-reference \added{constant} \grammarterm{template-parameter},
    then it is a prvalue if it has non-class type.
    Otherwise, if it is of class type \tcode{T},
    it is an lvalue and has type \tcode{const T} \iref{expr.prim.id.unqual}.
\end{note}

\begin{example}
    \begin{codeblock}
        using X = int;
        struct A {};
        template<const X& x, int i, A a> void f() {
            i++;                          // error: change of \grammarterm{template-parameter} value

            &x;                           // OK
            &i;                           // error: address of non-reference template-parameter
            &a;                           // OK
            int& ri = i;                  // error: attempt to bind non-const reference to temporary
            const int& cri = i;           // OK, const reference binds to temporary
            const A& ra = a;              // OK, const reference binds to a template parameter object
        }
    \end{codeblock}
\end{example}

\pnum
\begin{note}
    A \changed{non-type}{constant}
    \grammarterm{template-parameter}
    cannot be declared to have type \cv{} \keyword{void}.
    \begin{example}
        \begin{codeblock}
            template<void v> class X;       // error
            template<void* pv> class Y;     // OK
        \end{codeblock}
    \end{example}
\end{note}

\pnum
A \changed{non-type}{constant}
\grammarterm{template-parameter}
\indextext{array!template parameter of type}%
of type ``array of \tcode{T}'' or
\indextext{function!template parameter of type}%
of function type \tcode{T}
is adjusted to be of type ``pointer to \tcode{T}''.
\begin{example}
    \begin{codeblock}
        template<int* a>   struct R {  };
        template<int b[5]> struct S {  };
        int p;
        R<&p> w;                        // OK
        S<&p> x;                        // OK due to parameter adjustment
        int v[5];
        R<v> y;                         // OK due to implicit argument conversion
        S<v> z;                         // OK due to both adjustment and conversion
    \end{codeblock}
\end{example}

\pnum
A \changed{non-type}{constant} template parameter declared with a type that
contains a placeholder type with a \grammarterm{type-constraint}
introduces the immediately-declared constraint
of the \grammarterm{type-constraint}
for the invented type corresponding to the placeholder \iref{dcl.fct}.

\pnum
A \defnadj{default}{template argument} is
a template argument \iref{temp.arg} specified after \tcode{=}
in a \grammarterm{template-parameter}.
A default template argument may be specified for
any kind of \grammarterm{template-parameter} (type, \changed{non-type}{constant}, template)
that is not a template parameter pack\iref{temp.variadic}.
A default template argument may be specified in a template declaration.
A default template argument shall not be specified in
the \grammarterm{template-parameter-list}{s}
of the definition of a member of a class template
that appears outside of the member's class.
A default template argument
shall not be specified in a friend class template declaration.
If a friend function template declaration $D$
specifies a default template argument,
that declaration shall be a definition and
there shall be no other declaration of the function template
which is reachable from $D$ or from which $D$ is reachable.

\textcolor{noteclr}{[...]}

\indextext{\idxcode{<}!template and}%
\pnum
When parsing a default template argument
for a \changed{non-type}{constant} \grammarterm{template-parameter},
the first non-nested \tcode{>} is taken as
the end of the \grammarterm{template-parameter-list}
rather than a greater-than operator.
\begin{example}
    \begin{codeblock}
        template<int i = 3 > 4 >        // syntax error
        class X {  };

        template<int i = (3 > 4) >      // OK
        class Y {  };
    \end{codeblock}
\end{example}

\pnum
If a \grammarterm{template-parameter} is a
\grammarterm{type-parameter} with an ellipsis prior to its
optional \grammarterm{identifier} or is a
\grammarterm{parameter-declaration} that declares a
pack\iref{dcl.fct}, then the \grammarterm{template-parameter}
is a template parameter pack\iref{temp.variadic}.
A template parameter pack that is a \grammarterm{parameter-declaration} whose type
contains one or more unexpanded packs is a pack expansion. Similarly,
a template parameter pack that is a \grammarterm{type-parameter} with a
\grammarterm{template-parameter-list} containing one or more unexpanded
packs is a pack expansion.
A type parameter pack with a \grammarterm{type-constraint} that
contains an unexpanded parameter pack is a pack expansion.
A template parameter pack that is a pack
expansion shall not expand a template parameter pack declared in the same
\grammarterm{template-parameter-list}.
\begin{example}
\begin{codeblock}
    template <class... Types>                       // \tcode{Types} is a template type parameter pack
    class Tuple;                                 // but not a pack expansion

    template <class T, int... Dims>                 // \tcode{Dims} is a \changed{non-type}{constant} template parameter pack
    struct multi_array;                          // but not a pack expansion

    template <class... T>
    struct value_holder {
        template <T... Values> struct apply { };    // \tcode{Values} is a \changed{non-type}{constant} template parameter pack
    };                                            // and a pack expansion

    template <class... T, T... Values>              // error: \tcode{Values} expands template type parameter
    struct static_array;                          // pack \tcode{T} within the same template parameter list
\end{codeblock}
\end{example}

\textcolor{noteclr}{[...]}

\ednote{Modify [temp.param]/p16 As follow}

\pnum
If a \grammarterm{template-parameter} is \removed{a
\grammarterm{type-parameter} with an ellipsis prior to its
optional \grammarterm{identifier} or is a
\grammarterm{parameter-declaration} that declares a
pack \iref{dcl.fct}}
\begin{addedblock}
\begin{itemize}
\item a \grammarterm{type-parameter} with an ellipsis prior to its optional \grammarterm{identifier},
\item a \grammarterm{parameter-declaration} that declares a pack \iref{dcl.fct}, or
\item a template template parameter with an ellipsis prior to its optional \grammarterm{identifier},
\end{itemize}
\end{addedblock}
then the \grammarterm{template-parameter}
is a template parameter pack \iref{temp.variadic}.
A template parameter pack that is a \grammarterm{parameter-declaration} whose type
contains one or more unexpanded packs is a pack expansion. Similarly,
a template parameter pack that is a \grammarterm{\changed{type-}{template-template-}parameter} with a
\grammarterm{template-parameter-list} containing one or more unexpanded
packs is a pack expansion.
A type parameter pack with a \grammarterm{type-constraint} that
contains an unexpanded parameter pack is a pack expansion.
A template parameter pack that is a pack
expansion shall not expand a template parameter pack declared in the same
\grammarterm{template-parameter-list}.

\textcolor{noteclr}{[...]}

\rSec1[temp.names]{Names of template specializations}

\pnum
A template specialization \iref{temp.spec} can be referred to by a
\grammarterm{template-id}:

\begin{bnf}
    \nontermdef{simple-template-id}\br
    template-name \terminal{<} \opt{template-argument-list} \terminal{>}
\end{bnf}

\begin{bnf}
    \nontermdef{template-id}\br
    simple-template-id\br
    operator-function-id \terminal{<} \opt{template-argument-list} \terminal{>}\br
    literal-operator-id \terminal{<} \opt{template-argument-list} \terminal{>}
\end{bnf}

\begin{bnf}
    \nontermdef{template-name}\br
    identifier
\end{bnf}

\begin{bnf}
    \nontermdef{template-argument-list}\br
    template-argument \opt{\terminal{...}}\br
    template-argument-list \terminal{,} template-argument \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
    \nontermdef{template-argument}\br
    constant-expression\br
    type-id\br
    id-expression\br
    \added{concept-name}
\end{bnf}

\textcolor{noteclr}{[...]}

\pnum
A \defn{concept-id} is a \grammarterm{simple-template-id}
where the \grammarterm{template-name} is a \grammarterm{concept-name}.
A concept-id is a prvalue of type \tcode{bool}, and
does not name a template specialization.
A concept-id evaluates to \tcode{true}
if the concept's
normalized \grammarterm{constraint-expression} \iref{temp.constr.decl}
is satisfied \iref{temp.constr.constr} by the specified template arguments and
\tcode{false} otherwise.
\begin{note}
    Since a \grammarterm{constraint-expression} is an unevaluated operand,
    a concept-id appearing in a \grammarterm{constraint-expression}
    is not evaluated except as necessary
    to determine whether the normalized constraints are satisfied.
\end{note}
\begin{example}
    \begin{codeblock}
        template<typename T> concept C = true;
        static_assert(C<int>);      // OK
    \end{codeblock}
\end{example}

\textcolor{noteclr}{[...]}


\rSec2[temp.arg.template]{Template template arguments}

\rSec2[temp.arg.general]{General}

\pnum
\indextext{argument!template}%
There are three forms of
\grammarterm{template-argument},
corresponding to the three forms of
\grammarterm{template-parameter}:
type, \changed{non-type}{constant} and template.
\begin{addedblock}
A template template argument can name a type or alias template, a variable template or a concept.
\end{addedblock}

The type and form of each
\grammarterm{template-argument}
specified in a
\grammarterm{template-id}
shall match the type and form specified for the corresponding
parameter declared by the template in its
\grammarterm{template-parameter-list}.
When the parameter declared by the template is a template
parameter pack \iref{temp.variadic}, it will correspond to zero or more
\grammarterm{template-argument}{s}.
\begin{example}
\begin{codeblock}
    template<class T> class Array {
        T* v;
        int sz;
        public:
        explicit Array(int);
        T& operator[](int);
        T& elem(int i) { return v[i]; }
    };

    Array<int> v1(20);
    typedef std::complex<double> dcomplex;  // \tcode{std::complex} is a standard library template
    Array<dcomplex> v2(30);
    Array<dcomplex> v3(40);

    void bar() {
        v1[3] = 7;
        v2[3] = v3.elem(4) = dcomplex(7,8);
    }
\end{codeblock}
\end{example}

\textcolor{noteclr}{[...]}

\rSec2[temp.arg.type]{Template type arguments}

\pnum
A \grammarterm{template-argument} for \changed{a \grammarterm{template-parameter} which is a type}{\grammarterm{type-parameter}} shall be a \grammarterm{type-id}.

\pnum
\begin{example}
    \begin{codeblock}
        template <class T> class X { };
        template <class T> void f(T t) { }
        struct { } unnamed_obj;

        void f() {
            struct A { };
            enum { e1 };
            typedef struct { } B;
            B b;
            X<A> x1;          // OK
            X<A*> x2;         // OK
            X<B> x3;          // OK
            f(e1);            // OK
            f(unnamed_obj);   // OK
            f(b);             // OK
        }
    \end{codeblock}
\end{example}
\begin{note}
A template type argument can be an incomplete type\iref{term.incomplete.type}.
\end{note}

\textcolor{noteclr}{[...]}

\rSec2[temp.arg.nontype]{Template \changed{non-type}{constant} arguments}

\pnum
If the type \tcode{T} of a \grammarterm{template-parameter} \iref{temp.param}
contains a placeholder type \iref{dcl.spec.auto}
or a placeholder for a deduced class type \iref{dcl.type.class.deduct},
the type of the parameter is the type deduced
for the variable \tcode{x} in the invented declaration
\begin{codeblock}
    T x = @$E$@ ;
\end{codeblock}
where $E$ is the template argument provided for the parameter.
\begin{note}
    $E$ is a \grammarterm{template-argument} or
    (for a default template argument) an \grammarterm{initializer-clause}.
\end{note}
If a deduced parameter type is not permitted
for a \grammarterm{template-parameter} declaration \iref{temp.param},
the program is ill-formed.

\pnum
The value of a \changed{non-type}{constant} \grammarterm{template-parameter} $P$
of (possibly deduced) type \tcode{T}
is determined from its template argument $A$ as follows.
If \tcode{T} is not a class type and
$A$ is not a \grammarterm{braced-init-list},
$A$ shall be a converted constant expression \iref{expr.const}
of type \tcode{T}; the value of $P$ is $A$ (as converted).

\pnum
Otherwise, a temporary variable
\begin{codeblock}
    constexpr T v = @$A$@;
\end{codeblock}
is introduced.
The lifetime of \tcode{v} ends immediately after initializing it and
any template parameter object (see below).
For each such variable,
the \grammarterm{id-expression} \tcode{v}
is termed a \defn{candidate initializer}.

\pnum
If \tcode{T} is a class type,
a template parameter object\iref{temp.param} exists
that is constructed so as to be template-argument-equivalent to \tcode{v};
$P$ denotes that template parameter object.
$P$ is copy-initialized from an unspecified candidate initializer
that is template-argument-equivalent to \tcode{v}.
If, for the initialization from any candidate initializer,
\begin{itemize}
    \item
    the initialization would be ill-formed, or
    \item
    the full-expression of an invented \grammarterm{init-declarator}
    for the initialization would not be a constant expression
    when interpreted as a \grammarterm{constant-expression}\iref{expr.const}, or
    \item
    the initialization would cause $P$ to not be template-argument-equivalent\iref{temp.type} to \tcode{v},
\end{itemize}
the program is ill-formed.

\pnum
Otherwise, the value of $P$ is that of v.

\pnum
For a \changed{non-type}{constant} \grammarterm{template-parameter} of reference or pointer type,
or for each non-static data member of reference or pointer type
in a \changed{non-type}{constant} \grammarterm{template-parameter} of class type or subobject thereof,
the reference or pointer value shall not refer to
or be the address of (respectively):
\begin{itemize}
    \item a temporary object\iref{class.temporary},
    \item a string literal object\iref{lex.string},
    \item the result of a \tcode{typeid} expression\iref{expr.typeid},
    \item a predefined \mname{func} variable\iref{dcl.fct.def.general}, or
    \item a subobject\iref{intro.object} of one of the above.
\end{itemize}


\rSec2[temp.arg.template]{Template template arguments}

\pnum
\removed{A
\grammarterm{template-argument}
for a template
\grammarterm{template-parameter}
shall be the name of a class template or an alias template, expressed as
\grammarterm{id-expression}.}

\begin{addedblock}
A \grammarterm{template-argument} for a template template parameter shall be an \grammarterm{id-expression} denoting
\begin{itemize}
\item a class template or an alias template for a \grammarterm{type-template-parameter},
\item a variable template for a \grammarterm{variable-template-parameter}, and
\item a \grammarterm{concept-name} for a \grammarterm{concept-template-parameter}.
\end{itemize}
\end{addedblock}

Only primary templates are considered when matching the template template
argument with the corresponding parameter; partial specializations are not
considered even if their parameter lists match that of the template template
parameter.

\pnum
Any partial specializations \iref{temp.spec.partial} associated with the
primary template are considered when a
specialization based on the template
\grammarterm{template-parameter}
is instantiated.
If a specialization is not reachable from the point of instantiation,
and it would have been selected had it been reachable, the program is ill-formed,
no diagnostic required.
\begin{example}
    \begin{codeblock}
        template<class T> class A {     // primary template
            int x;
        };
        template<class T> class A<T*> { // partial specialization
            long x;
        };
        template<template<class U> class V> class C {
            V<int>  y;
            V<int*> z;
        };
        C<A> c;             // \tcode{V<int>} within \tcode{C<A>} uses the primary template, so \tcode{c.y.x} has type \tcode{int}
        // \tcode{V<int*>} within \tcode{C<A>} uses the partial specialization, so \tcode{c.z.x} has type \tcode{long}
    \end{codeblock}
\end{example}

\begin{addedblock}
Two template parameters are of the same kind if:
\begin{itemize}
\item they are both \grammarterm{type-parameter}{s},
\item they are both non-type parameters,
\item they are both \grammarterm{type-template-parameter}{s},
\item they are both \grammarterm{variable-template-parameter}{s}, or
\item they are both \grammarterm{concept-parameter}{s}.
\end{itemize}

A template template parameter \placeholder{P} and a template argument \placeholder{A} are compatible if
\begin{itemize}
\item \placeholder{A} denotes a class template or alias template and \placeholder{P} is a \grammarterm{type-template-parameter},
\item \placeholder{A} denotes a variable template and \placeholder{P} is a \grammarterm{variable-template-parameter}, or
\item \placeholder{A} denotes a \grammarterm{concept-name} and \placeholder{P} is a \grammarterm{concept-parameter}.
\end{itemize}
\end{addedblock}

\ednote {See CWG2398}

\pnum
A \grammarterm{template-argument} matches a template
\grammarterm{template-parameter} \tcode{P} when \added{\tcode{A} and \tcode{P} are compatible and}
\tcode{P} is at least as specialized as the \grammarterm{template-argument} \tcode{A}.
In this comparison, if \tcode{P} is unconstrained,
the constraints on \tcode{A} are not considered.
If \tcode{P} contains a template parameter pack, then \tcode{A} also matches \tcode{P}
if each of \tcode{A}'s template parameters
matches the corresponding template parameter in the
\grammarterm{template-head} of \tcode{P}.
Two template parameters match if they are of the same kind \removed{(type, non-type, template)},
for \changed{non-type}{constant} \grammarterm{template-parameter}{s}, their types are
equivalent \iref{temp.over.link}, and for template \grammarterm{template-parameter}{s},
each of their corresponding \grammarterm{template-parameter}{s} matches, recursively.
When \tcode{P}'s \grammarterm{template-head} contains a template parameter
pack \iref{temp.variadic}, the template parameter pack will match zero or more template
parameters or template parameter packs in the \grammarterm{template-head} of
\tcode{A} with the same type and form as the template parameter pack in \tcode{P}
(ignoring whether those template parameters are template parameter packs).

\begin{example}
\begin{codeblock}
    template<class T> class A { /*...*/ };
    template<class T, class U = T> class B { /*...*/ };
    template<class ... Types> class C { /*...*/ };
    template<auto n> class D { /*...*/ };
    template<template<class> class P> class X { /*...*/ };
    template<template<class ...> class Q> class Y { /*...*/ };
    template<template<int> class R> class Z { /*...*/ };

    X<A> xa;            // OK
    X<B> xb;            // OK
    X<C> xc;            // OK
    Y<A> ya;            // OK
    Y<B> yb;            // OK
    Y<C> yc;            // OK
    Z<D> zd;            // OK
\end{codeblock}
\end{example}
\begin{example}
\begin{codeblock}
    template <class T> struct eval;

    template <template <class, class...> class TT, class T1, class... Rest>
    struct eval<TT<T1, Rest...>> { };

    template <class T1> struct A;
    template <class T1, class T2> struct B;
    template <int N> struct C;
    template <class T1, int N> struct D;
    template <class T1, class T2, int N = 17> struct E;

    eval<A<int>> eA;                // OK, matches partial specialization of \tcode{eval}
    eval<B<int, float>> eB;         // OK, matches partial specialization of \tcode{eval}
    eval<C<17>> eC;                 // error: \tcode{C} does not match \tcode{TT} in partial specialization
    eval<D<int, 17>> eD;            // error: \tcode{D} does not match \tcode{TT} in partial specialization
    eval<E<int, float>> eE;         // error: \tcode{E} does not match \tcode{TT} in partial specialization
\end{codeblock}
\end{example}
\begin{example}
    \begin{codeblock}
        template<typename T> concept C = requires (T t) { t.f(); };
        template<typename T> concept D = C<T> && requires (T t) { t.g(); };

        template<template<C> class P> struct S { };

        template<C> struct X { };
        template<D> struct Y { };
        template<typename T> struct Z { };

        S<X> s1;            // OK, \tcode{X} and \tcode{P} have equivalent constraints
        S<Y> s2;            // error: \tcode{P} is not at least as specialized as \tcode{Y}
        S<Z> s3;            // OK, \tcode{P} is at least as specialized as \tcode{Z}
    \end{codeblock}
\end{example}

\pnum
A template \grammarterm{template-parameter} \tcode{P} is
at least as specialized as a template \grammarterm{template-argument} \tcode{A}
if, given the following rewrite to two function templates,
the function template corresponding to \tcode{P}
is at least as specialized as
the function template corresponding to \tcode{A}
according to the partial ordering rules
for function templates \iref{temp.func.order}.
Given an invented class template \tcode{X}
with the \grammarterm{template-head} of \tcode{A} (including default arguments
and \grammarterm{requires-clause}, if any):

\begin{itemize}
    \item
    Each of the two function templates has the same template parameters
    and \grammarterm{requires-clause} (if any),
    respectively, as \tcode{P} or \tcode{A}.
    \item
    Each function template has a single function parameter
    whose type is a specialization of \tcode{X}
    with template arguments corresponding to the template parameters
    from the respective function template where,
    for each template parameter \tcode{PP}
    in the \grammarterm{template-head} of the function template,
    a corresponding template argument \tcode{AA} is formed.
    If \tcode{PP} declares a template parameter pack,
    then \tcode{AA} is the pack expansion \tcode{PP...} \iref{temp.variadic};
    otherwise, \tcode{AA} is the \grammarterm{id-expression} \tcode{PP}.
\end{itemize}
If the rewrite produces an invalid type,
then \tcode{P} is not at least as specialized as \tcode{A}.

\textcolor{noteclr}{[...]}

\rSec1[temp.type]{Type equivalence}

\textcolor{noteclr}{[...]}

\pnum
\indextext{equivalence!template type}%
Two \grammarterm{template-id}{s} are the same if
\begin{itemize}
    \item
    their \grammarterm{template-name}{s},
    \grammarterm{operator-function-id}{s}, or
    \grammarterm{literal-operator-id}{s}
    refer to the same template, and

    \item
    their corresponding type \grammarterm{template-argument}{s}
    are the same type, and

    \item
    the template parameter values determined by
    their corresponding \changed{non-type}{constant} template arguments\iref{temp.arg.nontype}
    are template-argument-equivalent (see below), and

    \item
    their corresponding template \grammarterm{template-argument}{s}
    refer to the same template.
\end{itemize}

Two \grammarterm{template-id}{s} that are the same
refer to the same class, function, \added{concept, }or variable.

\textcolor{noteclr}{[...]}


\rSec2[temp.constr.order]{Partial ordering by constraints}
\indextext{subsume|see{constraint, subsumption}}

\pnum
A constraint $P$ \defnx{subsumes}{constraint!subsumption} a constraint $Q$
if and only if,
for every disjunctive clause $P_i$
in the disjunctive normal form
\begin{wfootnote}
    A constraint is in disjunctive normal form when it is a disjunction of
    clauses where each clause is a conjunction of atomic constraints.
    For atomic constraints $A$, $B$, and $C$, the disjunctive normal form
    of the constraint
    $A \land (B \lor C)$
    is
    $(A \land B) \lor (A \land C)$.
    %
    Its disjunctive clauses are $(A \land B)$ and $(A \land C)$.
\end{wfootnote}
of $P$, $P_i$ subsumes every conjunctive clause $Q_j$
in the conjunctive normal form
\begin{wfootnote}
    A constraint is in conjunctive normal form when it is a conjunction
    of clauses where each clause is a disjunction of atomic constraints.
    For atomic constraints $A$, $B$, and $C$, the constraint
    $A \land (B \lor C)$ is in conjunctive normal form.
    %
    Its conjunctive clauses are $A$ and $(B \lor C)$.
\end{wfootnote}
of $Q$, where
\begin{itemize}
    \item
    a disjunctive clause $P_i$ subsumes a conjunctive clause $Q_j$ if and only
    if there exists an atomic constraint $P_{ia}$ in $P_i$ for which there exists
    an atomic constraint $Q_{jb}$ in $Q_j$ such that $P_{ia}$ subsumes $Q_{jb}$, and

    \item an atomic constraint $A$ subsumes another atomic constraint
    $B$ if and only if $A$ and $B$ are identical using the
    rules described in \ref{temp.constr.atomic}.


    %\ednote{Add wording for fold expressions}

\end{itemize}
%
\begin{example}
    Let $A$ and $B$ be atomic constraints \iref{temp.constr.atomic}.
    %
    The constraint $A \land B$ subsumes $A$, but $A$ does not subsume $A \land B$.
    %
    The constraint $A$ subsumes $A \lor B$, but $A \lor B$ does not subsume $A$.
    %
    Also note that every constraint subsumes itself.
\end{example}

\pnum
\begin{note}
The subsumption relation defines a partial ordering on constraints.
This partial ordering is used to determine
\begin{itemize}
    \item the best viable candidate of non-template functions \iref{over.match.best},
    \item the address of a non-template function \iref{over.over},
    \item the matching of template template arguments \iref{temp.arg.template},
    \item the partial ordering of class template specializations \iref{temp.spec.partial.order}, and
    \item the partial ordering of function templates \iref{temp.func.order}.
\end{itemize}
\end{note}

\begin{addedblock}

The associated constraints \tcode{C} of a declaration \tcode{D} are \emph{subsumption eligible}
unless \tcode{D} is a template declaration and \tcode{C} is dependent on a \grammarterm{concept-parameter} of \tcode{D}.

\end{addedblock}


\pnum
A declaration \tcode{D1} is
\defn{at least as constrained} as
a declaration \tcode{D2} if
\begin{itemize}
    \item \tcode{D1} and \tcode{D2} are both constrained declarations and
    \tcode{D1}'s associated constraints
    \added{are subsumption eligible and} subsume those of \tcode{D2}; or

    \item \tcode{D2} has no associated constraints.
\end{itemize}

\pnum
A declaration \tcode{D1} is \defn{more constrained}
than another declaration \tcode{D2} when \tcode{D1} is at least as
constrained as \tcode{D2}, and \tcode{D2} is not at least as
constrained as \tcode{D1}.
\begin{example}
\begin{codeblock}
    template<typename T> concept C1 = requires(T t) { --t; };
    template<typename T> concept C2 = C1<T> && requires(T t) { *t; };

    template<C1 T> void f(T);       // \#1
    template<C2 T> void f(T);       // \#2
    template<typename T> void g(T); // \#3
    template<C1 T> void g(T);       // \#4

    f(0);                           // selects \#1
    f((int*)0);                     // selects \#2
    g(true);                        // selects \#3 because \tcode{C1<bool>} is not satisfied
    g(0);                           // selects \#4
\end{codeblock}
\end{example}

\begin{addedblock}
\begin{example}
\begin{codeblock}
template <template <typename T> concept X, typename T>
struct S {};
template <typename T>
concept A = true;
template <typename T>
concept B = true && A<T>;
template <typename T>
concept C = true && B<T>;

template <template <typename T>  concept X, typename T>
int answer(S<X, T>) requires B<T> { return 42; } // \#1
template <template <typename T> concept X, typename T>
int answer(S<X, T>) requires X<T> { return 43; } // \#2

// error: the 3 following calls are ambiguous because \#1 and \#2 are not subsumption eligible
// (their associated constraints depend on a concept template parameter X)
answer(S<A, int>{});
answer(S<C, int>{});
answer(S<B, int>{});
\end{codeblock}
\end{example}
\end{addedblock}




\rSec2[temp.constr.normal]{Constraint normalization}
\indextext{constraint!normalization|(}%

\pnum
The \defnx{normal form}{normal form!constraint} of an \grammarterm{expression} \tcode{E} is
a constraint \iref{temp.constr.constr} that is defined as follows:
%
\begin{itemize}
\item
The normal form of an expression \tcode{( E )} is
the normal form of \tcode{E}.

\item
The normal form of an expression \tcode{E1 || E2} is
the disjunction \iref{temp.constr.op} of
the normal forms of \tcode{E1} and \tcode{E2}.

\item
The normal form of an expression \tcode{E1 \&\& E2}
is the conjunction of
the normal forms of \tcode{E1} and \tcode{E2}.

\item
The normal form of a concept-id \tcode{C<A$_1$, A$_2$, ..., A$_n$>}
is the normal form of the \grammarterm{constraint-expression} of \tcode{C},
after \removed{substituting \tcode{A$_1$, A$_2$, ..., A$_n$}}
\begin{itemize}
\begin{addedblock}
\item substituting each use of A$_i$'s corresponding template parameter in the \grammarterm{constraint-expression} of \tcode{C} if A$_i$ denotes a \grammarterm{concept-name}
\end{addedblock}
\item
\added{substituting each A$_i$ that is not a \grammarterm{concept-name}} for \tcode{C}{'s} respective template parameters in the
parameter mappings in each atomic constraint.
If any such substitution results in an invalid type or expression,
the program is ill-formed; no diagnostic is required.

\end{itemize}

\ednote{We need wording to substitute C when C names a concept template parameter}

\begin{example}
    \begin{codeblock}
        template<typename T> concept A = T::value || true;
        template<typename U> concept B = A<U*>;
        template<typename V> concept C = B<V&>;
    \end{codeblock}
    Normalization of \tcode{B}{'s} \grammarterm{constraint-expression}
    is valid and results in
    \tcode{T::value} (with the mapping $\tcode{T} \mapsto \tcode{U*}$)
    $\lor$
    \tcode{true} (with an empty mapping),
    despite the expression \tcode{T::value} being ill-formed
    for a pointer type \tcode{T}.
    Normalization of \tcode{C}{'s} \grammarterm{constraint-expression}
    results in the program being ill-formed,
    because it would form the invalid type \tcode{V\&*}
    in the parameter mapping.
\end{example}

\ednote{The wording in blue is added by P2963}
\begin{addedblockTwo}
\item For a \grammarterm{fold-operator}  [expr.prim.fold] that is either \tcode{\&\&} or \tcode{||}
\end{addedblockTwo}
\begin{itemize}
\begin{addedblockTwo}
\item The normal form of an expression \tcode{( ... \grammarterm{fold-operator} E )} is the normal form of \tcode{( E \grammarterm{fold-operator}...)}.
\item The normal form of an expression \tcode{( E1 \grammarterm{fold-operator}  ... \grammarterm{fold-operator}  E2 )} is the the normal form of
\begin{itemize}
    \item \tcode{(E1 \grammarterm{fold-operator}...) \grammarterm{fold-operator}  E2} if \tcode{E1} contains an unexpanded pack, or
    \item \tcode{E1 \grammarterm{fold-operator} (E2 \grammarterm{fold-operator}...)} otherwise.
\end{itemize}
\end{addedblockTwo}
\ednote{The wording in pink is added by P2963 and removed by this paper}
\begin{removedblockTwo}
\item The normal form of \tcode{(E \&\& ...)} is a fold expanded conjunction constraint \mbox{[temp.constr.fold]} whose constraint is the normal form of \tcode{E}.
\item The normal form of \tcode{(E || ...)} is a fold expanded disjunction constraint whose constraint is the normal form of \tcode{E}.
\end{removedblockTwo}

\ednote{Add the following two bullets}
\begin{addedblock}
\item If \tcode{E} contains an unexpanded pack \tcode{P} naming a concept-name, the normal form of \tcode{(E \grammarterm{fold-operator} ...)}
is the normal form of \tcode{(} \tcode{((}$\mathtt{E'}_0$ \placeholder{op} $\mathtt{E'}_1$\tcode{)} \placeholder{op} $\cdots$\tcode{)} \placeholder{op} $\mathtt{E'}_{N-1}$ \tcode{)} where $\mathtt{E'}_i$ is formed by substituting the $ith$ element of the corresponding template parameter of \tcode{P} in \tcode{E}.
\item Otherwise, the normal form of \tcode{(E \&\& ...)} is a fold expanded conjunction constraint \mbox{[temp.constr.fold]} whose constraint is the normal form of \tcode{E}
      and the normal form of \tcode{(E || ...)} is a fold expanded disjunction constraint whose constraint is the normal form of \tcode{E}.

\end{addedblock}
\end{itemize}
%\begin{removedblockTwo}
%\item For a \grammarterm{fold-operator} [expr.prim.fold] that is either \tcode{\&\&} or \tcode{||},
%
%
%
%, the normal form of an expression \tcode{( ... \grammarterm{fold-operator} E )} is the normal form of \tcode{( E \grammarterm{fold-operator}...)}.
%\item The normal form of an expression \tcode{( E1 \grammarterm{fold-operator}  ... \grammarterm{fold-operator}  E2 )} is the the normal form of
%\begin{itemize}
%    \item \tcode{(E1 \grammarterm{fold-operator}...) \grammarterm{fold-operator}  E2} if \tcode{E1} contains an unexpanded pack, or
%    \item \tcode{E1 \grammarterm{fold-operator} (E2 \grammarterm{fold-operator}...)} otherwise.
%\end{itemize}
%\item The normal form of \tcode{(E \&\& ...)} is a fold expanded conjunction constraint \mbox{[temp.constr.fold]} whose constraint is the normal form of \tcode{E}.
%\item The normal form of \tcode{(E || ...)} is a fold expanded disjunction constraint whose constraint is the normal form of \tcode{E}.
%\end{removedblockTwo}
%
%
%\item The normal form of a \grammarterm{fold-expression} \iref{expr.prim.fold} \tcode{F}
%whose \grammarterm{fold-operator} \tcode{op} is either \tcode{\&\&} or \tcode{||}
%and whose pattern is a \tcode{concept-name} \tcode{C} is the normal form of the expanded expression F'
%produced by the expansion of \tcode{C}:
%
%\pnum
%\begin{itemize}
%    \item
%    % Note: "\space" used below because " " inside tcode adds too much whitespace;
%    % one could optionally use mathfont inside tcode, e.g., "\tcode{($ $}".
%    \tcode{(}\space
%    \tcode{((}$\mathtt{E}_1$
%    \placeholder{op} $\mathtt{E}_2$\tcode{)}
%    \placeholder{op} $\cdots$\tcode{)}
%    \placeholder{op} $\mathtt{E}_N$
%    \space\tcode{)}
%    for a unary left fold,
%    \item
%    \tcode{(}\space
%    $\mathtt{E}_1$     \placeholder{op}
%    \tcode{(}$\cdots$           \placeholder{op}
%    \tcode{(}$\mathtt{E}_{N-1}$ \placeholder{op}
%    $\mathtt{E}_N$\tcode{))}
%    \space\tcode{)}
%    for a unary right fold,
%    \item
%    \tcode{(}\space
%    \tcode{(((}$\mathtt{E}$
%    \placeholder{op} $\mathtt{E}_1$\tcode{)}
%    \placeholder{op} $\mathtt{E}_2$\tcode{)}
%    \placeholder{op} $\cdots$\tcode{)}
%    \placeholder{op} $\mathtt{E}_N$
%    \space\tcode{)}
%    for a binary left fold, and
%    \item
%    \tcode{(}\space
%    $\mathtt{E}_1$     \placeholder{op}
%    \tcode{(}$\cdots$           \placeholder{op}
%    \tcode{(}$\mathtt{E}_{N-1}$ \placeholder{op}
%    \tcode{(}$\mathtt{E}_{N}$   \placeholder{op}
%    $\mathtt{E}$\tcode{)))}
%    \space\tcode{)}
%    for a binary right fold.
%\end{itemize}
%\end{addedblock}


\item
The normal form of any other expression \tcode{E} is
the atomic constraint
whose expression is \tcode{E} and
whose parameter mapping is the identity mapping.
\end{itemize}

\pnum
The process of obtaining the normal form of a
\grammarterm{constraint-expression}
is called
\defnx{normalization}{normalization!constraint|see{constraint, normalization}}.
\begin{note}
    Normalization of \grammarterm{constraint-expression}{s}
    is performed
    when determining the associated constraints \iref{temp.constr.constr}
    of a declaration
    and
    when evaluating the value of an \grammarterm{id-expression}
    that names a concept specialization \iref{expr.prim.id}.
\end{note}

\pnum
\begin{example}
    \begin{codeblock}
        template<typename T> concept C1 = sizeof(T) == 1;
        template<typename T> concept C2 = C1<T> && 1 == 2;
        template<typename T> concept C3 = requires { typename T::type; };
        template<typename T> concept C4 = requires (T x) { ++x; };

        template<C2 U> void f1(U);      // \#1
        template<C3 U> void f2(U);      // \#2
        template<C4 U> void f3(U);      // \#3
    \end{codeblock}
    The associated constraints of \#1 are
    \tcode{sizeof(T) == 1} (with mapping $\tcode{T} \mapsto \tcode{U}$) $\land$ \tcode{1 == 2}.\\
    The associated constraints of \#2 are
    \tcode{requires \{ typename T::type; \}} (with mapping $\tcode{T} \mapsto \tcode{U}$).\\
    The associated constraints of \#3 are
    \tcode{requires (T x) \{ ++x; \}} (with mapping $\tcode{T} \mapsto \tcode{U}$).
\end{example}
\indextext{constraint!normalization|)}


\rSec2[temp.variadic]{Variadic templates}

\pnum
A \defn{template parameter pack} is a template parameter
that accepts zero or more template arguments.
\begin{example}
    \begin{codeblock}
        template<class ... Types> struct Tuple { };

        Tuple<> t0;                     // \tcode{Types} contains no arguments
        Tuple<int> t1;                  // \tcode{Types} contains one argument: \tcode{int}
        Tuple<int, float> t2;           // \tcode{Types} contains two arguments: \tcode{int} and \tcode{float}
        Tuple<0> error;                 // error: \tcode{0} is not a type
    \end{codeblock}
\end{example}

\pnum
A \defn{function parameter pack} is a function parameter
that accepts zero or more function arguments.
\begin{example}
    \begin{codeblock}
        template<class ... Types> void f(Types ... args);

        f();                            // \tcode{args} contains no arguments
        f(1);                           // \tcode{args} contains one argument: \tcode{int}
        f(2, 1.0);                      // \tcode{args} contains two arguments: \tcode{int} and \tcode{double}
    \end{codeblock}
\end{example}

\pnum
An \defnx{\grammarterm{init-capture} pack}{init-capture pack@\fakegrammarterm{init-capture} pack}
is a lambda capture that introduces an \grammarterm{init-capture}
for each of the elements in the pack expansion of its \grammarterm{initializer}.
\begin{example}
    \begin{codeblock}
        template <typename... Args>
        void foo(Args... args) {
            [...xs=args]{
                bar(xs...);             // \tcode{xs} is an \grammarterm{init-capture} pack
            };
        }

        foo();                          // \tcode{xs} contains zero \grammarterm{init-capture}s
        foo(1);                         // \tcode{xs} contains one \grammarterm{init-capture}
    \end{codeblock}
\end{example}

\pnum
A \defn{pack} is
a template parameter pack,
a function parameter pack,
or an \grammarterm{init-capture} pack.
The number of elements of a template parameter pack
or a function parameter pack
is the number of arguments provided for the parameter pack.
The number of elements of an \grammarterm{init-capture} pack
is the number of elements in the pack expansion of its \grammarterm{initializer}.

\pnum
\indextext{pattern|see{pack expansion, pattern}}%
A \defn{pack expansion}
consists of a \defnx{pattern}{pack expansion!pattern} and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:

\begin{itemize}
\item In a function parameter pack \iref{dcl.fct}; the pattern is the
\grammarterm{parameter-declaration} without the ellipsis.

\item In a \grammarterm{using-declaration} \iref{namespace.udecl};
the pattern is a \grammarterm{using-declarator}.

\item In a template parameter pack that is a pack expansion \iref{}:
\begin{itemize}
    \item
    if the template parameter pack is a \grammarterm{parameter-declaration};
    the pattern is the \grammarterm{parameter-declaration} without the ellipsis;

    \item
    if the template parameter pack is a \grammarterm{type-parameter};
    the pattern is the corresponding \grammarterm{type-parameter}
    without the ellipsis. % lah: set the period as replaced by a semicomma

    \begin{addedblock}
    \item
    if the template parameter pack is a template template parameter;
    the pattern is the corresponding template template parameter
    without the ellipsis.
    \end{addedblock}
\end{itemize}

\item \textcolor{noteclr}{[...]}
\end{itemize}

\textcolor{noteclr}{[...]}

\pnum
The instantiation of a pack expansion considers
items $\tcode{E}_1, \tcode{E}_2, \dotsc, \tcode{E}_N$,
where
$N$ is the number of elements in the pack expansion parameters.
Each $\tcode{E}_i$ is generated by instantiating the pattern and
replacing each pack expansion parameter with its $i^\text{th}$ element.
Such an element, in the context of the instantiation, is interpreted as
follows:
\begin{itemize}
    \item
    if the pack is a template parameter pack, the element is
    an \grammarterm{id-expression}
    (for a \changed{non-type}{constant} template parameter pack),
    a \grammarterm{typedef-name}
    (for a type template parameter pack \removed{declared without \tcode{template}}), or
    a \grammarterm{template-name}
    (for a \changed{type}{template} template parameter pack \removed{declared with \tcode{template}}),
    designating the $i^\text{th}$ corresponding type or value template argument;

\item \textcolor{noteclr}{[...]}
\end{itemize}

\textcolor{noteclr}{[...]}

\rSec2[temp.spec.partial]{Partial specialization}

\rSec3[temp.spec.partial.general]{General}

\textcolor{noteclr}{[...]}

\pnum
A \changed{non-type}{constant} argument is non-specialized if it is the name of a non-type
parameter.
All other \changed{non-type}{constant} arguments are specialized.

\pnum
Within the argument list of a partial specialization,
the following restrictions apply:

\begin{itemize}
    \item
    The type of a template parameter corresponding to a specialized \changed{non-type}{constant} argument
    shall not be dependent on a parameter of the partial specialization.
\end{itemize}

\textcolor{noteclr}{[...]}

\rSec3[temp.over.link]{Function template overloading}
\textcolor{noteclr}{[...]}

\pnum
When an expression that references a template parameter is used in the
function parameter list or the return type in the declaration of a
function template, the expression that references the template
parameter is part of the signature of the function template.
This is
necessary to permit a declaration of a function template in one
translation unit to be linked with another declaration of the function
template in another translation unit and, conversely, to ensure that
function templates that are intended to be distinct are not linked
with one another.
\begin{example}
    \begin{codeblock}
        template <int I, int J> A<I+J> f(A<I>, A<J>);   // \#1
        template <int K, int L> A<K+L> f(A<K>, A<L>);   // same as \#1
        template <int I, int J> A<I-J> f(A<I>, A<J>);   // different from \#1
    \end{codeblock}
\end{example}
\begin{note}
    Most expressions that use template parameters use \changed{non-type}{constant} template
    parameters, but it is possible for an expression to reference a type
    parameter.
    For example, a template type parameter can be used in the
    \tcode{sizeof} operator.
\end{note}

\textcolor{noteclr}{[...]}

\pnum
Two \grammarterm{template-head}{s} are
\defnx{equivalent}{equivalent!\idxgram{template-head}{s}} if
their \grammarterm{template-parameter-list}{s} have the same length,
corresponding \grammarterm{template-parameter}{s} are equivalent
and are both declared with \grammarterm{type-constraint}s that are equivalent
if either \grammarterm{template-parameter}
is declared with a \grammarterm{type-constraint},
and if either \grammarterm{template-head} has a \grammarterm{requires-clause},
they both have
\grammarterm{requires-clause}{s} and the corresponding
\grammarterm{constraint-expression}{s} are equivalent.
Two \grammarterm{template-parameter}{s} are
\defnx{equivalent}{equivalent!\idxgram{template-parameter}{s}}
under the following conditions:
\begin{itemize}
    \item they declare template parameters of the same kind,
    \item if either declares a template parameter pack, they both do,
    \item if they declare \changed{non-type}{constant} template parameters,
    they have equivalent types
    ignoring the use of \grammarterm{type-constraint}{s} for placeholder types, and
    \item if they declare template template parameters, their template
    parameters are equivalent.
\end{itemize}

\textcolor{noteclr}{[...]}
\rSec3[temp.func.order]{Partial ordering of function templates}

\pnum
\indextext{overloading!resolution!template}%
\indextext{ordering!function template partial|see{template, function, partial ordering}}%
If multiple function templates share a name,
the use of that name can be ambiguous because
template argument deduction \iref{temp.deduct} may identify
a specialization for more than one function template.
\defnx{Partial ordering}{template!function!partial ordering}
of overloaded function template declarations is used in the following contexts
to select the function template to which a function template specialization
refers:
\begin{itemize}
    \item
    during overload resolution for a call to a function template specialization \iref{over.match.best};
    \item
    when the address of a function template specialization is taken;
    \item
    when a placement operator delete that is a
    function template
    specialization
    is selected to match a placement operator new
    \iref{basic.stc.dynamic.deallocation,expr.new};
    \item
    when a friend function declaration \iref{temp.friend}, an
    explicit instantiation \iref{temp.explicit} or an explicit specialization \iref{temp.expl.spec} refers to
    a function template specialization.
\end{itemize}

\pnum
Partial ordering selects which of two function templates is more
specialized than the other by transforming each template in turn
(see next paragraph) and performing template argument deduction
using the function type.
The deduction process determines whether
one of the templates is more specialized than the other. If so, the
more specialized template is the one chosen by the partial ordering
process.
If both deductions succeed, the partial ordering selects
the more constrained template (if one exists) as determined below.

\pnum
To produce the transformed template, for each type, \changed{non-type}{constant}, or template
template parameter (including template parameter packs \iref{temp.variadic}
thereof) synthesize a unique type, value, or class template
respectively and substitute it for each occurrence of that parameter
in the function type of the template.


\ednote{Do we need to change anything here?} % lah: it doesn't seem you want this to be in your final paper.

\begin{note}
    The type replacing the placeholder
    in the type of the value synthesized for a \changed{non-type}{constant} template parameter
    is also a unique synthesized type.
\end{note}
Each function template $M$ that is a member function
is considered to have
a new first parameter of type $X(M)$, described below,
inserted in its function parameter list.
If exactly one of the function templates was considered by overload resolution
via a rewritten candidate \iref{over.match.oper}
with a reversed order of parameters,
then the order of the function parameters in its transformed template
is reversed.
For a function template $M$ with cv-qualifiers \cv{}
that is a member of a class $A$:

\textcolor{noteclr}{[...]}

\rSec2[temp.res.general]{General}


\indextext{type-only!context|see{context, type-only}}%
A qualified or unqualified name is said to be in
a \defnx{type-only context}{context!type-only}
if it is the terminal name of
\begin{itemize}
\item \textcolor{noteclr}{[...]}
\item a \grammarterm{decl-specifier} of the \grammarterm{decl-specifier-seq} of a
\begin{itemize}
    \item \textcolor{noteclr}{[...]}
    \item \grammarterm{parameter-declaration} in a \grammarterm{lambda-declarator}
    or \grammarterm{requirement-parameter-list},
    unless that \grammarterm{parameter-declaration} appears in a default argument, or
    \item \grammarterm{parameter-declaration} of a (\changed{non-type}{constant}) \grammarterm{template-parameter}.
\end{itemize}
\end{itemize}

\rSec2[temp.local]{Locally declared names}

\pnum
Like normal (non-template) classes, class templates have an
injected-class-name\iref{class.pre}.
The
injected-class-name can be used
as a \grammarterm{template-name} or a \grammarterm{type-name}.
When it is used with a
\grammarterm{template-argument-list},
as a \grammarterm{template-argument} for a template \changed{\grammarterm{template-parameter}}{\grammarterm{type-template-parameter}}),
or as the final identifier in the \grammarterm{elaborated-type-specifier} of
a friend class template declaration,
it is a \grammarterm{template-name} that refers to the
class template itself.
Otherwise, it is a \grammarterm{type-name}
equivalent to the \grammarterm{template-name}
followed by
the template argument list\iref{temp.decls.general,temp.arg.general}
of the class template
enclosed in \tcode{<>}.

\pnum
When the injected-class-name of a class template specialization or
partial specialization is used as a \grammarterm{type-name},
it is equivalent to the \grammarterm{template-name} followed by the
\grammarterm{template-argument}{s}
of the class template specialization or partial
specialization enclosed in
\tcode{<>}.

\textcolor{noteclr}{[...]}

\rSec3[temp.dep.type]{Dependent types}

\textcolor{noteclr}{[...]}

\pnum
A template argument that is equivalent to a template
parameter can be used in place of that
template parameter in a reference to the current instantiation.
For a template \grammarterm{type-parameter},
a template argument is equivalent to a template parameter
if it denotes the same type.
For a \changed{non-type}{constant} template parameter,
a template argument is equivalent to a template parameter
if it is an \grammarterm{identifier} that names a variable
that is equivalent to the template parameter.

\textcolor{noteclr}{[...]}

\pnum
A type is dependent if it is
\begin{itemize}
\item
a template parameter,
\item
denoted by a dependent (qualified) name,
\item
a nested class or enumeration that is a direct member of
a class that is the current instantiation,
\item
a cv-qualified type where the cv-unqualified type is dependent,
\item
a compound type constructed from any dependent type,
\item
an array type whose element type is dependent or whose
bound (if any) is value-dependent,
\item
a function type whose parameters include one or more function parameter packs,
\item
a function type whose exception specification is value-dependent,
\item
denoted by a dependent placeholder type,
\item
denoted by a dependent placeholder for a deduced class type,
\item
denoted by a \grammarterm{simple-template-id}
in which either the template name is a template parameter or any of the
template arguments \added{names a template template parameter or }is a dependent type or an expression that is type-dependent
or value-dependent or is a pack expansion,
\begin{wfootnote}
    This includes an injected-class-name\iref{class.pre} of a class template
    used without a \grammarterm{template-argument-list}.
\end{wfootnote}
\item a \grammarterm{pack-index-specifier}, or
\item denoted by \tcode{decltype(}\grammarterm{expression}{}\tcode{)},
where \grammarterm{expression} is type-dependent\iref{temp.dep.expr}.
\end{itemize}

\pnum
\begin{note}
    Because typedefs do not introduce new types, but
    instead simply refer to other types, a name that refers to a
    typedef that is a member of the current instantiation is dependent
    only if the type referred to is dependent.
\end{note}

\rSec3[temp.dep.expr]{Type-dependent expressions}

\pnum
Except as described below, an expression is type-dependent if any
subexpression is type-dependent.

\pnum
\keyword{this}
is type-dependent if the current class\iref{expr.prim.this} is
dependent\iref{temp.dep.type}.

\pnum
An \grammarterm{id-expression} is type-dependent
if it is a \grammarterm{template-id} that is not a concept-id and is dependent;
or if its terminal name is
\begin{itemize}
\item
associated by name lookup with one or more declarations
declared with a dependent type,
\item
associated by name lookup with
a \changed{non-type}{constant} \grammarterm{template-parameter}
declared with a type
that contains a placeholder type\iref{dcl.spec.auto},
\item
associated by name lookup with
a variable declared with a type that contains a placeholder type\iref{dcl.spec.auto}
where the initializer is type-dependent,
\item \textcolor{noteclr}{[...]}
\end{itemize}

\textcolor{noteclr}{[...]}

\rSec3[temp.dep.constexpr]{Value-dependent expressions}

\pnum
Except as described below, an expression used in a context where a
constant expression is required is value-dependent if any
subexpression is value-dependent.

\pnum
An
\grammarterm{id-expression}
is value-dependent if:
\begin{itemize}
    \item
    it is a concept-id and any of its arguments are dependent,
    \item
    it is type-dependent,
    \item
    it is the name of a \changed{non-type}{constant} template parameter,
    \item
    it names a static data member that is a dependent member of the current
    instantiation and is not initialized in a \grammarterm{member-declarator},
    \item
    it names a static member function that is a dependent member of the current
    instantiation, or
    \item
    it names a potentially-constant variable \iref{expr.const}
    that is initialized with an expression that is value-dependent.
\end{itemize}

\textcolor{noteclr}{[...]}

\rSec3[temp.dep.temp]{Dependent template arguments}

\pnum
A type
\grammarterm{template-argument}
is dependent if the type it specifies is dependent.

\pnum
A \changed{non-type}{constant}
\grammarterm{template-argument}
is dependent if its type is dependent or the constant
expression it specifies is value-dependent.

\pnum
Furthermore, a \changed{non-type}{constant}
\grammarterm{template-argument}
is dependent if the corresponding \changed{non-type}{constant} \grammarterm{template-parameter}
is of reference or pointer type and the \grammarterm{template-argument}
designates or points to a member of the current instantiation or a member of
a dependent type.

\pnum
A template \grammarterm{template-parameter} is dependent if
it names a \grammarterm{template-parameter} or
its terminal name is dependent.

\textcolor{noteclr}{[...]}

\rSec2[temp.deduct]{Template argument deduction}

\rSec3[temp.deduct.general]{General}
\textcolor{noteclr}{[...]}

\begin{note}
Type deduction can fail for the following reasons:
\begin{itemize}
\item Attempting to instantiate a pack expansion containing multiple packs of differing lengths.
\item
Attempting to create an array with an element type that is \keyword{void}, a
function type, or a reference type, or attempting
to create an array with a size that is zero or negative.
\begin{example}
\begin{codeblock}
    template <class T> int f(T[5]);
    int I = f<int>(0);
    int j = f<void>(0);             // invalid array
\end{codeblock}
\end{example}
\item
Attempting to use a type that is not a class or enumeration type in a qualified name.
\begin{example}
\begin{codeblock}
    template <class T> int f(typename T::B*);
    int i = f<int>(0);
\end{codeblock}
\end{example}
\item
Attempting to use a type in a \grammarterm{nested-name-specifier} of a
\grammarterm{qualified-id} when
that type does not contain the specified member, or
\begin{itemize}
\item
the specified member is not a type where a type is required, or
\item
the specified member is not a template where a template is required, or
\item
the specified member is not a \changed{non-type}{constant} where a \changed{non-type}{constant} is required.
\end{itemize}
\begin{example}
\begin{codeblock}
    template <int I> struct X { };
    template <template <class T> class> struct Z { };
    template <class T> void f(typename T::Y*) {}
    template <class T> void g(X<T::N>*) {}
    template <class T> void h(Z<T::TT>*) {}
    struct A {};
    struct B { int Y; };
    struct C {
        typedef int N;
    };
    struct D {
        typedef int TT;
    };

    int main() {
        // Deduction fails in each of these cases:
        f<A>(0);          // \tcode{A} does not contain a member \tcode{Y}
        f<B>(0);          // The \tcode{Y} member of \tcode{B} is not a type
        g<C>(0);          // The \tcode{N} member of \tcode{C} is not a \changed{non-type}{constant}
        h<D>(0);          // The \tcode{TT} member of \tcode{D} is not a template
    }
\end{codeblock}
\end{example}
\item
Attempting to create a pointer to reference type.
\item
Attempting to create a reference to \keyword{void}.
\item
Attempting to create ``pointer to member of \tcode{T}'' when \tcode{T} is not a
class type.
\begin{example}
    \begin{codeblock}
        template <class T> int f(int T::*);
        int i = f<int>(0);
    \end{codeblock}
\end{example}
\item
Attempting to give an invalid type to a \changed{non-type}{constant} template parameter.
\begin{example}
    \begin{codeblock}
        template <class T, T> struct S {};
        template <class T> int f(S<T, T{}>*);   // \#1
        class X {
            int m;
        };
        int i0 = f<X>(0);   // \#1 uses a value of non-structural type \tcode{X} as a \changed{non-type}{constant} template argument
    \end{codeblock}
\end{example}
\end{itemize}
\end{note}

\textcolor{noteclr}{[...]}

\rSec3[temp.deduct.call]{Deducing template arguments from a function call}

\pnum
Template argument deduction is done by comparing each function
template parameter type (call it
\tcode{P})
that contains \grammarterm{template-parameter}{s} that participate in template argument deduction
with the type of the corresponding argument of the call (call it
\tcode{A})
as described below.
If removing references and cv-qualifiers from \tcode{P} gives
\tcode{std::initializer_list<P$^{\prime}$>}
or $\tcode{P}'\tcode{[N]}$
for some $\tcode{P}'$ and \tcode{N} and the
argument is a non-empty initializer list \iref{dcl.init.list}, then deduction is
performed instead for each element of the initializer list independently,
taking $\tcode{P}'$
as separate function template parameter types $\tcode{P}'_i$
and the $i^\text{th}$ initializer element as the corresponding argument.
In the $\tcode{P}'\tcode{[N]}$ case, if \tcode{N} is a \changed{non-type}{constant} template parameter,
\tcode{N} is deduced from the length of the initializer list.
Otherwise, an initializer list argument causes the
parameter to be considered a non-deduced context \iref{temp.deduct.type}.

\textcolor{noteclr}{[...]}

\rSec3[temp.deduct.type]{Deducing template arguments from a type}

\pnum
Template arguments can be deduced in several different contexts, but
in each case a type that is specified in terms of template parameters
(call it
\tcode{P})
is compared with an actual type (call it
\tcode{A}),
and an attempt is made to find template argument values (a type for a type
parameter, a value for a \changed{non-type}{constant template} parameter, or a template for a
template parameter) that will make
\tcode{P},
after substitution of the deduced values (call it the deduced
\tcode{A}),
compatible with
\tcode{A}.

\pnum
In some cases, the deduction is done using a single set of types
\tcode{P}
and
\tcode{A},
in other cases, there will be a set of corresponding types
\tcode{P}
and
\tcode{A}.
Type deduction is done
independently for each
\tcode{P/A}
pair, and the deduced template
argument values are then combined.
If type deduction cannot be done
for any
\tcode{P/A}
pair, or if for any pair the deduction leads to more than
one possible set of deduced values, or if different pairs yield
different deduced values, or if any template argument remains neither
deduced nor explicitly specified, template argument deduction fails.
The type of a type parameter
is only deduced from an array bound
if it is not otherwise deduced.

\pnum
A given type
\tcode{P}
can be composed from a number of other
types, templates, and \changed{non-type}{constant template argument} values:

\begin{itemize}
    \item
    A function type includes the types of each of the function parameters,
    the return type, and its exception specification.
    \item
    A pointer-to-member type includes the type of the class object pointed to
    and the type of the member pointed to.
    \item
    A type that is a specialization of a class template (e.g.,
    \tcode{A<int>})
    includes the types, templates, and \changed{non-type}{constant template argument} values referenced by the
    template argument list of the specialization.
    \item
    An array type includes the array element type and the value of the
    array bound.
\end{itemize}

\pnum
In most cases, the types, templates, and \changed{non-type}{constant template argument} values that are used
to compose
\tcode{P}
participate in template argument deduction.
That is,
they may be used to determine the value of a template argument, and
template argument deduction fails if
the value so determined is not consistent with the values determined
elsewhere.
In certain contexts, however, the value does not
participate in type deduction, but instead uses the values of template
arguments that were either deduced elsewhere or explicitly specified.
If a template parameter is used only in non-deduced contexts and is not
explicitly specified, template argument deduction fails.
\begin{note}
    Under \ref{temp.deduct.call},
    if \tcode{P} contains no \grammarterm{template-parameter}{s} that appear
    in deduced contexts, no deduction is done, so \tcode{P} and \tcode{A}
    need not have the same form.
\end{note}

\pnum
The non-deduced contexts are:

\indextext{context!non-deduced}%
\begin{itemize}
    \item
    The
    \grammarterm{nested-name-specifier}
    of a type that was specified using a
    \grammarterm{qualified-id}.
    \item
    A \grammarterm{pack-index-specifier} or a \grammarterm{pack-index-expression}.
    \item
    The \grammarterm{expression} of a \grammarterm{decltype-specifier}.
    \item
    A \changed{non-type}{constant} template argument or an array bound in which a subexpression
    references a template parameter.
    \item
    A template parameter used in the parameter type of a function parameter that
    has a default argument that is being used in the call for which argument
    deduction is being done.
    \item
    A function parameter for which the associated argument is an
    overload set\iref{over.over}, and one or more of the following apply:
    \begin{itemize}
        \item
        more than one function matches the function parameter type (resulting in
        an ambiguous deduction), or
        \item
        no function matches the function parameter type, or
        \item
        the overload set supplied as an argument contains one or more function templates.
    \end{itemize}
    \item A function parameter for which the associated argument is an initializer
    list\iref{dcl.init.list} but the parameter does not have
    a type for which deduction from an initializer list is specified\iref{temp.deduct.call}.
    \begin{example}
        \begin{codeblock}
            template<class T> void g(T);
            g({1,2,3});                 // error: no argument deduced for \tcode{T}
        \end{codeblock}
    \end{example}
    \item A function parameter pack that does not occur at the end of the
    \grammarterm{parameter-declaration-list}.
\end{itemize}

\ednote{Modify [temp.deduct.type]/p8 As follow}

\pnum
A template type argument
\tcode{T},
a template template argument \added{denoting a class template or an alias template}
\tcode{TT},
\added{a template template argument denoting a variable template or a concept \tcode{VV},}
or a template \changed{non-type}{constant} argument
\tcode{i}
can be deduced if
\tcode{P}
and
\tcode{A}
have one of the following forms:
\begin{codeblock}
    @\opt{\cv{}}@ T
    T*
    T&
    T&&
    @\opt{T}@[@\opt{i}@]
    @\opt{T}@(@\opt{T}@) noexcept(@\opt{i}@)
    @\opt{T}@ @\opt{T}@::*
    @\opt{TT}@<T>
    @\opt{TT}@<i>
    @\opt{TT}@<TT>
    @\opt{TT}@<>
    @\added{\opt{TT}<VV>}@
\end{codeblock}

\textcolor{noteclr}{[...]}

\pnum
Template arguments cannot be deduced from function arguments involving
constructs other than the ones specified above.

\pnum
When the value of the argument
corresponding to a \changed{non-type}{constant} template parameter \tcode{P}
that is declared with a dependent type
is deduced from an expression,
the template parameters in the type of \tcode{P}
are deduced from the type of the value.


\pnum
\begin{note}
Except for reference and pointer types, a major array bound is not part of a
function parameter type and cannot be deduced from an argument:
\begin{codeblock}
    template<int i> void f1(int a[10][i]);
    template<int i> void f2(int a[i][20]);
    template<int i> void f3(int (&a)[i][20]);

    void g() {
        int v[10][20];
        f1(v);                        // OK, \tcode{i} deduced as \tcode{20}
        f1<20>(v);                    // OK
        f2(v);                        // error: cannot deduce template-argument \tcode{i}
        f2<10>(v);                    // OK
        f3(v);                        // OK, \tcode{i} deduced as \tcode{10}
    }
\end{codeblock}
\end{note}

\textcolor{noteclr}{[...]}

\pnum
\begin{note}
If, in the declaration of a function template with a \changed{non-type}{constant}
template parameter, the \changed{non-type}{constant} template parameter
is used in a subexpression in the function parameter list,
the expression is a non-deduced context as specified above.
\begin{example}
    \begin{codeblock}
        template <int i> class A { };
        template <int i> void g(A<i+1>);
        template <int i> void f(A<i>, A<i+1>);
        void k() {
            A<1> a1;
            A<2> a2;
            g(a1);                        // error: deduction fails for expression \tcode{i+1}
            g<0>(a1);                     // OK
            f(a1, a2);                    // OK
        }
    \end{codeblock}
\end{example}
\end{note}


\ednote{Adjust the library wording as follow}

\rSec2[intseq.make]{Alias template \tcode{make_integer_sequence}}

\indexlibraryglobal{make_integer_sequence}%
\begin{itemdecl}
    template<class T, T N>
    using make_integer_sequence = integer_sequence<T, @\seebelow{}@>;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    $\tcode{N} \geq 0$.

    \pnum
    The alias template
    \tcode{make_integer_sequence} denotes a specialization of
    \tcode{integer_sequence} with \tcode{N} \changed{non-type}{constant} template arguments.
    The type \tcode{make_integer_sequence<T, N>} is an alias for the type
    \tcode{integer_sequence<T, 0, 1, ..., N-1>}.
    \begin{note}
        \tcode{make_integer_sequence<int, 0>} is an alias for the type
        \tcode{integer_sequence<int>}.
    \end{note}
\end{itemdescr}

\rSec2[rand.eng]{Random number engine class templates}%

\rSec3[rand.eng.general]{General}%

\pnum
Descriptions are provided in \ref{rand.eng}
only for engine operations
that are not described in \ref{rand.req.eng}
or for operations where there is additional semantic information.
In particular,
declarations for copy constructors,
for copy assignment operators,
for streaming operators,
and for equality and inequality operators
are not shown in the synopses.

\pnum
Each template specified in \ref{rand.eng}
requires one or more relationships,
involving the value(s) of its \changed{non-type}{constant} template parameter(s), to hold.
A program instantiating any of these templates
is ill-formed
if any such required relationship fails to hold.

\rSec2[rand.adapt]{Random number engine adaptor class templates}

\rSec3[rand.adapt.general]{In general}

\pnum
Each template specified in this subclause~\ref{rand.adapt}
requires one or more relationships,
involving the value(s) of its \changed{non-type}{constant} template parameter(s), to hold.
A program instantiating any of these templates
is ill-formed
if any such required relationship fails to hold.


\ednote{Finally, get rid of "non-type" in the compatibility annex}

\rSec2[diff.cpp14.temp]{templates}

\change
Allowance to deduce from the type of a \changed{non-type}{constant} template argument.
\rationale
In combination with the ability to declare
\changed{non-type}{constant} template arguments with placeholder types,
allows partial specializations to decompose
from the type deduced for the \changed{non-type}{constant} template argument.
\effect
Valid \CppXIV{} code may fail to compile
or produce different results in this revision of \Cpp{}.
For example:
\begin{codeblock}
    template <int N> struct A;
    template <typename T, T N> int foo(A<N> *) = delete;
    void foo(void *);
    void bar(A<0> *p) {
        foo(p);           // ill-formed; previously well-formed
    }
\end{codeblock}


\section{Acknowledgments}
Many people contributed valuable discussions and feedbacks to this paper, notably
Brian Bi, Nina Dinka Ranns, Alisdair Meredith, Joshua Berne, Pablo Halpern, Lewis Baker, Bengt Gustafsson,
Hannеs Hauswedell and Barry Revzin.

We would like to thanks Daveed Vandevoorde for convince us to find a design that does not affect partial ordering.

We also want to thank Lori Hughes for helping editing this paper and Bloomberg for sponsoring this work.


\bibliographystyle{plain}
\bibliography{wg21}


\renewcommand{\section}[2]{}%

\begin{thebibliography}{9}


\end{thebibliography}
\end{document}
