% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{Pack Indexing}
\docnumber{D2662R2}
\audience{EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Pablo Halpern}{phalpern@halpernwightsoftware.com}

\usepackage{color, colortbl}
\begin{document}
\maketitle

\section{Abstract}

This paper expands on the pack indexing feature described in \paper{P1858R2} and provides wording.

\section{Revisions}

\subsection{R2}

\begin{itemize}
	\item Wording improvements
\end{itemize}

\subsection{R1}

\begin{itemize}
\item At EWG's request, we explained in more details the syntax choices and explored alternatives.
\item Wording improvements
\end{itemize}

\subsection{R0}

\begin{itemize}
\item{Initial revision}
\end{itemize}

\section{Motivation}

The motivation for pack indexing is covered in \paper{P1858R2} and
 \paper{P2632R0}.

The short background version is that packs are sequences of types or expressions
and indexing is a fundamental operation on sequences.
C++ and its users have so far relied on deduction or library facilities, such as \tcode{index_sequence}, or full-fledged template metaprogramming libraries, such as
mp11 and boost.hana, to extract the Nth element of a pack, which has a high cost both in terms of code complexity and compiler throughput.

This paper proposes a new code language syntax to index packs of types (yielding a type) and packs of expressions (yielding an expression).

Previous works in this area also include \paper{P0565R0}, \paper{P1803R0}, \paper{N3761} and \paper{N4235}.

\section{Syntax}

The general syntax is \tcode{\placeholder{name-of-a-pack} ... [constant-expression]}.
The syntax has the benefit of reusing familiar elements (\tcode{...} usually denotes a pack expansion) and \tcode{[]} subscripts.
That indexing a pack expansion reuses these elements is, therefore, natural:

\begin{colorblock}
template <typename... T>
constexpr auto first_plus_last(T... values) ->  T...[0] {
    return T...[0](values...[0] + values...[sizeof...(values)-1]);
}
int main() {
    //first_plus_last(); // ill formed
    static_assert(first_plus_last(1, 2, 10) == 11);
}
\end{colorblock}

This syntax is used by Circle and was initially proposed by \paper{P1858R2}.

\subsection{Other syntactic options considered}

The \tcode{pack...[index]}
syntax was selected for this proposal after considering a
number of other options, some of which have been proposed by other
committee members.
\begin{itemize}
\item \tcode{pack.[index]}; see \paper{N4235}
\item \tcode{pack<index>} or \tcode{pack...<index>}
\item \tcode{std::nth_type<index, pack...>} or \tcode{std::nth_value<index>(pack...)}
\item \tcode{packexpr(args, I)}; see \paper{P1803R0}
\item \tcode{[index]pack}; see \paper{P0535R0}
\item Pack objects; see \paper{P2671R0}
\end{itemize}

\subsection{So, which syntax is the best choice?}

Any syntax would be better than
\href{https://twitter.com/incomputable/status/1590733659694583808}{the status quo}.
However, having considered the different options, the original choice,

\tcode{Pack...[N]}, still seems to be the best option, as it is straightforward
and consistent with existing pack features.  What follows is a detailed
analysis of the different options, but readers who find the proposed syntax acceptable might want to skip forward to
the "Pack Index" section.

Before arguing what the best syntax is, which is ultimately subjective, we need to understand the constraints.
\begin{itemize}
\item An indexed pack can produce a type, an expression, and maybe in the future a template template parameter, a universal template, and so on; thus we need a syntax
that can work in all contexts.

\item We want a syntax that can be expanded to support slicing in the future.

\item Pack elements can be array like or tuple like, so we need to be careful
  about ambiguities. In particular, directly applying a subscript to a pack
  (\tcode{P[i]}, where \tcode{P} is a pack) is nonviable. Indeed, indexing a
  pack of arrays (\tcode{ArrayPack...[index]}), indexing each array in a pack
  (\tcode{ArrayPack[index]...}), indexing a single array with a pack of indexes
  (\tcode{Array[IndexPack]...}), and indexing each array in a pack of arrays
  with an index from an (equal-length) pack of indexes
  (\tcode{ArrayPack[IndexPack]...}) are different operations, all of which are
  useful. [\href{https://compiler-explorer.com/z/E86h8eMG1}{This example}]
  shows how, using the proposed syntax, one can distinguish between indexing
  the arrays from a pack with indexes from a pack
  (\tcode{ArrayPack[IndexPack]...}) and indexing a pack of arrays with a pack
  of indexes (\tcode{ArrayPack...[IndexPack]...}).
\end{itemize}

\subsubsection{\tcode{pack.[index]}}

Historically in C++ (and C++-like languages), a single dot denotes member access.
Reusing that syntax for pack indexing would introduce a semantics inconsistency and, more importantly, could close the door to future evolutions.

\paper{P1858R0} proposes \tcode{tuple-like.[N]} as syntactic sugar over
\tcode{get<N>(tuple-like)}
and \tcode{aggregate.[N]} returning the $Nth$ data member of an aggregate. % lah: WHAT is "returning the $Nth$ data member of an aggregate"---just the aggregate.[N] or BOTH get<N>(tuple-like) AND aggregate.[N]?

Ideally, \tcode{tuple[N]} would simply work.
A few proposals have tried to improve the user-friendlyness
of tuple indexing (see
\paper{P2726R0} and \paper{P0311R0}).

We see no technical limitation to making \tcode{tuple-like[N]} work on types that do not otherwise define a \tcode{operator[]}.
\paper{P1858R2} prefers \tcode{.[]} to \tcode{[]} because the paper proposes to index not only tuple-like, but also any other decomposable types, such as aggregates.
An aggregate might have an \tcode{operator[]} already, so disambiguating is unnecessary.
Note that array-like classes are tuple like, but their \tcode{operator[]} has the same semantics as what tuple indexing would do. % lah: I know this seems weird, but in "array-like classes," the "array-like" is functioning as a two-word adjective for a noun, so it gets a hyphen, and "tuple like" is functioning as a predicate adjective, so it doesn't get a hyphen.

Whether tuple-indexing should be written as \tcode{.[]} or \tcode{[]} depends on whether indexing an aggregate is a frequent enough use case
to warrant a specific syntax, rather than indexing the pack formed by unpacking an aggregate (\tcode{aggregate[:]} --- in the syntax of \paper{P1858R2}, \tcode{aggregate.[N]} is a shorthand for \tcode{aggregate[:]...[N]}).

If % lah: When are you using "we" to mean the authors and when are you using it to mean "the Committee" or "the C++ community"?
a shorthand syntax to index the fields of an aggregate doesn't seem useful, then we can index tuple-like objects with \tcode{tuple[N]}, which would make
\tcode{pack.[N]} up for grabs. But that does not mean we should. We see little motivation --- other than availability --- for using syntax that usually denotes member access for packs.

\subsubsection{Angle brackets}

We could use angle brackets instead of square brackets, the argument, we suppose, being argument is that \tcode{<>} is more template like and that pack indexing is also template like.
However, most languages have existing practices in which \tcode{[]} is to be used for both indexing and slicing.
Being consistent with existing practice doesn't hurt.
Besides, pack indexing will often occur in angle-bracket-heavy code, so using brackets for indexing too would not look better.

\subsection{\tcode{std::nth_type<index, pack...>} or \tcode{std::nth_value<index>(pack...)}}

As mentioned in the motivation section, there already exist library-only
approaches to indexing a pack in mp11, boost.hana, and other libraries.
Indeed, most implementations of the C++ Standard Library contain a private
metafunction or two for this purpose.

The implementations are not complicated, but they are hard to write correctly
and, in non-optimized compiles, can result in the generation of a large number
of symbols and small functions:

\begin{colorblock}
template <size_t Index, class P0, class... Pack>
struct __nth_type_imp
{
    using type = typename __nth_type_imp<Index - 1, Pack...>::type;
};

template <class P0, class... Pack>
struct __nth_type_imp<0, P0, Pack...>
{
    using type = P0;
};

template <size_t Index, class P0, class... Pack>
using nth_type = typename __nth_type_imp<Index, P0, Pack...>::type;

template <size_t Index, class T0, class... Types>
constexpr decltype(auto) nth_value(T0&& p0, Types&&... pack) noexcept
{
    if constexpr (0 == Index)
        return std::forward<T0>(p0);
    else
        return nth_value<Index-1>(std::forward<Types>(pack)...);
}
\end{colorblock}

The obvious advantage of this approach is that it is implemented entirely in
the library, with no language changes necessary.  However, the disadvantages
are significant:

\begin{itemize}
\item Not only is the syntax harder to use, but there are different syntaxes
  for packs of types verses packs of values. A metafunction for indexing a pack
  of templates (not shown) would have a third name and require yet another
  syntax.
\item The recursion level for each of these facilities is
  $O(index)$. The instantiations for each index value is not re-used for
  other index values, so \tcode{nth_type<5, pack...>} and
  \tcode{nth_type<6, pack...>} produce 11 instantiations total, even with the
  same \tcode{pack}.  Retrieving every element of a pack of size $N$,
  requires $\mathtt{O(N^2)}$ template instantiations.  If implemented entirely as
  a library, the drag on compile time can be quite large.

  A compiler can reduce the instantiation expense through the use of an
  intrinsic, and several compilers have implemented such intrinsics.  However,
  there is no guarantee that every implementation will do so.  Moreover, even
  if the library template invoked an intrinsic, one level of pack expansion is
  still needed for the indirection, making the best-case scenario
  $\mathtt(O(index))$.
\item The library solution does not have a future path for
  treating a subset of a pack as an unexpanded pack (slicing). Because packs
  are not first-class objects or types, it is doubtful that any metafunction
  could yield an unexpanded pack without language changes, thus eliminating the
  advantages of a library-only approach.
\item The library solution would also not work for universal template
  parameters, as described in \paper{P1985R1}.
\end{itemize}

\subsubsection{Magic function}

\paper{P1803R0} proposed \tcode{packexpr(pack, N)}, i.e., \tcode{reserved-identifier(pack, N)}.
We would need to find an identifier that is meaningful for all types of packs (not just expressions) and is not widely used.
The identifier would most certainly have to be a globally reserved keyword (not a contextual one), as pack indexing can appear anywhere either a type, or an expression can appear, which is everywhere.

Perhaps \tcode{packelement(pack, index)} would work, but we would arguably need another identifier for slicing.

\subsubsection{\tcode{[N]pack...}}

\paper{P0535R0} explored putting the index before the pack, and this method
would probably work, although some looking ahead might be necessary to distinguish that syntax from that of lambdas.
We see no logic to this choice other than, again, availability.

\subsubsection{Pack objects}

\paper{P2671R0} proposes a syntax (rather arbitrarily given it's currently unused), to create a \textit{pack object} or, rather, to instruct the compiler to manipulate
a pack without expanding it.
The one motivating use case is for the expansion statement, where that syntax allows us to distinguish \textit{looping} over a tuple versus looping over a pack in a nonambiguous manner.
Other examples, including pack indexing and slicing, look similar but arguably worse using this \textit{pack object} mechanism.

As noted, an expansion statement can be used with a pack using

\begin{colorblock}
    template for (auto elem : std::tuple(ts...)) { ... }
\end{colorblock}

Revzin observes this use is "wasteful," which is true, but a big part of the problem is that a tuple is a much heavier type than it ought to be,
and pack indexing is one of the tools we need to make tuples lighter - along with forwarding references deduction and member packs.

In this model, \tcode{pack!} is a pack object (the syntax seems to have been chosen rather arbitrarily on the fact it's currently not used),
and then that object can be indexed using \tcode{pack![N]}.

The pack object can be modeled by taking a reflection of the pack and then indexing that object splices the Nth element, as explained in \paper{P2671R0}

\begin{colorblock}
template <std::vector<std::meta::info> V>
struct PackObject {
    constexpr auto operator[](std::ptrdiff_t idx) const {
        return [: V[idx] :];
    }
};
\end{colorblock}

This model does not explain how it would deal with packs of types, template parameters, universal templates, and anything that is not an expression as an \tcode{operator[]}
has to return an expression.
Note that it could arguably return a meta::info and then let the user do the splicing itself, at which point any proclaimed syntax advantage would be lost.

We probably should have a discussion around the concept of pack objects, because they raise an interesting question:
Do we need a syntax to reflect on a pack, that would be a shorthand for \tcode{std::vector\{\^{}ts...\}}? Maybe?
Because I think that's the question that "pack-objects" fundamentally tries to answer.

And it is true that pack indexing is equivalent to
\begin{colorblock}
 [: std::vector{^pack...}[N] :]
\end{colorblock}

And slicing can probably be emulated with

\begin{colorblock}
...[: std::vector{^pack...} | std::views::drop(N) | std::views::take(M) ] :]...
\end{colorblock}

Note that \paper{P2671R0} seems to propose a slicing operator (\tcode{pack[N:M]}) anyway,
because the code above is not exactly terse.

Barry observes that slicing through a pack object creates more questions than it solves.
If slicing a pack creates a pack - which seems fairly obvious, does slicing a pack object create a pack object or a pack?

Both answers seem equally justified, however if slicing a pack object produces a pack object, now we need another syntax
to turn the pack object back into a pack, and this is how \paper{P2671R0}
ends up suggesting \tcode{ts![1:]\~...} or \tcode{ts![1..]\~...}.

Which is a lot of new syntax constructs that do try to offer a consistent story.
And only work for expressions!

In terms of compile time, an implementation could either do what the paper proposes,
ie create a pack object, which includes a constexpr vector, evaluate that, and splice it to get the resulting expression
which would be less than optimal (and yet faster than any existing solution!), or an implementation
could be cleaver and treat \tcode{![N]} as a single "pack indexing" construct, which would be efficient but would be, in effect,
a pack indexing operation spelled \tcode{![]} instead of \tcode{...[]}.

I will not claim that one is prettier than the other, but one is certainly a natural extension of the current grammar.\subsubsection{Something else?}

We could entertain all sorts of syntaxes that are not yet used: two dots, four dots, \tcode{!}, \tcode{@} \$, and so on.
None of them would be a logical extension of the existing grammar, and since we are extending an existing facility, we should aim for something more justified than simply "it's not yet used by something else."

\subsubsection{Too many dots?}

One of the arguments heard against the \tcode{T...[N]} syntax is the "too many dots" argument.
And it's true that code that perform a lot of pack manipulation has numerous dots.
However, the code does make sense and is readable; e.g., see this \href{https://github.com/seanbaxter/circle/blob/master/tuple/tuple.hxx}{linked implementation of tuple}.
A few advantages come along with \tcode{...} for pack expansions.
\begin{itemize}
\item Seeing at a glance which pattern is expanded and where is useful.
\item The syntax of pack declarations and pack expansion has so far been rather consistent and follows a given pattern. Multiple paper authors
 have come up with the same syntax independently because it's an obvious extension of existing syntax.
\item Using \tcode{...\placeholder{postfix-syntax}} for this feature --- and future pack-related features (and nothing else) --- gives us a clear, reserved design space for packs.
\end{itemize}

\section{Allowable values for the pack index}

The index of a pack indexing expression or specifier is an integral constant expression between 0 and \tcode{sizeof...(pack) - 1}.
Empty packs can't be indexed.

In other proposals, a negative index, \tcode{-N}, would be interpreted as
indexing from the end of the pack --- as an alias of \tcode{T...[sizeof...(T)-N]}.
However, a negative index could occur by accident, yielding surprising results:

\begin{colorblock}
// Return the index of the first type convertible to Needle in Pack
// @\textbf{or -1 if Pack does not contain a suitable type}@.
template <typename Needle, typename... Pack>
auto find_convertible_in_pack;

// if find_convertible_in_pack<Foo, Types...> is -1, T will be the last type, erroneously.
using T = Types...[find_convertible_in_pack<Foo, Types...>];
\end{colorblock}

In general, incorrect computations in an index can lead to a negative value that should make the program ill formed but would instead
yield an incorrect type.

Note, however, that Circle does support from-the-end indexing using a negative index, and Sean Baxter reports no surprises from using this feature.

An alternative for indexing from the end is to provide a specific syntax; for example, C\# uses \tcode{\^{}} to mean "from the end", and Dlang interprets \tcode{\${}}
as the size of the array:
\begin{colorblock}
using Foo = T...[0];
using Bar = T...[^1]; // first from the end
using Bar = T...[$ - 1]; // first from the end
\end{colorblock}

Given that alternatives are available, all of which can be added later and for which we do not have usage experience, this paper does not propose
from-the-end indexing.

\section{Indexing a pack of types}

Indexing a pack of types is a type specifier that can, like \tcode{decltype}, appear as
\begin{itemize}
    \item a simple-type-specifier
    \item a base class specifier
    \item a nested name specifier
    \item the type of an explicit destructor call
\end{itemize}

\section{Type deduction}

Pack indexing specifiers should not allow deducing the pack from such an expression:

\begin{colorblock}
template <typename... T>
void f(T...[0]);
f(0);
\end{colorblock}

To start thinking about how deduction would work here or what that code would possibly mean doesn't make sense.
We simply always consider pack indexing to be a non-deduced context.

\section{Indexing a pack of expressions}

The intent is that a pack indexing expression behaves exactly as the underlying expression would.
In particular, \tcode{decltype(id-dexpression) and \tcode{decltype(pack-index-expression)}} behave the same.

\section{Future evolution}

The syntax can be extended in subsequent proposals to support

\begin{itemize}
\item indexing packs introduced by structured bindings or other non-dependent packs
\item indexing packs of template template parameters
\item from-the-end-indexing
\item pack slicing (returning a subset of a pack as an unexpanded pack)
\end{itemize}
Packs of universal template parameters could be indexed in the same way.


\section{Potential impact on existing code}

In C++23, \tcode{T... [N]} is a valid syntax for declaring a function parameter matching a pack of unnamed arrays of size N:

\begin{colorblock}
template <typename... T>
void f(T... [1]); //
int main() {
    f<int, double>(nullptr, nullptr); // void f<int, double>(int [1], double [1])
}
\end{colorblock}

Neither MSVC nor GCC supports this syntax and this pattern does not appear outside of compiler test suites (from a search on \href{https://cs.github.com/}{Github}, \href{https://codesearch.isocpp.org/cgi-bin/cgi_ppsearch?q=...%5B&search=Search}{isocpp} and in VCPKG).
The fact that 2 majors compilers did not implement this syntax in over a decade is indicative of its lack of usefulness.

Should anyone be affected, a workaround is to name the variable:

\begin{colorblock}
template <typename... T>
void f(T... foo[1]);
\end{colorblock}

See this linked \href{https://godbolt.org/z/T7v3ETz1G}{demonstration}.

\section{Implementation}

This proposal is inspired by features implemented in the Circle compiler (with the same syntax).
The provided wording is based on an implementation in a fork of Clang, which is available on \href{https://compiler-explorer.com/z/WKobTEq6x}{Compiler Explorer}.

\section{Wording}

\rSec2[basic.lookup.qual]{Qualified name lookup}

\rSec3[basic.lookup.qual.general]{General}

\pnum
\indextext{lookup!qualified name|(}%
\indextext{name!qualified}%
\indextext{qualification!explicit}%
Lookup of an \grammarterm{identifier}
followed by a \tcode{::} scope resolution operator
considers only
namespaces, types, and templates whose specializations are types.
If a name, \grammarterm{template-id}, or \grammarterm{\changed{decltype-specifier}{complex-type-specifier}}
is followed by a \tcode{::},
it shall designate a namespace, class, enumeration, or dependent type,
and the \tcode{::} is never interpreted as
a complete \grammarterm{nested-name-specifier}.


\rSec2[expr.prim.id]{Names}

\rSec3[expr.prim.id.general]{General}

\begin{bnf}
	\nontermdef{id-expression}\br
	unqualified-id\br
	qualified-id\br
\begin{addedblock}
	pack-index-expression
\end{addedblock}
\end{bnf}

\rSec3[expr.prim.id.unqual]{Unqualified names}


% Modify id-expression to add another level for (un)qualified-id (id)
% a pack-expression => restrict to identifier

% check the order of pack specifier to appear last everywhere it is mentionned.

% introduce complex type specifier

\begin{bnf}
    \nontermdef{unqualified-id}\br
    identifier\br
    operator-function-id\br
    conversion-function-id\br
    literal-operator-id\br
    \terminal{\~} type-name\br
    \terminal{\~} \changed{decltype-specifier}{complex-type-specifier}\br
    template-id
\end{bnf}

\pnum
\indextext{identifier}
An \grammarterm{identifier} is only
an \grammarterm{id-expression} if it has
been suitably declared \iref{dcl.dcl}
or if it appears as part of a \grammarterm{declarator-id} \iref{dcl.decl}.
An \grammarterm{identifier} that names a coroutine parameter
refers to the copy of the parameter \iref{dcl.fct.def.coroutine}.

\begin{note}
    For \grammarterm{operator-function-id}{s}, see~\ref{over.oper}; for
    \grammarterm{conversion-function-id}{s}, see~\ref{class.conv.fct}; for
    \grammarterm{literal-operator-id}{s}, see~\ref{over.literal}; for
    \grammarterm{template-id}{s}, see~\ref{temp.names}.
    A \grammarterm{type-name} or \grammarterm{ \changed{decltype-specifier}{complex-type-specifier}}
    prefixed by \tcode{\~} denotes the destructor of the type so named;
    see~\ref{expr.prim.id.dtor}.
    Within the definition of a non-static member function, an
    \grammarterm{identifier} that names a non-static member is transformed to a
    class member access expression \iref{class.mfct.non.static}.
\end{note}

\pnum
A \defn{component name} of an \grammarterm{unqualified-id} $U$ is
\begin{itemize}
    \item
    $U$ if it is a name or
    \item
    the component name of
    the \grammarterm{template-id} or \grammarterm{type-name} of $U$, if any.
\end{itemize}

\begin{note}
    Other constructs that contain names to look up can have several
    component names \iref{expr.prim.id.qual, dcl.type.simple, dcl.type.elab,
        dcl.mptr, namespace.udecl, temp.param, temp.names, temp.res}.
\end{note}

The \defnadj{terminal}{name} of a construct is
the component name of that construct that appears lexically last.


\rSec3[expr.prim.id.qual]{Qualified names}

\indextext{operator!scope resolution}%
\indextext{\idxcode{::}|see{operator, scope resolution}}%
%
\begin{bnf}
    \nontermdef{qualified-id}\br
    nested-name-specifier \opt{\keyword{template}} unqualified-id
\end{bnf}

\indextext{operator!scope resolution}%
\indextext{name hiding}%
%
\begin{bnf}
    \nontermdef{nested-name-specifier}\br
    \terminal{::}\br
    type-name \terminal{::}\br
    namespace-name \terminal{::}\br
    \changed{decltype-specifier}{complex-type-specifier} \terminal{::}\br
    nested-name-specifier identifier \terminal{::}\br
    nested-name-specifier \opt{\keyword{template}} simple-template-id \terminal{::}
\end{bnf}

\pnum
\indextext{component name}%
The component names of a \grammarterm{qualified-id} are those of
its \grammarterm{nested-name-specifier} and \grammarterm{unqualified-id}.
The component names of a \grammarterm{nested-name-specifier} are
its \grammarterm{identifier} (if any) and those of its
\grammarterm{type-name},
\grammarterm{namespace-name},
\grammarterm{simple-template-id}, and/or
\grammarterm{nested-name-specifier}.

\pnum
A \grammarterm{nested-name-specifier} is \defn{declarative} if it is part of
\begin{itemize}
    \item
    a \grammarterm{class-head-name},
    \item
    an \grammarterm{enum-head-name},
    \item
    a \grammarterm{qualified-id}
    that is the \grammarterm{id-expression} of a \grammarterm{declarator-id}, or
    \item
    a declarative \grammarterm{nested-name-specifier}.
\end{itemize}
A declarative \grammarterm{nested-name-specifier}
shall not have a \grammarterm{decltype-specifier}.
A declaration that uses a declarative \grammarterm{nested-name-specifier}
shall be a friend declaration or
inhabit a scope that contains the entity being redeclared or specialized.

\pnum
The \grammarterm{nested-name-specifier} \tcode{::} nominates
the global namespace.
A \grammarterm{nested-name-specifier} with a \grammarterm{\changed{decltype-specifier}{complex-type-specifier}}
nominates the type denoted by the \grammarterm{\changed{decltype-specifier}{complex-type-specifier}},
which shall be a class or enumeration type.
If a \grammarterm{nested-name-specifier} $N$
is declarative and
has a \grammarterm{simple-template-id} with a template argument list $A$
that involves a template parameter,
let $T$ be the template nominated by $N$ without $A$.
$T$ shall be a class template.
\begin{itemize}
    \item
    {If $A$ is the template argument list \iref{temp.arg} of
    the corresponding \grammarterm{template-head} $H$ \iref{temp.mem},
    $N$ nominates the primary template of $T$;
    $H$ shall be equivalent to
    the \grammarterm{template-head} of $T$ \iref{temp.over.link}.}
    \item
    {Otherwise, $N$ nominates the partial specialization \iref{temp.spec.partial} of $T$
    whose template argument list is equivalent to $A$ \iref{temp.over.link};
    the program is ill-formed if no such partial specialization exists.}
\end{itemize}
Any other \grammarterm{nested-name-specifier} nominates
the entity denoted by its
\grammarterm{type-name},
\grammarterm{namespace-name},
\grammarterm{identifier}, \removed{or}
\grammarterm{simple-template-id}.
If the \grammarterm{nested-name-specifier} is not declarative,
the entity shall not be a template.

\pnum
A \grammarterm{qualified-id} shall not be of the form
\grammarterm{nested-name-specifier} \opt{\keyword{template}} \tcode{\~}
\grammarterm{\changed{decltype-specifier}{complex-type-specifier}} nor of the form
\grammarterm{\changed{decltype-specifier}{complex-type-specifier}} \tcode{::} \tcode{\~} \grammarterm{type-name}.

\pnum
The result of a \grammarterm{qualified-id} $Q$ is
the entity it denotes \iref{basic.lookup.qual}.
The type of the expression is the type of the result.
The result is an lvalue if the member is
\begin{itemize}
    \item
    a function other than a non-static member function,
    \item
    a non-static member function
    if $Q$ is the operand of a unary \tcode{\&} operator,
    \item
    a variable,
    \item
    a structured binding \iref{dcl.struct.bind}, or
    \item
    a data member,
\end{itemize}
and a prvalue otherwise.

\begin{addedblock}
\ednote{Add a new section after [expr.prim.id.qual]}

\rSec3[expr.prim.pack.index]{Pack indexing expression}

\begin{bnf}
    \nontermdef{pack-index-expression}\br
    identifier \terminal{...} \terminal{[} constant-expression \terminal{]}  \br
\end{bnf}

The \grammarterm{identifier} in a \grammarterm{pack-index-expression} shall denote a pack.

The \grammarterm{constant-expression} shall be a converted constant expression [expr.const] of type \tcode{std::size_t} whose value $V$ is such that $0 \le V < \tcode{sizeof...(identifier)}$.

The index of the \grammarterm{pack-index-expression} is $V$.

A \grammarterm{pack-index-expression} is a pack expansion ([temp.variadic]).

\note{A \grammarterm{pack-index-expression} denotes the $V$\textsuperscript{th} expression in the pack denoted by the  \grammarterm{identifier} ([temp.variadic]).}

\end{addedblock}

\rSec3[expr.unary.op]{Unary operators}

\ednote{Modify [expr.unary.op]/p10}

\pnum
\indextext{operator!ones' complement}%
The operand of the \tcode{\~{}} operator shall have integral or unscoped enumeration type.
Integral promotions are performed.
The type of the result is the type of the promoted operand.
% FIXME: [basic.fundamental]/p5 uses $x_i$; [expr] uses $\tcode{x}_i$.
Given the coefficients $\tcode{x}_i$
of the base-2 representation\iref{basic.fundamental}
of the promoted operand \tcode{x},
the coefficient $\tcode{r}_i$
of the base-2 representation of the result \tcode{r}
is 1 if $\tcode{x}_i$ is 0, and 0 otherwise.
\begin{note}
	The result is the ones' complement of the operand
	(where operand and result are considered as unsigned).
\end{note}
There is an ambiguity
in the grammar when \tcode{\~{}} is followed by
a \grammarterm{type-name} or \grammarterm{\changed{decltype-specifier}{complex-type-specifier}}.
The ambiguity is resolved by treating \tcode{\~{}} as the
operator rather than as the start of an \grammarterm{unqualified-id}
naming a destructor.
\begin{note}
	Because the grammar does not permit an operator to follow the
	\tcode{.}, \tcode{->}, or \tcode{::} tokens, a \tcode{\~{}} followed by
	a \grammarterm{type-name} or \grammarterm{\changed{decltype-specifier}{complex-type-specifier}} in a
	member access expression or \grammarterm{qualified-id} is
	unambiguously parsed as a destructor name.
\end{note}

\rSec2[dcl.name]{Type names}

\pnum
\indextext{type name}%
To specify type conversions explicitly,
\indextext{operator!cast}%
and as an argument of
\tcode{sizeof},
\tcode{alignof},
\keyword{new},
or
\tcode{typeid},
the name of a type shall be specified.
This can be done with a
\grammarterm{type-id},
which is syntactically a declaration for a variable or function
of that type that omits the name of the entity.

\begin{bnf}
    \nontermdef{type-id}\br
    type-specifier-seq \opt{abstract-declarator}
\end{bnf}

\begin{bnf}
    \nontermdef{defining-type-id}\br
    defining-type-specifier-seq \opt{abstract-declarator}
\end{bnf}

\begin{bnf}
    \nontermdef{abstract-declarator}\br
    ptr-abstract-declarator\br
    \opt{noptr-abstract-declarator} parameters-and-qualifiers trailing-return-type\br
    abstract-pack-declarator
\end{bnf}

\begin{bnf}
    \nontermdef{ptr-abstract-declarator}\br
    noptr-abstract-declarator\br
    ptr-operator \opt{ptr-abstract-declarator}
\end{bnf}

\begin{bnf}
    \nontermdef{noptr-abstract-declarator}\br
    \opt{noptr-abstract-declarator} parameters-and-qualifiers\br
    \opt{noptr-abstract-declarator} \terminal{[} \opt{constant-expression} \terminal{]} \opt{attribute-specifier-seq}\br
    \terminal{(} ptr-abstract-declarator \terminal{)}
\end{bnf}

\begin{bnf}
    \nontermdef{abstract-pack-declarator}\br
    noptr-abstract-pack-declarator\br
    ptr-operator abstract-pack-declarator
\end{bnf}

\begin{bnf}
    \nontermdef{noptr-abstract-pack-declarator}\br
    noptr-abstract-pack-declarator parameters-and-qualifiers\br
    \removed{noptr-abstract-pack-declarator \terminal{[} \opt{constant-expression} \terminal{]} \opt{attribute-specifier-seq}}\br
    \terminal{...}
\end{bnf}

\ednote{The sequence \tcode{...[constant-expression]} should always be treated as pack indexing. However we may want to allow \tcode{T(\&...)[constant-expression]},
which is the object of \paper{CWG1488}}

\ednote{[...]}

\rSec3[dcl.type.simple]{Simple type specifiers}%
\indextext{type specifier!simple}

\pnum
The simple type specifiers are

\begin{bnf}
\nontermdef{simple-type-specifier}\br
\opt{nested-name-specifier} type-name\br
nested-name-specifier \keyword{template} simple-template-id\br\textbf{}
\changed{decltype-specifier}{complex-type-specifier}\br
placeholder-type-specifier\br
\opt{nested-name-specifier} template-name\br
\end{bnf}

\begin{addedblock}
\begin{bnf}
\nontermdef{complex-type-specifier}\br
decltype-specifier\br
pack-index-specifier\br
\end{bnf}
\end{addedblock}

\textcolor{noteclr}{[...]}

\begin{simpletypetable}
    {\grammarterm{simple-type-specifier}{s} and the types they specify}
    {dcl.type.simple}
    {ll}
    \topline
    \hdstyle{Specifier(s)}            &   \hdstyle{Type}                  \\ \capsep
    \grammarterm{type-name}           & the type named                    \\
    \grammarterm{simple-template-id}  & the type as defined in [temp.names]\\
    \grammarterm{decltype-specifier}  & the type as defined in [dcl.type.decltype]\\
    \added{\grammarterm{pack-index-specifier}} & \added{the type as defined in [dcl.type.pack.indexing]} \\
    \grammarterm{placeholder-type-specifier}
    & the type as defined in [dcl.spec.auto]\\
    \grammarterm{template-name}       & the type as defined in [dcl.type.class.deduct]\\
    \tcode{char}                      & ``\tcode{char}''                  \\
    \tcode{unsigned char}             & ``\tcode{unsigned char}''         \\
    \tcode{signed char}               & ``\tcode{signed char}''           \\
    \keyword{char8_t}                   & ``\tcode{char8_t}''               \\
    \keyword{char16_t}                  & ``\tcode{char16_t}''              \\
    ... & \\
\end{simpletypetable}


\pnum
When multiple \grammarterm{simple-type-specifier}{s} are allowed, they can be
freely intermixed with other \grammarterm{decl-specifier}{s} in any order.
\begin{note}
    It is \impldef{signedness of \tcode{char}} whether objects of \tcode{char} type are
    represented as signed or unsigned quantities. The \tcode{signed} specifier
    forces \tcode{char} objects to be signed; it is redundant in other contexts.
\end{note}


\ednote{Add a new section after [dcl.type.simple]}


\begin{addedblock}

\rSec3[dcl.type.pack.indexing]{Pack indexing specifier}

\begin{bnf}
    \nontermdef{pack-index-specifier}\br
    typedef-name \terminal{...} \terminal{[} constant-expression \terminal{]}  \br
\end{bnf}

The \grammarterm{typedef-name} in a \grammarterm{pack-index-specifier} shall denote a pack.

The \grammarterm{constant-expression} shall be a converted constant expression [expr.const] of type \tcode{std::size_t} whose value $V$ is such that $0 \le V < \tcode{sizeof...(typedef-name)}$.

The index of a \grammarterm{pack-index-specifier} is $V$.
A \grammarterm{pack-index-specifier} is a pack expansion ([temp.variadic]).

\note{The \grammarterm{pack-index-specifier} denotes the type of the ${V}$\textsuperscript{th} \tcode{typedef-name} of the pack ([temp.variadic]).}

\end{addedblock}



\rSec3[dcl.type.decltype]{Decltype specifiers}%
\indextext{type specifier!\idxcode{decltype}}%

\begin{bnf}
    \nontermdef{decltype-specifier}\br
    \keyword{decltype} \terminal{(} expression \terminal{)}
\end{bnf}

\pnum
\indextext{type specifier!\idxcode{decltype}}%
For an expression $E$, the type denoted by \tcode{decltype($E$)} is defined as follows:
\begin{itemize}
\item if $E$ is an unparenthesized \grammarterm{id-expression}
naming a structured binding \iref{dcl.struct.bind},
\tcode{decltype($E$)} is the referenced type as given in
the specification of the structured binding declaration;

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression}
naming a non-type \grammarterm{template-parameter} \iref{temp.param},
\tcode{decltype($E$)} is the type of the \grammarterm{template-parameter}
after performing any necessary
type deduction \iref{dcl.spec.auto, dcl.type.class.deduct};

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression} or
an unparenthesized
class
member access \iref{expr.ref}, \tcode{decltype($E$)} is the
type of the entity named by $E$.
If there is no such entity, the program is ill-formed;

\item otherwise, if $E$ is
an xvalue, \tcode{decltype($E$)} is \tcode{T\&\&}, where \tcode{T} is the type
of $E$;

\item otherwise, if $E$ is an lvalue, \tcode{decltype($E$)}
is \tcode{T\&}, where \tcode{T} is the type of $E$;

\item otherwise, \tcode{decltype($E$)} is the type of $E$.
\end{itemize}

The operand of the \keyword{decltype} specifier is an unevaluated
operand \iref{term.unevaluated.operand}.

\begin{example}
    \begin{codeblock}
        const int&& foo();
        int i;
        struct A { double x; };
        const A* a = new A();
        decltype(foo()) x1 = 17;        // type is \tcode{const int\&\&}
        decltype(i) x2;                 // type is \tcode{int}
        decltype(a->x) x3;              // type is \tcode{double}
        decltype((a->x)) x4 = x3;       // type is \tcode{const double\&}
        \end{codeblock}
        \begin{addedblock}
        \begin{codeblock}
        [](auto... pack){
            decltype(pack...[0])   x5;  // type is \tcode{int}
            decltype((pack...[0])) x6;  // type is \tcode{int\&}
        }(0);
        \end{codeblock}
        \end{addedblock}
\end{example}


\rSec1[class]{Classes}

\rSec2[class.dtor]{Destructors}%


\pnum
\indextext{destructor!explicit call}%
In an explicit destructor call, the destructor is specified by a
\tcode{\~{}}
followed by a
\grammarterm{type-name} or \grammarterm{decltype-specifier}
that denotes the destructor's class type.
The invocation of a destructor is subject to the usual rules for member
functions \iref{class.mfct};
that is, if the object is not of the destructor's class type and
not of a class derived from the destructor's class type (including when
the destructor is invoked via a null pointer value), the program has
undefined behavior.

\rSec1[class.derived]{Derived classes}%

\rSec2[class.derived.general]{General}%
\indextext{derived class|(}

\indextext{virtual base class|see{base class, virtual}}
\indextext{virtual function|see{function, virtual}}
\indextext{dynamic binding|see{function, virtual}}

\pnum
\indextext{base class}%
\indextext{inheritance}%
\indextext{multiple inheritance}%
A list of base classes can be specified in a class definition using
the notation:

\begin{bnf}
    \nontermdef{base-clause}\br
    \terminal{:} base-specifier-list
\end{bnf}


\begin{bnf}
    \nontermdef{base-specifier-list}\br
    base-specifier \opt{\terminal{...}}\br
    base-specifier-list \terminal{,} base-specifier \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
    \nontermdef{base-specifier}\br
    \opt{attribute-specifier-seq} class-or-\changed{decltype}{complex-type-specifier}\br
    \opt{attribute-specifier-seq} \keyword{virtual} \opt{access-specifier} class-or-\changed{decltype}{complex}\br
    \opt{attribute-specifier-seq} access-specifier \opt{\keyword{virtual}} class-or-\changed{decltype}{complex-type-specifier}
\end{bnf}

\begin{bnf}
    \nontermdef{class-or-\changed{decltype}{complex-type-specifier}}\br
    \opt{nested-name-specifier} type-name\br
    nested-name-specifier \keyword{template} simple-template-id\br
    \changed{decltype-specifier}{complex-type-specifier}
\end{bnf}

\indextext{specifier access|see{access specifier}}%
%
\begin{bnf}
    \nontermdef{access-specifier}\br
    \keyword{private}\br
    \keyword{protected}\br
    \keyword{public}
\end{bnf}


\rSec1[temp.type]{Type equivalence}

\pnum
If an expression $e$ is type-dependent \iref{temp.dep.expr},
\tcode{decltype($e$)}
denotes a unique dependent type. Two such \grammarterm{decltype-specifier}{s}
refer to the same type only if their \grammarterm{expression}{s} are
equivalent \iref{temp.over.link}.
\begin{note} % lah: Thios note in the Standard draft is label "Note 1", not just "Note".
    However, such a type might be aliased,
    e.g., by a \grammarterm{typedef-name}.
\end{note}

\begin{addedblock}
For a template parameter pack \tcode{T}, \tcode{T...[\grammarterm{constant-expression}{}]} denotes a unique dependent type.

If the \grammarterm{constant-expression} of a \grammarterm{pack-index-specifier} is value-dependent, two such \grammarterm{pack-index-specifier}{s} refer to the same type only if their \grammarterm{constant-expression}{s} are equivalent \iref{temp.over.link}.

Otherwise, two such \grammarterm{pack-index-specifier}{s} refer to the same type only if their \grammarterm{constant-expression}{s} have the same value.

\end{addedblock}

\rSec2[temp.variadic]{Variadic templates}

\textcolor{noteclr}{[...]}

\pnum
\indextext{pattern|see{pack expansion, pattern}}%
A \defn{pack expansion}
consists of a \defnx{pattern}{pack expansion!pattern} and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:

\begin{itemize}
    \item In a function parameter pack \iref{dcl.fct}; the pattern is the
    \grammarterm{parameter-declaration} without the ellipsis.

    \item In a \grammarterm{using-declaration} \iref{namespace.udecl};
    the pattern is a \grammarterm{using-declarator}.

    \item In a template parameter pack that is a pack expansion \iref{temp.param}:
    \begin{itemize}
        \item
        if the template parameter pack is a \grammarterm{parameter-declaration};
        the pattern is the \grammarterm{parameter-declaration} without the ellipsis;

        \item
        if the template parameter pack is a \grammarterm{type-parameter};
        the pattern is the corresponding \grammarterm{type-parameter}
        without the ellipsis.
    \end{itemize}

    \item In an \grammarterm{initializer-list} \iref{dcl.init};
    the pattern is an \grammarterm{initializer-clause}.

    \item In a \grammarterm{base-specifier-list} \iref{class.derived};
    the pattern is a \grammarterm{base-specifier}.

    \item In a \grammarterm{mem-initializer-list} \iref{class.base.init} for a
    \grammarterm{mem-initializer} whose \grammarterm{mem-initializer-id} denotes a
    base class; the pattern is the \grammarterm{mem-initializer}.

    \item In a \grammarterm{template-argument-list} \iref{temp.arg};
    the pattern is a \grammarterm{template-argument}.

    \item In an \grammarterm{attribute-list} \iref{dcl.attr.grammar}; the pattern is
    an \grammarterm{attribute}.

    \item In an \grammarterm{alignment-specifier} \iref{dcl.align}; the pattern is
    the \grammarterm{alignment-specifier} without the ellipsis.

    \item In a \grammarterm{capture-list} \iref{expr.prim.lambda.capture}; the pattern is
    the \grammarterm{capture} without the ellipsis.

    \item In a \tcode{sizeof...} expression \iref{expr.sizeof}; the pattern is an
    \grammarterm{identifier}.

    \begin{addedblock}
    \item In a \grammarterm{pack-index-expression}; the pattern is an
    \grammarterm{identifier}.
    \item In a \grammarterm{pack-index-specifier}; the pattern is a
    \grammarterm{typedef-name}.
    \end{addedblock}

    \item In a \grammarterm{fold-expression} \iref{expr.prim.fold};
    the pattern is the \grammarterm{cast-expression}
    that contains an unexpanded pack.
\end{itemize}

\begin{example} % lah: this is labeled Example 4 in the Standard's draft.
    \begin{codeblock}
        template<class ... Types> void f(Types ... rest);
        template<class ... Types> void g(Types ... rest) {
            f(&rest ...);     // ``\tcode{\&rest ...}'' is a pack expansion; ``\tcode{\&rest}'' is its pattern
        }
    \end{codeblock}
\end{example}

\pnum
For the purpose of determining whether a pack satisfies a rule
regarding entities other than packs, the pack is
considered to be the entity that would result from an instantiation of
the pattern in which it appears.

\pnum
A pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more packs that
are not expanded by a nested pack expansion; such packs are called
\defnx{unexpanded packs}{pack!unexpanded} in the pattern. All of the packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a pack that is not expanded is
ill-formed.
\begin{example} % lah: this is labeled Example 5 in the Standard's draft.
    \begin{codeblock}
        template<typename...> struct Tuple {};
        template<typename T1, typename T2> struct Pair {};

        template<class ... Args1> struct zip {
            template<class ... Args2> struct with {
                typedef Tuple<Pair<Args1, Args2> ... > type;
            };
        };

        typedef zip<short, int>::with<unsigned short, unsigned>::type T1;
        // \tcode{T1} is \tcode{Tuple<Pair<short, unsigned short>, Pair<int, unsigned>>}
        typedef zip<short>::with<unsigned short, unsigned>::type T2;
        // error: different number of arguments specified for \tcode{Args1} and \tcode{Args2}

        template<class ... Args>
        void g(Args ... args) {                   // OK, \tcode{Args} is expanded by the function parameter pack \tcode{args}
            f(const_cast<const Args*>(&args)...);   // OK, ``\tcode{Args}'' and ``\tcode{args}'' are expanded
            f(5 ...);                               // error: pattern does not contain any packs
            f(args);                                // error: pack ``\tcode{args}'' is not expanded
            f(h(args ...) + args ...);              // OK, first ``\tcode{args}'' expanded within \tcode{h},
            // second ``\tcode{args}'' expanded within \tcode{f}
        }
    \end{codeblock}
\end{example}

\pnum
The instantiation of a pack expansion considers
items $\tcode{E}_1, \tcode{E}_2, \dotsc, \tcode{E}_N$,
where
$N$ is the number of elements in the pack expansion parameters.
Each $\tcode{E}_i$ is generated by instantiating the pattern and
replacing each pack expansion parameter with its $i^\text{th}$ element.
Such an element, in the context of the instantiation, is interpreted as
follows:
\begin{itemize}
    \item
    if the pack is a template parameter pack, the element is
    an \grammarterm{id-expression}
    (for a non-type template parameter pack),
    a \grammarterm{typedef-name}
    (for a type template parameter pack declared without \tcode{template}), or
    a \grammarterm{template-name}
    (for a type template parameter pack declared with \tcode{template}),
    designating the $i^\text{th}$ corresponding type or value template argument;

    \item
    if the pack is a function parameter pack, the element is an
    \grammarterm{id-expression}
    designating the $i^\text{th}$ function parameter
    that resulted from instantiation of
    the function parameter pack declaration;
    otherwise

    \item
    if the pack is an \grammarterm{init-capture} pack,
    the element is an \grammarterm{id-expression}
    designating the variable introduced by
    the $i^\text{th}$ \grammarterm{init-capture}
    that resulted from instantiation of
    the \grammarterm{init-capture} pack.
\end{itemize}
When $N$ is zero, the instantiation of a pack expansion
does not alter the syntactic interpretation of the enclosing construct,
even in cases where omitting the pack expansion entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.

\pnum
The instantiation of a \tcode{sizeof...} expression \iref{expr.sizeof} produces
an integral constant with value $N$.

\begin{addedblock}
\pnum

When instantiating a \grammarterm{pack-index-expression} $P$,
let $K$ be the index of $P$.
The instantiation of $P$ is the \grammarterm{id-expression} \tcode{$\mathtt{E}_K$}.


When instantiating a \grammarterm{pack-index-specifier} $P$,
let $K$ be the index of $P$.
The instantiation of $P$ is the \grammarterm{typedef-name} \tcode{$\mathtt{E}_K$}.
\end{addedblock}


\textcolor{noteclr}{[...]}

\rSec3[temp.deduct.type]{Deducing template arguments from a type}

% An id-expression is type-dependent if it is a template-id that is not a concept-id and is dependent; OR it it a pack expression whose constant expression is a constant expression OR or if its terminal name is

% modify class.base.init.

\pnum
The non-deduced contexts are:

\indextext{context!non-deduced}%
\begin{itemize}
    \item
    The
    \grammarterm{nested-name-specifier}
    of a type that was specified using a
    \grammarterm{qualified-id}.
    \begin{addedblock}
    \item A \grammarterm{pack-index-specifier} or a \grammarterm{pack-index-expression}.
    \end{addedblock}
    \item
    The \grammarterm{expression} of a \grammarterm{decltype-specifier}.
    \item
    A non-type template argument or an array bound in which a subexpression
    references a template parameter.
    \item
    A template parameter used in the parameter type of a function parameter that
    has a default argument that is being used in the call for which argument
    deduction is being done.
    \item
    A function parameter for which the associated argument is an
    overload set \iref{over.over}, and one or more of the following apply:
    \begin{itemize}
        \item
        more than one function matches the function parameter type (resulting in
        an ambiguous deduction), or
        \item
        no function matches the function parameter type, or
        \item
        the overload set supplied as an argument contains one or more function templates.
    \end{itemize}
    \item A function parameter for which the associated argument is an initializer
    list \iref{dcl.init.list} but the parameter does not have
    a type for which deduction from an initializer list is specified \iref{temp.deduct.call}.
    \begin{example}
        \begin{codeblock}
            template<class T> void g(T);
            g({1,2,3});                 // error: no argument deduced for \tcode{T}
        \end{codeblock}
    \end{example}
    \item A function parameter pack that does not occur at the end of the
    \grammarterm{parameter-declaration-list}.
\end{itemize}


\begin{addedblock}

\rSec1[diff.cpp23]{C++ and ISO C++23}

\rSec2[diff.cpp23.dcl.dcl]{Declarations}

\rSec3[decl.array]
\change
Previously, \tcode{T...[$n$]} would declare a pack of function parameters.
\tcode{T...[$n$]} is now a \grammarterm{pack-index-specifier}.
\rationale
Improve the handling of packs.
\effect
Valid C++23 code that declares a pack of parameter without specifying a \tcode{declarator-id} becomes ill-formed.

\begin{codeblock}
template <typename... T>
void f(T... [1]);
template <typename... T>
void g(T... ptr[1]);

int main() {
    f<int, double>(nullptr, nullptr); // ill-formed, previously void f<int, double>(int [1], double [1])
    g<int, double>(nullptr, nullptr); // ok
}
\end{codeblock}

\begin{colorblock}

\end{colorblock}

\end{addedblock}

\section{Feature test macros}

\ednote{Add a new macro in \tcode{[tab:cpp.predefined.ft]} : \tcode{__cpp_pack_indexing} set to the date of adoption}.


\section{Acknowledgments}

We would like to thank Bloomberg for sponsoring this work.\\

We extend our appreciate to Sean Baxter for his work on Circle and to Barry Revzin  for his work on \paper{P1858R2}, both works being the foundation of the design presented here.

Thanks also to Lewis Baker for his valuable feedback on this paper, and Lori Hughes for editing this paper.

\section{References} % lah: Correct your citation style. Books, proceedings, conference names, and Standards use italics. Articles, presentations, and talks use quotes. Harvard style is the general UK convention. https://intranet.birmingham.ac.uk/as/libraryservices/library/referencing/icite/harvard/referencelist.aspx

\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[P2632R0]{P2632R0}
Corentin Jabot, Pablo Halpern, John Lakos, Alisdair Meredith, Joshua Berne, and Gašper Ažman\newline
\emph{A plan for better template meta programming facilities in C++26}\newline
\url{https://wg21.link/P2632R0}\newline
October 2022

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}

\end{document}
