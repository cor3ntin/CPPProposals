% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{Pack Indexing}
\docnumber{D2662R1}
\audience{EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Pablo Halpern}{phalpern@halpernwightsoftware.com}
\authorthree{John Lakos}{jlakos@bloomberg.net}
\authorfour{Alisdair Meredith}{ameredith1@bloomberg.net}
\authorfive{Joshua Berne}{jberne4@bloomberg.net}

\usepackage{color, colortbl}
\begin{document}
\maketitle

\section{Abstract}

This paper expands on the pack indexing feature described in \paper{P1858R2} and provides wording. % lah: wording for what? Perhaps add something like "proposes wording changes for the Standard." 

% lah: do you want to add a TOC? It can be helpful so readers can quickly see what's coming. 

\section{Revisions}


\subsection{R1}

\begin{itemize}
\item{Better explore the syntax choices and explore alternatives}
\end{itemize}

\subsection{R0}

\begin{itemize}
\item{Initial revision}
\end{itemize}

\section{Motivation}

The motivation for pack indexing is covered in \paper{P1858R2} and
 \cite{P2632R0}. % lah: 1. Why are you using two different citation methods? Both papers are cited in this paper. When I click the first paper link, I'm linked to the paper online. When I click the second paper link, I'm linked to the item in the bib. Why are these different? 2. You don't list titles for citations elsewhere, so it's inconsistent to list them here. 

The short background version is that packs are sequences of types/expressions % lah: Replace the slash with either "and", "or", or "and/or" so your reader is 100% clear what you meant. 
 and indexing is a fundamental operation on sequences.
C++ and its users have so far relied on deduction or library facilities, such as \tcode{index_sequence}, or full-fledged template metaprogramming libraries, such as
mp11 and boost.hana, to extract the Nth element of a pack, which has a high cost both in terms of code complexity and compiler throughput.

This paper proposes a new code language syntax to index packs of types (yielding a type) and packs of expressions (yielding an expression).

Previous works in this area also include \paper{P0565R0}, \paper{P1803R0}, \paper{N3761} and \paper{N4235}.

\section{Syntax}

The general syntax is \tcode{\placeholder{name-of-a-pack} ... [constant-expression]}.
The syntax has the benefit of reusing familiar elements (\tcode{...} usually denotes a pack expansion) and \tcode{[]} subscripts.
That indexing a pack expansion reuses these elements is, therefore, natural: 

\begin{colorblock}
template <typename... T>
constexpr auto first_plus_last(T... values) ->  T...[0] {
    return T...[0](values...[0] + values...[sizeof...(values)-1]);
}
int main() {
    //first_plus_last(); // ill formed
    static_assert(first_plus_last(1, 2, 10) == 11);
}
\end{colorblock}

This syntax is used by Circle and was initially proposed by \paper{P1858R2}.

\subsection{Other syntactic options considered}

The pack...[index] % lah: Should this be in code font? 
syntax was selected for this proposal after considering a
number of other options, some of which have been proposed by other
committee members.
\begin{itemize}
\item \tcode{pack.[index]}; see \paper{N4235}
\item \tcode{pack<index>} or \tcode{pack...<index>}
\item \tcode{packexpr(args, I)}; see \paper{P1803R0}
\item \tcode{[index]pack}; see \paper{P0535R0}
\item Pack objects; see \paper{P2671R0}
\end{itemize}

\subsection{So, which syntax is the best choice?}

Any syntax would be better than
\href{https://twitter.com/incomputable/status/1590733659694583808}{the status quo}.
However, having considered the different options, the original choice,
\tcode{Pack...[N]}, still seems to be the best option, as it is straightforward
and consistent with existing pack features.  What follows is a detailed
analysis of the different options, but readers who find the proposed syntax acceptable might want to skip forward to
the "Pack Index" section.

Before arguing what the best syntax is, which is ultimately subjective, we need to understand the constraints.
\begin{itemize}
\item An indexed pack can produce a type, an expression, and maybe in the future a template template parameter, a universal template, and so on; thus we need a syntax
that can work in all contexts.
\item We want a syntax that can be expanded to support slicing in the future.
\item Pack elements can be array like or tuple like, so we need to be careful
  about ambiguities. In particular, directly applying a subscript to a pack
  (\tcode{P[i]}, where \tcode{P} is a pack) is nonviable. Indeed, indexing a
  pack of arrays (\tcode{ArrayPack...[index]}), indexing each array in a pack
  (\tcode{ArrayPack[index]...}), indexing a single array with a pack of indices % lah: indexes is for book indexes and indices is for mathematics.  
  (\tcode{Array[IndexPack]...}), and indexing each array in a pack of arrays
  with an index from an (equal-length) pack of indices 
  (\tcode{ArrayPack[IndexPack]...}) are different operations, all of which are
  useful. [\href{https://compiler-explorer.com/z/E86h8eMG1}{This example}]
  shows how, using the proposed syntax, one can distinguish between indexing
  the arrays from a pack with indices from a pack
  (\tcode{ArrayPack[IndexPack]...}) and indexing a pack of arrays with a pack
  of indices (\tcode{ArrayPack...[IndexPack]...}).
\end{itemize}

\subsubsection{pack.[index]} % lah: 1. note that here you don't use code font,  but for a later section head, you do. Pick a method and use that method consistently. 2. Is there any visual difference between subsection and subsubsection heads? I measured them with an old font ruler, and I see there is a size difference, but I shouldn't have to measure the font to see that. Consider adding section numbering so readers can quickly and easily see the structure. 

Historically in C++ (and C++-like languages), a single dot denotes member access.
Reusing that syntax for pack indexing would introduce a semantics inconsistency and, more importantly, could close the door to future evolutions.

\paper{P1858R0} proposes \tcode{tuple-like.[N]} as sugar over % lah: What do you mean "as sugar over"? If I'm not clear, then a global audience won't be clear. 
\tcode{get<N>(tuple-like)}
and \tcode{aggregate.[N]} returning the $Nth$ data member of an aggregate. % lah: WHAT is "returning the $Nth$ data member of an aggregate"---just the aggregate.[N] or BOTH get<N>(tuple-like) AND aggregate.[N]? 

Ideally, \tcode{tuple[N]} would just work. % lah: By "just," do you mean that it would simply work or do you mean that it would barely work? 
A few proposals have tried to improve the ergonomy % lah: Do you mean ergodicity? 
of tuple indexing (see
\paper{P2726R0} and \paper{P0311R0}).

We see no technical limitation to making \tcode{tuple-like[N]} work on types that do not otherwise define a \tcode{operator[]}.
\paper{P1858R2} prefers \tcode{.[]} to \tcode{[]} because the paper proposes to index not only tuple-like, but also any other decomposable types, such as aggregates.
An aggregate might have an \tcode{operator[]} already, so disambiguating is unnecessary. 
Note that array-like classes are tuple like, but their \tcode{operator[]} has the same semantics as what tuple indexing would do. % lah: I know this seems weird, but in "array-like classes," the "array-like" is functioning as a two-word adjective for a noun, so it gets a hyphen, and "tuple like" is functioning as a predicate adjective, so it doesn't get a hyphen. 

Whether tuple-indexing should be written as \tcode{.[]} or \tcode{[]} depends on whether indexing an aggregate is a frequent enough use case
to warrant a specific syntax, rather than indexing the pack formed by unpacking an aggregate (\tcode{aggregate[:]} --- in the syntax of \paper{P1858R2}, \tcode{aggregate.[N]} is a shorthand for \tcode{aggregate[:]...[N]}).

If % lah: When are you using "we" to mean the authors and when are you using it to mean "the Committee" or "the C++ community"? 
a shorthand syntax to index the fields of an aggregate doesn't seem useful, then we can index tuple-like objects with \tcode{tuple[N]}, which would make
\tcode{pack.[N]} up for grabs. But that does not mean we should. We see little motivation --- other than availability --- for using syntax that usually denotes member access for packs.

\subsubsection{Angle brackets}

We could use angle brackets instead of square brackets, the argument, we suppose, being argument is that \tcode{<>} is more template like and that pack indexing is also template like.
However, most languages have existing practices in which \tcode{[]} is to be used for both indexing and slicing.
Being consistent with existing practice never hurts. %lah: never? 
Besides, pack indexing will often occur in angle-bracket-heavy code, so using brackets for indexing too would not look better.

\subsubsection{Magic function}

\paper{P1803R0} proposed \tcode{packexpr(pack, N)}, i.e., \tcode{reserved-identifier(pack, N)}.
We would need to find an identifier that is meaningful for all types of packs (not just expressions) and is not widely used.
The identifier would most certainly have to be a globally reserved keyword (not a contextual one), as pack indexing can appear anywhere either a type, or an expression can appear, which is everywhere.

Perhaps \tcode{packelement(pack, index)} would work, but we would arguably need another identifier for slicing.

\subsubsection{\tcode{[N]pack...}} % lah: note that here you use code font, but for an earlier section head, you didn't. Pick a method and use that method consistently. Also note that the code font looks much smaller than the header font.  

\paper{P0535R0} explored putting the index before the pack, and this method 
would probably work, although some looking ahead might be necessary to distinguish from lambdas. % lah: to distinguish WHAT from lambdas? 
We see no logic to this choice other than, again, availability. 

\subsubsection{Pack objects}

\paper{P2671R0} proposes a syntax (rather arbitrarily given it's currently unused), to create a \textit{pack object} or, rather, to instruct the compiler to manipulate
a pack without expanding it.
The one motivating use case is for the expansion statement, where that syntax allows us to distinguish \textit{looping} over a tuple versus looping over a pack in a nonambiguous manner.
Other examples, including pack indexing and slicing, look similar but arguably worse using this \textit{pack object} mechanism.

As noted, an expansion statement can be used with a pack using

\begin{colorblock}
    template for (auto elem : std::tuple(ts...)) { ... }
\end{colorblock}


Revzin observes this use is "wasteful," which is true, but a big part of the problem is that a tuple is a much heavier type than it ought to be,
and pack indexing is one of the tools we need to make tuples lighter - along with forwarding references deduction and member packs. % lah: if you mean that you're making tuples and forwarding references reduction and member packs lighter, then leave as is. If you mean that that forwarding references reduction and member packs are also tools, then change to "...one of the tools, along with forwarding references deduction and member packs, that we need to make tuples lighter." 

% lah: a lot of material that is included in the online PDF is missing in this .tex file 

\subsubsection{Something else?}

We could entertain all sorts of syntaxes that are not yet used: two dots, four dots, \tcode{!}, \tcode{@} \$, and so on.
None of them would be a logical extension of the existing grammar, and since we are extending an existing facility, we should aim for something more justified than simply "it's not yet used by something else."

\subsubsection{Too many dots?}

One of the arguments heard against the \tcode{T...[N]} syntax is the "too many dots" argument.
And it's true that code that perform a lot of pack manipulation has numerous dots.
However, the code does make sense and is readable; e.g., see this \href{https://github.com/seanbaxter/circle/blob/master/tuple/tuple.hxx}{linked implementation of tuple}.
A few advantages come along with \tcode{...} for pack expansions. 
\begin{itemize}
\item Seeing at a glance which pattern is expanded and where is useful.
\item The syntax of pack declarations and pack expansion has so far been rather consistent and follows a given pattern. Multiple people % lah: developers? committee members? 
 have come up with the same syntax independently because it's an obvious extension of existing syntax.
\item Using \tcode{...\placeholder{postfix-syntax}} for this feature --- and future pack-related features (and nothing else) --- gives us a clear, reserved design space for packs.
\end{itemize}

\section{Allowable values for the pack index}

The index of a pack indexing expression or specifier is an integral constant expression between 0 and \tcode{sizeof...(pack) - 1}.
Empty packs can't be indexed.

In other proposals, a negative index, \tcode{-N}, would be interpreted as
indexing from the end of the pack --- as an alias of \tcode{T...[sizeof...(T)-N]}.
However, a negative index could occur by accident, yielding surprising results:

\begin{colorblock}
// Return the index of the first type convertible to Needle in Pack
// @\textbf{or -1 if Pack does not contain a suitable type}@.
template <typename Needle, typename... Pack>
auto find_convertible_in_pack;

// If find_convertible_in_pack<Foo, Types> is -1, T will be the last type, erroneously.
using T = Types...[find_convertible_in_pack<Foo, Types>];
\end{colorblock}

In general, incorrect computations in an index can lead to a negative value that should make the program ill formed but would instead
yield an incorrect type.

Note, however, that Circle does support from-the-end indexing using a negative index, and Sean Baxter reports no surprises from using this feature.

An alternative for indexing from the end is to provide a specific syntax; for example, C\# uses \tcode{\^{}} to mean "from the end", and Dlang interprets \tcode{\${}}
as the size of the array:
\begin{colorblock}
using Foo = T...[0];
using Bar = T...[^1]; // first from the end
using Bar = T...[$ - 1]; // first from the end
\end{colorblock}

Given that alternatives are available, all of which can be added later and for which we do not have usage experience, this paper does not propose
from-the-end indexing.

\section{Indexing a pack of types}

Indexing a pack of types is a type specifier that can, like \tcode{decltype}, appear as
\begin{itemize}
    \item a simple-type-specifier
    \item a base class specifier
    \item a nested name specifier
    \item the type of an explicit destructor call
\end{itemize}

\section{Type deduction}

Pack indexing specifiers should not allow deducing the pack from such an expression:

\begin{colorblock}
template <typename... T>
void f(T...[0]);
f(0);
\end{colorblock}

To start thinking about how deduction would work here or what that code would possibly mean doesn't make sense.
We simply always consider pack indexing to be a non-deduced context.

\section{Indexing a pack of expressions}

The intent is that a pack indexing expression behaves exactly as the underlying expression would.
In particular, \tcode{decltype(id-dexpression) and \tcode{decltype(pack-index-expression)}} behave the same.

\section{Future evolution}

The syntax can be extended in subsequent proposals to support

\begin{itemize}
\item indexing packs introduced by structured bindings or other non-dependent packs
\item indexing packs of template template parameters
\item from-the-end-indexing
\item pack slicing (returning a subset of a pack as an unexpanded pack)
\end{itemize}
Packs of universal template parameters could be indexed in the same way.


\section{Potential impact on existing code}

In C++23, \tcode{T... [N]} is a valid syntax for declaring a function parameter matching a pack of unnamed arrays of size N:

\begin{colorblock}
template <typename... T>
void f(T... [1]); //
int main() {
    f<int, double>(nullptr, nullptr); // void f<int, double>(int [1], double [1])
}
\end{colorblock}

Neither MSVC nor GCC supports this syntax and from a search on \href{https://cs.github.com/}{Github}, \href{https://codesearch.isocpp.org/cgi-bin/cgi_ppsearch?q=...%5B&search=Search}{isocpp} and in VCPKG, this pattern does not appear outside of compiler test suites.

Should anyone be affected, a workaround is to name the variable:

\begin{colorblock}
template <typename... T>
void f(T... foo[1]);
\end{colorblock}

See this linked \href{https://godbolt.org/z/T7v3ETz1G}{demonstration}.

\section{Implementation}

This proposal is inspired by features implemented in the Circle compiler (with the same syntax).
The provided wording is based on an implementation in a fork of Clang, which is available on \href{https://compiler-explorer.com/z/WKobTEq6x}{Compiler Explorer}.

As of the writing of the paper, the Clang implementation is known not to support pack indexing inside of the expansion of other template parameters;
i.e., the following code is intended to work but currently does not:

\begin{colorblock}
template <typename... Ts, int... N>
auto f(Ts... ts) {
    return std::tuple{ (ts...[N])... };
}
\end{colorblock}

We hope to fix these issues before the Kona meeting in November.

\section{Formal wording}

\rSec2[basic.lookup.qual]{Qualified name lookup} % lah: 1. look at your PDF online. Your bullet is not displaying properly. Perhaps this isn't a web font or perhaps you're not embedding the fonts properly into your PDF. 2. Set your cross-references within parens, exactly like they appear in the Standard's draft. Inunderstand not wanting to use the section numbers, since it is a draft and they could change, but otherwise try to match the Standard when you're quoting from it. 

\rSec3[basic.lookup.qual.general]{General}

\pnum
\indextext{lookup!qualified name|(}%
\indextext{name!qualified}%
\indextext{qualification!explicit}%
Lookup of an \grammarterm{identifier}
followed by a \tcode{::} scope resolution operator
considers only
namespaces, types, and templates whose specializations are types.
If a name, \grammarterm{template-id}, \added{pack-index-specifier,} or \grammarterm{decltype-specifier}
is followed by a \tcode{::},
it shall designate a namespace, class, enumeration, or dependent type,
and the \tcode{::} is never interpreted as
a complete \grammarterm{nested-name-specifier}.

\rSec2[expr.prim.id]{Names}
\rSec3[expr.prim.id.unqual]{Unqualified names}

\begin{bnf}
    \nontermdef{unqualified-id}\br
    identifier\br
    \added{pack-index-expression}\br
    operator-function-id\br
    conversion-function-id\br
    literal-operator-id\br
    \terminal{\~} type-name\br
    \terminal{\~} decltype-specifier\br
    \added{\terminal{\~} pack-index-specifier}\br
    template-id
\end{bnf}

\pnum
\indextext{identifier}% % lah: Maybe add paragraph numbering. Set the paragraphs *exactly* as they appear in the Standard's draft.
An \grammarterm{identifier} is only
an \grammarterm{id-expression} if it has
been suitably declared \iref{dcl.dcl}
or if it appears as part of a \grammarterm{declarator-id} \iref{dcl.decl}.
An \grammarterm{identifier} that names a coroutine parameter
refers to the copy of the parameter \iref{dcl.fct.def.coroutine}.

\begin{note}
    For \grammarterm{operator-function-id}{s}, see~\ref{over.oper}; for
    \grammarterm{conversion-function-id}{s}, see~\ref{class.conv.fct}; for
    \grammarterm{literal-operator-id}{s}, see~\ref{over.literal}; for
    \grammarterm{template-id}{s}, see~\ref{temp.names}.
    A \grammarterm{type-name}\added{, \grammarterm{pack-index-specifier}, } or \grammarterm{decltype-specifier}
    prefixed by \tcode{\~} denotes the destructor of the type so named;
    see~\ref{expr.prim.id.dtor}.
    Within the definition of a non-static member function, an
    \grammarterm{identifier} that names a non-static member is transformed to a
    class member access expression \iref{class.mfct.non.static}.
\end{note}

\pnum
A \defn{component name} of an \grammarterm{unqualified-id} $U$ is
\begin{itemize}
    \item
    $U$ if it is a name or
    \item
    the component name of
    the \grammarterm{template-id} or \grammarterm{type-name} of $U$, if any.
\end{itemize}

\begin{note}
    Other constructs that contain names to look up can have several
    component names \iref{expr.prim.id.qual, dcl.type.simple, dcl.type.elab,
        dcl.mptr, namespace.udecl, temp.param, temp.names, temp.res}.
\end{note}

The \defnadj{terminal}{name} of a construct is
the component name of that construct that appears lexically last.


\rSec3[expr.prim.id.qual]{Qualified names}

\indextext{operator!scope resolution}%
\indextext{\idxcode{::}|see{operator, scope resolution}}%
%
\begin{bnf}
    \nontermdef{qualified-id}\br
    nested-name-specifier \opt{\keyword{template}} unqualified-id
\end{bnf}

\indextext{operator!scope resolution}%
\indextext{name hiding}%
%
\begin{bnf}
    \nontermdef{nested-name-specifier}\br
    \terminal{::}\br
    type-name \terminal{::}\br
    namespace-name \terminal{::}\br
    decltype-specifier \terminal{::}\br
    \added{pack-index-specifier \terminal{::}}\br
    nested-name-specifier identifier \terminal{::}\br
    nested-name-specifier \opt{\keyword{template}} simple-template-id \terminal{::}
\end{bnf}

\pnum
\indextext{component name}%
The component names of a \grammarterm{qualified-id} are those of
its \grammarterm{nested-name-specifier} and \grammarterm{unqualified-id}.
The component names of a \grammarterm{nested-name-specifier} are
its \grammarterm{identifier} (if any) and those of its
\grammarterm{type-name},
\grammarterm{namespace-name},
\grammarterm{simple-template-id}, and/or
\grammarterm{nested-name-specifier}.

\pnum
A \grammarterm{nested-name-specifier} is \defn{declarative} if it is part of
\begin{itemize}
    \item
    a \grammarterm{class-head-name},
    \item
    an \grammarterm{enum-head-name},
    \item
    a \grammarterm{qualified-id}
    that is the \grammarterm{id-expression} of a \grammarterm{declarator-id}, or
    \item
    a declarative \grammarterm{nested-name-specifier}.
\end{itemize}
A declarative \grammarterm{nested-name-specifier}
shall not have a \grammarterm{decltype-specifier}.
A declaration that uses a declarative \grammarterm{nested-name-specifier}
shall be a friend declaration or
inhabit a scope that contains the entity being redeclared or specialized.

\pnum
The \grammarterm{nested-name-specifier} \tcode{::} nominates
the global namespace.
A \grammarterm{nested-name-specifier} with a \grammarterm{decltype-specifier}
nominates the type denoted by the \grammarterm{decltype-specifier},
which shall be a class or enumeration type.
If a \grammarterm{nested-name-specifier} $N$
is declarative and
has a \grammarterm{simple-template-id} with a template argument list $A$
that involves a template parameter,
let $T$ be the template nominated by $N$ without $A$.
$T$ shall be a class template.
\begin{itemize}
    \item
    {If $A$ is the template argument list \iref{temp.arg} of
    the corresponding \grammarterm{template-head} $H$ \iref{temp.mem},
    $N$ nominates the primary template of $T$;
    $H$ shall be equivalent to
    the \grammarterm{template-head} of $T$ \iref{temp.over.link}.}
    \item
    {Otherwise, $N$ nominates the partial specialization \iref{temp.spec.partial} of $T$
    whose template argument list is equivalent to $A$ \iref{temp.over.link};
    the program is ill-formed if no such partial specialization exists.}
\end{itemize}
Any other \grammarterm{nested-name-specifier} nominates
the entity denoted by its
\grammarterm{type-name},
\grammarterm{namespace-name},
\grammarterm{identifier}, or
\grammarterm{simple-template-id}.
If the \grammarterm{nested-name-specifier} is not declarative,
the entity shall not be a template.

\pnum
A \grammarterm{qualified-id} shall not be of the form\added{s}
\grammarterm{nested-name-specifier} \opt{\keyword{template}} \tcode{\~}
\grammarterm{decltype-specifier}
\changed{nor of the form}{, }
\grammarterm{decltype-specifier} \tcode{::} \tcode{\~} \grammarterm{type-name}
\added{,
\grammarterm{nested-name-specifier} \opt{\keyword{template}} \tcode{\~}
\grammarterm{pack-index-\linebreak[3]specifier}
or \grammarterm{pack-index-specifier} \tcode{::} \tcode{\~} \grammarterm{type-name}
}.

\pnum
The result of a \grammarterm{qualified-id} $Q$ is
the entity it denotes \iref{basic.lookup.qual}.
The type of the expression is the type of the result.
The result is an lvalue if the member is
\begin{itemize}
    \item
    a function other than a non-static member function,
    \item
    a non-static member function
    if $Q$ is the operand of a unary \tcode{\&} operator,
    \item
    a variable,
    \item
    a structured binding \iref{dcl.struct.bind}, or
    \item
    a data member,
\end{itemize}
and a prvalue otherwise.

\begin{addedblock}
\ednote{Add a new section after [expr.prim.id.qual]}

\rSec3[expr.prim.pack.index]{Pack indexing expression}

\begin{bnf}
    \nontermdef{pack-index-expression}\br
    id-expression \terminal{...} \terminal{[} constant-expression \terminal{]}  \br
\end{bnf}

The \grammarterm{id-expression} in a \grammarterm{pack-index-expression} shall denote a pack.

The \grammarterm{constant-expression} shall be an integral constant expression.
The \grammarterm{constant-expression} shall evaluate to a value $V$ such that 0 <= $V$ < \tcode{sizeof...(id-expression)}.

The index of a \grammarterm{pack-index-expression} is the value of its \grammarterm{constant-expression}.

A \grammarterm{pack-index-expression} denotes the ${index}$\textsuperscript{th} expression in a pack ([temp.variadic]).
A \grammarterm{pack-index-expression} is a pack expansion ([temp.variadic]).

\end{addedblock}

\rSec3[dcl.type.simple]{Simple type specifiers}%
\indextext{type specifier!simple}

\pnum
The simple type specifiers are
\begin{bnf}
\nontermdef{simple-type-specifier}\br
\opt{nested-name-specifier} type-name\br
nested-name-specifier \keyword{template} simple-template-id\br\textbf{}
decltype-specifier\br
\added{pack-index-specifier}\br
placeholder-type-specifier\br
\opt{nested-name-specifier} template-name\br
\end{bnf}
\textcolor{noteclr}{[...]}

\begin{simpletypetable}
    {\grammarterm{simple-type-specifier}{s} and the types they specify}
    {dcl.type.simple}
    {ll}
    \topline
    \hdstyle{Specifier(s)}            &   \hdstyle{Type}                  \\ \capsep
    \grammarterm{type-name}           & the type named                    \\
    \grammarterm{simple-template-id}  & the type as defined in [temp.names]\\
    \added{\grammarterm{pack-index-specifier}} & \added{the type as defined in [dcl.type.pack.indexing]} \\
    \grammarterm{decltype-specifier}  & the type as defined in [dcl.type.decltype]\\
    \grammarterm{placeholder-type-specifier}
    & the type as defined in [dcl.spec.auto]\\
    \grammarterm{template-name}       & the type as defined in [dcl.type.class.deduct]\\
    \tcode{char}                      & ``\tcode{char}''                  \\
    \tcode{unsigned char}             & ``\tcode{unsigned char}''         \\
    \tcode{signed char}               & ``\tcode{signed char}''           \\
    \keyword{char8_t}                   & ``\tcode{char8_t}''               \\
    \keyword{char16_t}                  & ``\tcode{char16_t}''              \\
\end{simpletypetable}
% lah: Add ... here to denote that the tables continues, but you're omitting the rest. 

% lah: why have you switched the order of the table and the text that precedes it in the Standard draft? 
\pnum
When multiple \grammarterm{simple-type-specifier}{s} are allowed, they can be
freely intermixed with other \grammarterm{decl-specifier}{s} in any order.
\begin{note}
    It is \impldef{signedness of \tcode{char}} whether objects of \tcode{char} type are
    represented as signed or unsigned quantities. The \tcode{signed} specifier
    forces \tcode{char} objects to be signed; it is redundant in other contexts.
\end{note}


\ednote{Add a new section after [dcl.type.simple]}


\begin{addedblock}

\rSec3[dcl.type.pack.indexing]{Pack indexing specifier}

\begin{bnf}
    \nontermdef{pack-index-specifier}\br
    typedef-name \terminal{...} \terminal{[} constant-expression \terminal{]}  \br
\end{bnf}

The \grammarterm{typedef-name} in a \grammarterm{pack-index-specifier} shall denote a pack.

The \grammarterm{constant-expression} shall be an integral constant expression.
The \grammarterm{constant-expression} shall evaluate to a value $V$ such that 0 <= $V$ < \tcode{sizeof...(typedef-name)}.

The index of a \grammarterm{pack-index-specifier} is the value of its \grammarterm{constant-expression}.

A \grammarterm{pack-index-specifier} denotes the type of the ${index}$\textsuperscript{th} \tcode{typedef-name} in a pack ([temp.variadic]).
A \grammarterm{pack-index-specifier} is a pack expansion ([temp.variadic]).

\end{addedblock}



\rSec3[dcl.type.decltype]{Decltype specifiers}%
\indextext{type specifier!\idxcode{decltype}}%

\begin{bnf}
    \nontermdef{decltype-specifier}\br
    \keyword{decltype} \terminal{(} expression \terminal{)}
\end{bnf}

\pnum
\indextext{type specifier!\idxcode{decltype}}%
For an expression $E$, the type denoted by \tcode{decltype($E$)} is defined as follows:
\begin{itemize}
\item if $E$ is an unparenthesized \grammarterm{id-expression}
naming a structured binding \iref{dcl.struct.bind},
\tcode{decltype($E$)} is the referenced type as given in
the specification of the structured binding declaration;

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression}
naming a non-type \grammarterm{template-parameter} \iref{temp.param},
\tcode{decltype($E$)} is the type of the \grammarterm{template-parameter}
after performing any necessary
type deduction \iref{dcl.spec.auto, dcl.type.class.deduct};

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression} or
an unparenthesized
class
member access \iref{expr.ref}, \tcode{decltype($E$)} is the
type of the entity named by $E$.
If there is no such entity, the program is ill-formed;

\begin{addedblock}
\begin{note}
A \grammarterm{pack-index-expression} is an \grammarterm{id-expression}.
\end{note}
\end{addedblock}

\item otherwise, if $E$ is
an xvalue, \tcode{decltype($E$)} is \tcode{T\&\&}, where \tcode{T} is the type
of $E$;

\item otherwise, if $E$ is an lvalue, \tcode{decltype($E$)}
is \tcode{T\&}, where \tcode{T} is the type of $E$;

\item otherwise, \tcode{decltype($E$)} is the type of $E$.
\end{itemize}

The operand of the \keyword{decltype} specifier is an unevaluated
operand \iref{term.unevaluated.operand}.

\begin{example}
    \begin{codeblock}
        const int&& foo();
        int i;
        struct A { double x; };
        const A* a = new A();
        decltype(foo()) x1 = 17;        // type is \tcode{const int\&\&}
        decltype(i) x2;                 // type is \tcode{int}
        decltype(a->x) x3;              // type is \tcode{double}
        decltype((a->x)) x4 = x3;       // type is \tcode{const double\&}
        \end{codeblock}
        \begin{addedblock}
        \begin{codeblock}
        [](auto... pack){
            decltype(pack...[0])   x5;  // type is \tcode{int}
            decltype((pack...[0])) x6;  // type is \tcode{int\&}
        }(0);
        \end{codeblock}
        \end{addedblock}
\end{example}


\rSec1[class]{Classes}

\rSec2[class.dtor]{Destructors}%


% lah: your \added command is adding a space. There should be no space preceding the added comma, yet there is in your output PDF. 
\pnum
\indextext{destructor!explicit call}%
In an explicit destructor call, the destructor is specified by a
\tcode{\~{}}
followed by a
\grammarterm{type-name}\added{, \grammarterm{pack-index-specifier},} or \grammarterm{decltype-specifier}
that denotes the destructor's class type.
The invocation of a destructor is subject to the usual rules for member
functions \iref{class.mfct};
that is, if the object is not of the destructor's class type and
not of a class derived from the destructor's class type (including when
the destructor is invoked via a null pointer value), the program has
undefined behavior.

\rSec1[class.derived]{Derived classes}%

\rSec2[class.derived.general]{General}%
\indextext{derived class|(}

\indextext{virtual base class|see{base class, virtual}}
\indextext{virtual function|see{function, virtual}}
\indextext{dynamic binding|see{function, virtual}}

\pnum
\indextext{base class}%
\indextext{inheritance}%
\indextext{multiple inheritance}%
A list of base classes can be specified in a class definition using
the notation:

\begin{bnf}
    \nontermdef{base-clause}\br
    \terminal{:} base-specifier-list
\end{bnf}


\begin{bnf}
    \nontermdef{base-specifier-list}\br
    base-specifier \opt{\terminal{...}}\br
    base-specifier-list \terminal{,} base-specifier \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
    \nontermdef{base-specifier}\br
    \opt{attribute-specifier-seq} class-or-decltype\br
    \opt{attribute-specifier-seq} \keyword{virtual} \opt{access-specifier} class-or-decltype\br
    \opt{attribute-specifier-seq} access-specifier \opt{\keyword{virtual}} class-or-decltype
\end{bnf}

\begin{bnf}
    \nontermdef{class-or-decltype}\br
    \opt{nested-name-specifier} type-name\br
    nested-name-specifier \keyword{template} simple-template-id\br
    decltype-specifier\br
    \added{pack-index-specifier}
\end{bnf}

\indextext{specifier access|see{access specifier}}%
%
\begin{bnf}
    \nontermdef{access-specifier}\br
    \keyword{private}\br
    \keyword{protected}\br
    \keyword{public}
\end{bnf}


\rSec1[temp.type]{Type equivalence}

\pnum
If an expression $e$ is type-dependent \iref{temp.dep.expr},
\tcode{decltype($e$)}
denotes a unique dependent type. Two such \grammarterm{decltype-specifier}{s}
refer to the same type only if their \grammarterm{expression}{s} are
equivalent \iref{temp.over.link}.
\begin{note} % lah: Thios note in the Standard draft is label "Note 1", not just "Note".
    However, such a type might be aliased,
    e.g., by a \grammarterm{typedef-name}.
\end{note}

\begin{addedblock}
For a template argument \tcode{T}, if the \grammarterm{constant-expression} of a \grammarterm{pack-index-specifier} is type-dependent,
\tcode{T...[\grammarterm{constant-expression}]} denotes a unique dependent type.
Two such \grammarterm{pack-index-specifier}{s} refer to the same type only if their \grammarterm{constant-expression}{s} are
equivalent \iref{temp.over.link} and their type are the same. %lah: what does the "their" refer to? The pack-index-specifiers or the constant-expressions? Also, we would need to alter this to "their types are the same" or "their type is the same".
\end{addedblock}

\rSec2[temp.variadic]{Variadic templates}

\textcolor{noteclr}{[...]}

\pnum
\indextext{pattern|see{pack expansion, pattern}}%
A \defn{pack expansion}
consists of a \defnx{pattern}{pack expansion!pattern} and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:

\begin{itemize}
    \item In a function parameter pack \iref{dcl.fct}; the pattern is the
    \grammarterm{parameter-declaration} without the ellipsis.

    \item In a \grammarterm{using-declaration} \iref{namespace.udecl};
    the pattern is a \grammarterm{using-declarator}.

    \item In a template parameter pack that is a pack expansion \iref{temp.param}:
    \begin{itemize}
        \item
        if the template parameter pack is a \grammarterm{parameter-declaration};
        the pattern is the \grammarterm{parameter-declaration} without the ellipsis;

        \item
        if the template parameter pack is a \grammarterm{type-parameter};
        the pattern is the corresponding \grammarterm{type-parameter}
        without the ellipsis.
    \end{itemize}

    \item In an \grammarterm{initializer-list} \iref{dcl.init};
    the pattern is an \grammarterm{initializer-clause}.

    \item In a \grammarterm{base-specifier-list} \iref{class.derived};
    the pattern is a \grammarterm{base-specifier}.

    \item In a \grammarterm{mem-initializer-list} \iref{class.base.init} for a
    \grammarterm{mem-initializer} whose \grammarterm{mem-initializer-id} denotes a
    base class; the pattern is the \grammarterm{mem-initializer}.

    \item In a \grammarterm{template-argument-list} \iref{temp.arg};
    the pattern is a \grammarterm{template-argument}.

    \item In an \grammarterm{attribute-list} \iref{dcl.attr.grammar}; the pattern is
    an \grammarterm{attribute}.

    \item In an \grammarterm{alignment-specifier} \iref{dcl.align}; the pattern is
    the \grammarterm{alignment-specifier} without the ellipsis.

    \item In a \grammarterm{capture-list} \iref{expr.prim.lambda.capture}; the pattern is
    the \grammarterm{capture} without the ellipsis.

    \item In a \tcode{sizeof...} expression \iref{expr.sizeof}; the pattern is an
    \grammarterm{identifier}.

    \begin{addedblock}
    \item In a \grammarterm{pack-index-expression}; the pattern is an
    \grammarterm{id-expression}.
    \item In a \grammarterm{pack-index-specifier}; the pattern is an
    \grammarterm{identifier}.
    \end{addedblock}

    \item In a \grammarterm{fold-expression} \iref{expr.prim.fold};
    the pattern is the \grammarterm{cast-expression}
    that contains an unexpanded pack.
\end{itemize}

\begin{example} % lah: this is labeled Example 4 in the Standard's draft. 
    \begin{codeblock}
        template<class ... Types> void f(Types ... rest);
        template<class ... Types> void g(Types ... rest) {
            f(&rest ...);     // ``\tcode{\&rest ...}'' is a pack expansion; ``\tcode{\&rest}'' is its pattern
        }
    \end{codeblock}
\end{example}

\pnum
For the purpose of determining whether a pack satisfies a rule
regarding entities other than packs, the pack is
considered to be the entity that would result from an instantiation of
the pattern in which it appears.

\pnum
A pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more packs that
are not expanded by a nested pack expansion; such packs are called
\defnx{unexpanded packs}{pack!unexpanded} in the pattern. All of the packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a pack that is not expanded is
ill-formed.
\begin{example} % lah: this is labeled Example 5 in the Standard's draft. 
    \begin{codeblock}
        template<typename...> struct Tuple {};
        template<typename T1, typename T2> struct Pair {};

        template<class ... Args1> struct zip {
            template<class ... Args2> struct with {
                typedef Tuple<Pair<Args1, Args2> ... > type;
            };
        };

        typedef zip<short, int>::with<unsigned short, unsigned>::type T1;
        // \tcode{T1} is \tcode{Tuple<Pair<short, unsigned short>, Pair<int, unsigned>>}
        typedef zip<short>::with<unsigned short, unsigned>::type T2;
        // error: different number of arguments specified for \tcode{Args1} and \tcode{Args2}

        template<class ... Args>
        void g(Args ... args) {                   // OK, \tcode{Args} is expanded by the function parameter pack \tcode{args}
            f(const_cast<const Args*>(&args)...);   // OK, ``\tcode{Args}'' and ``\tcode{args}'' are expanded
            f(5 ...);                               // error: pattern does not contain any packs
            f(args);                                // error: pack ``\tcode{args}'' is not expanded
            f(h(args ...) + args ...);              // OK, first ``\tcode{args}'' expanded within \tcode{h},
            // second ``\tcode{args}'' expanded within \tcode{f}
        }
    \end{codeblock}
\end{example}

\pnum
The instantiation of a pack expansion considers
items $\tcode{E}_1, \tcode{E}_2, \dotsc, \tcode{E}_N$,
where
$N$ is the number of elements in the pack expansion parameters.
Each $\tcode{E}_i$ is generated by instantiating the pattern and
replacing each pack expansion parameter with its $i^\text{th}$ element.
Such an element, in the context of the instantiation, is interpreted as
follows:
\begin{itemize}
    \item
    if the pack is a template parameter pack, the element is
    an \grammarterm{id-expression}
    (for a non-type template parameter pack),
    a \grammarterm{typedef-name}
    (for a type template parameter pack declared without \tcode{template}), or
    a \grammarterm{template-name}
    (for a type template parameter pack declared with \tcode{template}),
    designating the $i^\text{th}$ corresponding type or value template argument;

    \item
    if the pack is a function parameter pack, the element is an
    \grammarterm{id-expression}
    designating the $i^\text{th}$ function parameter
    that resulted from instantiation of
    the function parameter pack declaration;
    otherwise

    \item
    if the pack is an \grammarterm{init-capture} pack,
    the element is an \grammarterm{id-expression}
    designating the variable introduced by
    the $i^\text{th}$ \grammarterm{init-capture}
    that resulted from instantiation of
    the \grammarterm{init-capture} pack.
\end{itemize}
When $N$ is zero, the instantiation of a pack expansion
does not alter the syntactic interpretation of the enclosing construct,
even in cases where omitting the pack expansion entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.

\pnum
The instantiation of a \tcode{sizeof...} expression \iref{expr.sizeof} produces
an integral constant with value $N$.

\begin{addedblock}
\pnum

When instantiating a \grammarterm{pack-index-expression} $P$,
let $K$ be the index of $P$.
The instantiation of $P$ is the \grammarterm{id-expression} \tcode{$\mathtt{E}_K$}.


When instantiating a \grammarterm{pack-index-specifier} $P$,
let $K$ be the index of $P$.
The instantiation of $P$ is the \grammarterm{typedef-name} \tcode{$\mathtt{E}_K$}.
\end{addedblock}


\textcolor{noteclr}{[...]}

\rSec3[temp.deduct.type]{Deducing template arguments from a type}


\pnum
The non-deduced contexts are:

\indextext{context!non-deduced}%
\begin{itemize}
    \item
    The
    \grammarterm{nested-name-specifier}
    of a type that was specified using a
    \grammarterm{qualified-id}.
    \begin{addedblock}
    \item A \grammarterm{pack-index-specifier.}
    \end{addedblock}
    \item
    The \grammarterm{expression} of a \grammarterm{decltype-specifier}.
    \item
    A non-type template argument or an array bound in which a subexpression
    references a template parameter.
    \item
    A template parameter used in the parameter type of a function parameter that
    has a default argument that is being used in the call for which argument
    deduction is being done.
    \item
    A function parameter for which the associated argument is an
    overload set \iref{over.over}, and one or more of the following apply:
    \begin{itemize}
        \item
        more than one function matches the function parameter type (resulting in
        an ambiguous deduction), or
        \item
        no function matches the function parameter type, or
        \item
        the overload set supplied as an argument contains one or more function templates.
    \end{itemize}
    \item A function parameter for which the associated argument is an initializer
    list \iref{dcl.init.list} but the parameter does not have
    a type for which deduction from an initializer list is specified \iref{temp.deduct.call}.
    \begin{example}
        \begin{codeblock}
            template<class T> void g(T);
            g({1,2,3});                 // error: no argument deduced for \tcode{T}
        \end{codeblock}
    \end{example}
    \item A function parameter pack that does not occur at the end of the
    \grammarterm{parameter-declaration-list}.
\end{itemize}


\begin{addedblock}

\rSec1[diff.cpp23]{C++ and ISO C++23}

\rSec2[diff.cpp23.dcl.dcl]{Declarations}

\rSec3[decl.array]
\change
Previously, \tcode{T...[$n$]} would declare a pack of function parameters of type "array of \tcode{T} of size \tcode{$n$}".
\tcode{T...[$n$]} is now a \grammarterm{pack-index-specifier}.
\rationale
Improve the handling of packs.
\effect
Valid C++23 code that declares % lah: a? the? 
pack of arrays parameter without specifying a \tcode{declarator-id} may become ill-formed.

\begin{codeblock}
template <typename... T>
void f(T... [1]);
template <typename... T>
void g(T... ptr[1]);

int main() {
    f<int, double>(nullptr, nullptr); // ill-formed, previously void f<int, double>(int [1], double [1])
    g<int, double>(nullptr, nullptr); // ok
}
\end{codeblock}

\begin{colorblock}

\end{colorblock}

\end{addedblock}

\section{Feature test macros}

\ednote{Add a new macro in \tcode{[tab:cpp.predefined.ft]} : \tcode{__cpp_pack_indexing} set to the date of adoption}.


\section{Acknowledgments}

We would like to thank Bloomberg for sponsoring this work.\\

We extend our appreciate to Sean Baxter for his work on Circle and to Barry Revzin  for his work on \paper{P1858R2}, both works being the foundation of the design presented here.

Thanks also to Lewis Baker for his valuable feedback on this paper.

\section{References} % lah: Correct your citation style. Books, proceedings, conference names, and Standards use italics. Articles, presentations, and talks use quotes. Harvard style is the general UK convention. https://intranet.birmingham.ac.uk/as/libraryservices/library/referencing/icite/harvard/referencelist.aspx

\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[P2632R0]{P2632R0}
Corentin Jabot, Pablo Halpern, John Lakos, Alisdair Meredith, Joshua Berne, and Gašper Ažman\newline
\emph{A plan for better template meta programming facilities in C++26}\newline
\url{https://wg21.link/P2632R0}\newline
October 2022

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}

\end{document}
