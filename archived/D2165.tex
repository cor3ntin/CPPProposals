% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}

\title{Compatibility between \tcode{tuple}, \tcode{pair} and \placeholder{tuple-like} objects}
\docnumber{P2165R4}
\audience{LEWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle

\paperquote{A tuple by any other name would unpack just as well - Shakespair}

\section{Abstract}

We propose to make \tcode{pair} constructible from \tcode{tuple} and \tcode{std::array}
We mandate \tcode{tuple_cat} and friends to be compatible with these types,
and associative containers more compatible with them.
The changes proposed in this paper make the use of std::pair unnecessary in new code.

\section{Revisions}

\subsection{R4}

The following changes where made following LWG small group review (June 14th 2022)

\begin{itemize}
\item Remove the comparison between pair and tuple-like as they were insufficient to satisfay equality_comparible as a common_reference isn't specialized for a pair and a tuple-like.
\item Remove the changes to support use_allocator construction which the group agreed were not needed.
\item Modify the definition of \tcode{tuple-like} to support \tcode{std::get} implementations returning prvalues, such as \tcode{subrange}.
\item Simplify the wording of the added tuple constructor.
\item Constrain the added \tcode{tuple} constructor, and the \tcode{tuple} assignement operators from tuple-like to types that are not exactly the same \tcode{tuple}.
\item Constrain the \tcode{pair} assignement operators from tuple-like to types that are not exactly the same \tcode{pair}.
\item Rewrite the \tcode{tuple_cat} wording to be clearer (Thanks Tomasz!)
\item Fix a number of typos, errors and formatting issues.
\end{itemize}

The following changes where made following LWG review (June 24th 2022)

\begin{itemize}
\item Rewrite \tcode{tuple-like} to explicity state only \tcode{pair}, \tcode{tuple}, \tcode{array}.
\item Mark the return type of the new \tcode{operator<=>} "see below" in the synopsis.
\item The description of the new \tcode{operator<=>} in \tcode{<tuple>} was referring to a non-existing pack. Add wording to introduce that pack.
\item \tcode{tuple_element_t} and \tcode{tuple_size_v} were sometimes used on reference types. Add \tcode{remove_cvref_t}.
\item \tcode{common_type} still had extraneous template parameters.
\item Constrain \tcode{common_type} and \tcode{basic_common_reference} of \tcode{tuple-like} to require
non cvref qualified types and \tcode{tuple-like} of the same size.
\item The new \tcode{tuple} constructor still had some unecessary wording referencing a non existing Ui.
Remove that wording.
\item Fix the effects of \tcode{tuple::operator=(tuple-like)}.
\item \tcode{std::get} was inconsistently qualified. As the existing wording uses it unqualied,
remove the qualifications.
\item In the description of \tcode{tuple_cat}, \tcode{remove_cvref_t} instead of  \tcode{remove_reference_t},
for consistency.
\end{itemize}

The following changes where made following LWG small group review (June 28th 2022)

\begin{itemize}
\item Fix notation in the description of \tcode{tuple_cat}.
\item Replace "Preconditions" by "Mandates" in the description of \tcode{tuple_cat}.
\item Reorder constraints in \tcode{basic_common_reference} and \tcode{common_type}
\item Remove \tcode{FWD} in the tuple constructor (only used once)
\item Fix a couple of typos and formatting issue
\item Remove an extraneous \tcode{>} in [associative.general]
\item Add references to \placeholder{different-from}
\item In \tcode{operator==(tuple, tuple)}, the statements that two empty tuples compare equal is now a note.
\end{itemize}

The following changes where made following LWG review (July 8th 2022)

\begin{itemize}
\item The \tcode{tuple-like} concept now models \textbf{and satisfies} its requirements.
\item Reword the introduction of TTypes/Utypes in [tuple.common_ref].
\item Reorder the constraints in [tuple.common_ref].
\item Use the wording "The member \grammarterm{typedef-name} \tcode{type}..." in [tuple.common_ref].
\item Missing period in \tcode{tuple_cat}
\item In \tcode{tuple_cat}, introduce $n$ first and don't use range notation.

\end{itemize}

\subsection{R3}
\begin{itemize}
\item Reduce the scope to types that have a \tcode{get} method in the \tcode{std::} namespace.
In effect only \tcode{tuple}, \tcode{pair}, \tcode{array} and \tcode{ranges::subrange} are \tcode{tuple-like}
with that definition.
The intent is to extend to user-provided types later once \tcode{std::get} or equivalent is defined as a customization-point.
Limiting to \tcode{std::get} allows to unconditionally use \tcode{std::tuple} as the reference type of \tcode{zip}, \tcode{cartesian_product} in C++23.
\item Rebase the wording onto the latest draft, which contains significant changes (const assignment operators).
\item Add the wording modification to zip.
\item Remove the modification to associative containers, with the intent to add these constructors in a later version of C++.
\item Conserve the existing tuple and pair constructors, assignment, and comparison operators. The proposed changes to tuple and pair are now additions exclusively. This is both because implementers cannot remove them because of ABI, and because the proposed constructors are not foud for classes that inherit publicly from pair or tuple. This removes some concern for breaking changes.
\item Add an overload to \tcode{uses_allocator_construction_args}.
\item Add a feature test macro.
\item Fix the tuple-like concept to support reference types.
\end{itemize}

\subsection{R2}

The scope and design have changed quite a bit since R1. First, R1 failed to account for most tuple-like things like \tcode{array}.
Second, R2 also modifies associative containers to accept tuple-like objects.

\subsection{R1}
\begin{itemize}
    \item The wording in R0 was non-sensical
    \item Add a note on deduction guide
    \item Modify \tcode{tuple_cat} to unconditionally support \tcode{tuple-like} entities.
\end{itemize}

\pagebreak

\section{Tony tables}
\begin{center}
\begin{tabular}{l|l}
Before & After\\ \hline

\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}

constexpr std::pair  p {1, 3.0};
constexpr std::tuple t {p}; // OK

std::pair<int, double> pp
             (get<0>(t), get<1>(t));

static_assert(std::tuple(p) == t);

static_assert(@\textcolor{red}{p == t}@);
static_assert(@\textcolor{red}{p <=> t == 0}@);

@\textcolor{red}{std::tuple<int,int> t = std::array \{1, 2\};}@


static_assert(same_as<std::tuple<int>,
    range_value_t<decltype(views::zip(v))>>);

static_assert(same_as<std::pair<int,int>,
    range_value_t<decltype(views::zip(v, v))>>);


// x is std::tuple<int, int>
// because tuple is convertible from pair
auto x = true ? tuple{0,0} : pair{0,0};


\end{colorblock}
\end{minipage}
&
\begin{minipage}[t]{0.5\textwidth}
\begin{colorblock}

constexpr std::pair  p {1, 3.0};
constexpr std::tuple t {p}; // OK

std::pair<int, double> pp{t};


static_assert(std::tuple(p) == t);

static_assert(p == t);
static_assert(p <=> t == 0);

std::tuple<int,int> t = std::array {1, 2};

// not the same size: ill-formed
@\textcolor{red}{std::tuple<int> t = std::array \{1, 2\};}@


static_assert(<std::tuple<int>,
    range_value_t<decltype(views::zip(v))>>);

static_assert(same_as<std::tuple<int,int>,
    range_value_t<decltype(views::zip(v, v))>>);




// Both types are interconvertible,
// The expression is ambiguous an this is ill-formed
@\textcolor{red}{auto x = true ?  tuple\{0,0\} : pair\{0,0\};}@

\end{colorblock}
\end{minipage}
\\\\ \hline

\end{tabular}
\end{center}

\textcolor{red}{Red text is ill-formed}

\section{Motivation}

\tcode{pair}s are platonic tuples of 2 elements. \tcode{pair} and \tcode{tuple} share
most of their interface.

Notably, a tuple can be constructed and assigned from a pair, but the reverse is not true.
Tuple and pairs cannot be compared.

Having both types in the standard library is somewhat redundant - as noted in \paper{N2270} - a problem that \paper{N2533}
tried to address before C++, alas unsuccessfully.

We are not proposing to get rid of \tcode{pair}.
However, we are suggesting that maybe new facilities should use \tcode{tuple}, or when appropriate, a structure with named members.
The authors of \paper{N2270}, circa 2007, observed:

\begin{quoteblock}
There is very little reason, other than history, for the library to contain both \tcode{pair<T, U>} and \tcode{tuple<T, U>}. If we do deprecate pair, then we should change all interfaces in the library that use it, including the associative containers, to use \tcode{tuple} instead. This will be a source-incompatible change, but it need not be ABI-breaking.
\end{quoteblock}

As \tcode{pair} will continue to exist, it should still be possible for users of the standard library to ignore its existence, which can be achieved by making sure pairs are constructible from \tcode{tuple}, and types that are currently constructible from \tcode{pair} can be constructed from another kind of \tcode{tuple}.

For example, associative containers deal in pairs, and they do not allow construction from sequences of tuples. This has forced ranges (\tcode{zip}: \paper{P2321R1}, \tcode{carthesian_product}: \paper{P2374R0}) to deal in \tcode{pair} when dealing with tuples of 2 elements.

\tcode{view_of_tuples | to<map>} currently doesn't work, and we think it should.

%Lastly, while there is support for \tcode{enumerate} to have a reference type with named members, there is also a desire
%that \tcode{enumerate(container) | to<map>} should work.
%In general, it is ridiculously hard and costly to make simple structs that can be used as reference types of ranges.
%With the proposed changes, any named type that implements the tuple protocol shares a common reference with the corresponding tuple if the members themselves have a common reference.

%As such, only
%\begin{itemize}
%\item \tcode{tuple_element}
%\item \tcode{tuple_size}
%\item \tcode{get}
%\end{itemize}
%
%need to be provided for a range's reference's type to be any type, as long as the value type is a tuple.
%
%This paper takes care of providing a \tcode{basic_common_reference} and a \tcode{basic_common_type}
%between \tcode{tuple} and tuple-like entities.
%\paper{P1858R2} and \paper{P1096R0} explores ways to simplify further the tuple protocol.
%
Standard types supporting the tuple protocol include

\begin{itemize}
\item \tcode{pair}
\item \tcode{tuple}
\item \tcode{array}
\item \tcode{subrange}
\item the proposed \tcode{enumerate}'s \tcode{reference} type.
\item \tcode{span} of static extent- \textbf{prior to \paper{P2116R0} which removed that support}
\end{itemize}

%\subsection{C arrays and aggregate}
%
%C arrays and aggregate are supported by structured bindings, but this mechanism does not use the tuple protocol.
%As such, these types will not be convertible to \tcode{tuple} with this paper.


\section{Design}

We introduce an exposition only concept \tcode{tuple-like} which can then be used in the definition of \tcode{tuple} and \tcode{pair} construction,
comparison and assignment operators.
A type satisfies \tcode{\placeholder{tuple-like}} if it implements the tuple protocol (\tcode{std::get, std::tuple_element, std::tuple_size}).
The concept is a generalization of the \placeholder{pair-like} exposition-only concept used by \tcode{subrange} and \tcode{views::values}/\tcode{views::keys}.

With that concept, we

\begin{itemize}
    \item Allow a \tcode{tuple} to be constructed, assigned and compared with any standard tuple-like object (of the same size).
    \item Allow a \tcode{pair} to be constructed, assigned and compared with any standard tuple-like object of size 2.
    \item Can use \tcode{tuple} in \tcode{zip} and similar views consistently, in the 2 views case.
    \item Define a \tcode{common_reference} and a \tcode{common_type} between \tcode{std::tuple} and any \tcode{tuple-like} object. This simplifies using a custom tuple-like type in a zip-like view. \textbf{This change is only necessary in C++23}
    if we want to addopt the design of \tcode{enumerate} as proposed by \paper{P2164R5}.
\end{itemize}

In comparisons, one of the 2 objects has to be a \tcode{tuple}, or a \tcode{pair}. This is done so that comparison operators can be made hidden friends in order to avoid enormous overload sets.

We also make \tcode{tuple_cat} support any \tcode{\placeholder{tuple-like}} parameter.
This is conditionally supported by implementations already.

\tcode{std::apply} and \tcode{std::make_from_tuple} are similarly constrained. There is currently non stated constraints on these functions but
types that do not satisfy \tcode{tuple-like} do not satisfy the implicit requirements of implementations.
Constraining them improves diagnostic quality.

Associative containers are already specified to be usable with elements convertible to their
\tcode{value_type}, so all constructors and methods can be used with \tcode{tuple-like}, except those taking an
\tcode{initializer_list} as parameter. Changes to \tcode{initializer_list}  are not proposed in this revision of this paper as it is not strictly necessary to be done in 23. It could be considered as a future extension.


\subsection{\tcode{std::get}}

I was initially under the misguided impression that get was designed to be found by unqualified lookup, which it is not.
We do not have time to research and specify a CPO forget - which would probably require additional changes to the language (structured binding) and the library.
As such, this paper offers the minimal changes necessary to make the standard types inter-compatible, with the express purpose to
be able to use tuple in \tcode{zip} and \tcode{cartesian_product}.

\begin{note}
Because implementations should always called std::get qualified, it is not a potentially-breaking change to constrain the previously unconstrained \tcode{apply}, \tcode{tuple_cat} and \tcode{make_from_tuple}
functions.
\end{note}


\subsection{CTAD issues}

A previous version of this paper modified the deduction guides to use the tuple-like constructors for tuple-like objects.

But this would change the meaning of \tcode{tuple \{array<int, 2>\{\}\}}.
The current version does not add or modify deduction guides.
As such, \tcode{tuple \{boost::tuple<int, int>\{\}\}} is deduced as \tcode{std::tuple<boost::tuple<int, int>>}

This is obviously not ideal, but, it is a pre-exising problem in C++20. \tcode{tuple {pair<int, int> {}} } is currently deduced to \tcode{std::tuple<int, int>},
while other tuple-like objects T are deduced as \tcode{std::tuple<T>}, which may be surprising.
This is the same problem that all deduction guides involving wrapper types, and may require a more comprehensive fix, for example:

\begin{colorblock}
tuple {pair, pair } // ok
tuple {pair} // ill-formed / deprecated
tuple {std::of_value, pair }  // tuple<pair<foo, bar>>
tuple {std::of_elems, pair }  // tuple<foo, bar>
\end{colorblock}

While we could add a non-ambiguous guide for pair, we think it's better for \tcode{pair} and \tcode{tuple} to remain consistent.

\textbf{We do not propose modifications to CTAD constructors}



\subsection{Open Questions}

\subsubsection{pair const assignement}

\tcode{zip} added const assignement operators and to both \tcode{tuple} and \tcode{pair} for the benefits of views, which use tuple and pair as proxy types.
With the present proposal, \tcode{pair} is no longer used by ranges. Do we want to keep its added assignment operators?


\subsection{\textcolor{Red}{Breaking API changes}}

\subsubsection{Ternary operator ambiguities}

Before this paper, \tcode{tuple} was constructible from \tcode{pair},
but the opposite was not true.

As such \tcode{expr ? apair : atuple} would resolve unambiguously to a tuple.

Because this changes makes both \tcode{pair} and \tcode{tuple} constructible from each other,
the expression is now ambiguous.

This proposal is, therefore, a breaking change.
However, it is unlikely that this pattern exists in practice.
It can be resolved by casting either expression to the type of the other.

Similar expressions such as \tcode{true ? std::tuple\{0.\} : std::tuple\{0\}} are ill-formed in C++20 because they are ambiguous.

\subsubsection{The lying tuple also converting to std::tuple}

Consider the following example, courtesy of Tomasz Kamiński and Barry Revzin.

\begin{colorblock}
    struct M {
        operator tuple<int, int>() const { return {1, 1}; }
    };

    namespace std {
        template <> struct tuple_size<M> : integral_constant<size_t, 2> { };
        template <int I> struct tuple_element<I, M> { using type = int; };
        template <int I> auto get(M) { return 2; }
    }
\end{colorblock}

In C++20, \tcode{std::tuple<int, int>\{M\}} would be equal to \tcode{std::tuple<int, int>\{1, 1\}};

With the current proposal, the tuple-like constructor is a better match than the conversion operator, and
\tcode{std::tuple<int, int>\{M\}} would be equal to \tcode{std::tuple<int, int>\{2, 2\}};

As the conversion is not called, side effects that this operator might have (ex: logging) - are not executed.
Another scenario may be that the conversion operator would return a tuple with different element types than \tcode{get}/\tcode{tuple_element_t}.

And while there exists types that are both convertible to \tcode{std::tuple} and \tcode{tuple-like} - like ranges-v3's \tcode{compressed_pair},
We do not think the case of types that would do different things when the conversion operator is called rather than the proposed \tcode{tuple-like}
std::tuple constructor is worth considering

\begin{itemize}
    \item Checking the presence of an operator \tcode{tuple<tuple_element_t<Index>...>} is costly.
    \item Checking the presence of an arbitrary conversion operator a tuple can be constructed from is not possible
    \item We make no promise not to add overloads.
    \item It is UB for users to add std::get overloads
\end{itemize}

But, if this was a problem, we could provide an opt-out mechanism such as

\begin{colorblock}
    template<class>
    inline constexpr bool disable_tuple-like = false; // user specializable
\end{colorblock}

There is precedence for that (\tcode{ranges::disable_sized_range}), but this is not proposed in this paper,
as we think the potential for breakage is theoretical.

\subsection{Implementation}

This proposal has been fully implemented in libstdc++ \href{https://github.com/cor3ntin/gcc/tree/tuple_pair2}{[Github]},
such that all existing tests pass, and new changes have been tested by the author. (The proposed changes to \tcode{zip} have not been made)

\begin{note}
And implementation can and probably should short-circuit the \tcode{tuple-like} concept-checking for known standard tuple-like types.
\end{note}

\section{Future work}

This proposal does not explore a way to make \tcode{std::get} a customization point, our main goal being to get rid of \tcode{tuple-or-pair} for 23.
This requires future exploration. Tuple comparison operators are good candidates for hidden friends.

\subsection{Possible associative containers modifications}

A previous version of this paper proposed to modify \tcode{\{unordered\char`_\}\{multi\}map} so that
they could be constructed from an \tcode{initializer_list} of \tcode{tuple-like}.
These changes were, however, broken and are not necessary for C++23. I, therefore, elected to remove them from the paper.
However, associative containers are already specified to be usable with elements convertible to their
\tcode{value_type}, so all constructors and methods can be used with \tcode{tuple-like}, except those taking an
\tcode{initializer_list} as parameter.

\section{Wording}


\subsection{Feature test macros}

\ednote{
Add a new macro in \tcode{<version>} \tcode{__cpp_lib_tuple_like} set to the date of adoption.
The macro \tcode{__cpp_lib_tuple_like} is also present in
<utility>, <tuple>, <map>, <unordered_map>
}


\rSec2[tuple.syn]{Header \tcode{<tuple>} synopsis}
\begin{codeblock}
#include <compare>              // see \ref{compare.syn}

namespace std {
// \ref{tuple.tuple}, class template \tcode{tuple}
template<class... Types>
class tuple;

\end{codeblock}
\begin{addedblock}

%template <typename T, size_t N>
%concept  @\placeholder{is-tuple-element}@ = requires (T t) {  // \expos
%    typename tuple_element_t<N, T>;
%    { @\textbf{std::}@get<N>(t) } -> convertible_to<const tuple_element_t<N, T>&>;
%};
%
%template <typename T>
%concept @\placeholder{tuple-like-impl}@ // \expos
%= requires  {
%    typename tuple_size<T>::type;
%} && []<size_t... I>(index_sequence<I...>)
%{ return (@\placeholder{is-tuple-element}@<T, I> && ...); }(make_index_sequence<tuple_size_v<T>>{});


\begin{codeblock}

template <typename T>
concept @\placeholder{tuple-like}@ =  @\seebelow@; // \expos

template <typename T>
concept @\placeholder{pair-like}@ // \expos
    = @\placeholder{tuple-like}@<T> && tuple_size_v<remove_cvref_t<T>> == 2;


\end{codeblock}
\end{addedblock}


\begin{removedblock}
\begin{codeblock}
template<class... TTypes, class... UTypes, template<class> class TQual>
requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
    using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
};

template<class... TTypes, class... UTypes>
requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
struct common_type<tuple<TTypes...>, tuple<UTypes...>> {
    using type = tuple<common_type_t<TTypes, UTypes>...>;
};
\end{codeblock}
\end{removedblock}

\begin{addedblock}
\begin{codeblock}
template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
struct basic_common_reference<TTuple, UTuple, TQual, UQual>;

template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple>
struct common_type<TTuple, UTuple>;
\end{codeblock}
\end{addedblock}
\begin{codeblock}

// \ref{tuple.creation}, tuple creation functions
inline constexpr @\unspec@ ignore;

template<class... TTypes>
constexpr tuple<unwrap_ref_decay_t<TTypes>...> make_tuple(TTypes&&...);

template<class... TTypes>
constexpr tuple<TTypes&&...> forward_as_tuple(TTypes&&...) noexcept;

template<class... TTypes>
constexpr tuple<TTypes&...> tie(TTypes&...) noexcept;

template<@\changed{class}{\placeholder{tuple-like}}@... Tuples>
constexpr tuple<CTypes...> tuple_cat(Tuples&&...);

// \ref{tuple.apply}, calling a function with a tuple of arguments
template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
constexpr decltype(auto) apply(F&& f, Tuple&& t);

template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
constexpr T make_from_tuple(Tuple&& t);

// \ref{tuple.helper}, tuple helper classes
template<class T> struct tuple_size;                  // \notdef
template<class T> struct tuple_size<const T>;

template<class... Types> struct tuple_size<tuple<Types...>>;

template<size_t I, class T> struct tuple_element;     // \notdef
template<size_t I, class T> struct tuple_element<I, const T>;

template<size_t I, class... Types>
struct tuple_element<I, tuple<Types...>>;

template<size_t I, class T>
using tuple_element_t = typename tuple_element<I, T>::type;

// \ref{tuple.elem}, element access
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>& get(tuple<Types...>&) noexcept;
template<size_t I, class... Types>
constexpr tuple_element_t<I, tuple<Types...>>&& get(tuple<Types...>&&) noexcept;
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>& get(const tuple<Types...>&) noexcept;
template<size_t I, class... Types>
constexpr const tuple_element_t<I, tuple<Types...>>&& get(const tuple<Types...>&&) noexcept;
template<class T, class... Types>
constexpr T& get(tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr T&& get(tuple<Types...>&& t) noexcept;
template<class T, class... Types>
constexpr const T& get(const tuple<Types...>& t) noexcept;
template<class T, class... Types>
constexpr const T&& get(const tuple<Types...>&& t) noexcept;

// [tuple.rel], relational operators
template<class... TTypes, class... UTypes>
constexpr bool operator==(const tuple<TTypes...>&, const tuple<UTypes...>&);\end{codeblock}
\begin{addedblock}
\begin{codeblock}
template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr bool operator==(const tuple<TTypes...>&, const UTuple&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}

template<class... TTypes, class... UTypes>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, UTypes...>>
operator<=>(const tuple<TTypes...>&, const tuple<UTypes...>&);\end{codeblock}
\begin{addedblock}
\begin{codeblock}

template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr @\seebelow@ operator<=>(const tuple<TTypes...>&, const UTuple&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}

// \ref{tuple.traits}, allocator-related traits
template<class... Types, class Alloc>
struct uses_allocator<tuple<Types...>, Alloc>;

// \ref{tuple.special}, specialized algorithms
template<class... Types>
constexpr void swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(@\seebelow@);
template<class... Types>
constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(@\seebelow@);

// \ref{tuple.helper}, tuple helper classes
template<class T>
inline constexpr size_t tuple_size_v = tuple_size<T>::value;
}
\end{codeblock}

\begin{addedblock}


\rSec2[tuple.like]{Concept \placeholder{tuple-like}}

\begin{itemdecl}
template <typename T>
concept @\placeholder{tuple-like}@ =  @\seebelow@; // \expos
\end{itemdecl}

\begin{itemdescr}
A type \tcode{T} models and satisfies the exposition-only concept \placeholder{tuple-like} if \tcode{std::remove_cvref_t<T>} is
a specialization of \tcode{array}, \tcode{pair}, \tcode{tuple} or \tcode{ranges::subrange}.
\end{itemdescr}




\end{addedblock}

\rSec2[tuple.tuple]{Class template \tcode{tuple}}
\indexlibraryglobal{tuple}%

\begin{codeblock}
namespace std {
template<class... Types>
class tuple {
    public:
    // \ref{tuple.cnstr}, \tcode{tuple} construction
    constexpr explicit(@\seebelow@) tuple();
    constexpr explicit(@\seebelow@) tuple(const Types&...); // only if \tcode{sizeof...(Types) >= 1}
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(UTypes&&...); // only if \tcode{sizeof...(Types) >= 1}

    tuple(const tuple&) = default;
    tuple(tuple&&) = default;

    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(tuple<UTypes...>&);
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(const tuple<UTypes...>&);
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(tuple<UTypes...>&&);
    template<class... UTypes>
    constexpr explicit(@\seebelow@) tuple(const tuple<UTypes...>&&);

    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(pair<U1, U2>&);  // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>&); // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(pair<U1, U2>&&);   // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>&&); // only if \tcode{sizeof...(Types) == 2}
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(UTuple&&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    // allocator-extended constructors
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a);
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);
\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<class Alloc, @\placeholder{tuple-like}@ UTuple>
    constexpr explicit(@\seebelow@) tuple(allocator_arg_t, const Alloc& a, UTuple&&);
\end{codeblock}
\end{addedblock}
\begin{codeblock}
    // \ref{tuple.assign}, \tcode{tuple} assignment
    constexpr tuple& operator=(const tuple&);
    constexpr const tuple& operator=(const tuple&) const;
    constexpr tuple& operator=(tuple&&) noexcept(@\seebelow@);
    constexpr const tuple& operator=(tuple&&) const;

    template<class... UTypes>
    constexpr tuple& operator=(const tuple<UTypes...>&);
    template<class... UTypes>
    constexpr const tuple& operator=(const tuple<UTypes...>&) const;
    template<class... UTypes>
    constexpr tuple& operator=(tuple<UTypes...>&&);
    template<class... UTypes>
    constexpr const tuple& operator=(tuple<UTypes...>&&) const;

    template<class U1, class U2>
    constexpr tuple& operator=(const pair<U1, U2>&);          // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr const tuple& operator=(const pair<U1, U2>&) const;
    // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr tuple& operator=(pair<U1, U2>&&);               // only if \tcode{sizeof...(Types) == 2}
    template<class U1, class U2>
    constexpr const tuple& operator=(pair<U1, U2>&&) const;   // only if \tcode{sizeof...(Types) == 2}

\end{codeblock}
\begin{addedblock}
\begin{codeblock}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr tuple& operator=(UTuple&&);
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr const tuple& operator=(UTuple&&) const;
\end{codeblock}
\end{addedblock}
\begin{codeblock}

    // \ref{tuple.swap}, \tcode{tuple} swap
    constexpr void swap(tuple&) noexcept(@\seebelow@);
    constexpr void swap(const tuple&) const noexcept(@\seebelow@);
};

template<class... UTypes>
tuple(UTypes...) -> tuple<UTypes...>;
template<class T1, class T2>
tuple(pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, UTypes...) -> tuple<UTypes...>;
template<class Alloc, class T1, class T2>
tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;
template<class Alloc, class... UTypes>
tuple(allocator_arg_t, Alloc, tuple<UTypes...>) -> tuple<UTypes...>;
}
\end{codeblock}

\rSec3[tuple.cnstr]{Construction}

\pnum
In the descriptions that follow, let $i$ be in the range
\range{0}{sizeof...(Types)} in order, $\tcode{T}_i$
be the $i^\text{th}$ type in \tcode{Types}, and
$\tcode{U}_i$ be the $i^\text{th}$ type in a template parameter pack named \tcode{UTypes}, where indexing
is zero-based.

[...]

\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(pair<U1, U2>& u);
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>& u);
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(pair<U1, U2>&& u);
    template<class U1, class U2> constexpr explicit(@\seebelow@) tuple(const pair<U1, U2>&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    Let \tcode{\exposid{FWD}(u)} be \tcode{static_cast<decltype(u)>(u)}.

    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} is 2,
        \item
        \tcode{is_constructible_v<$\tcode{T}_0$, decltype(get<0>(\exposid{FWD}(u)))>} is \tcode{true}, and
        \item
        \tcode{is_constructible_v<$\tcode{T}_1$, decltype(get<1>(\exposid{FWD}(u)))>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes the first element with \tcode{get<0>(\exposid{FWD}(u))} and
    the second element with \tcode{get<1>(\exposid{FWD}(\brk{}u))}.

    \pnum
    \remarks
    The expression inside \tcode{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<decltype(get<0>(@\exposid{FWD}@(u))), @$\tcode{T}_0$@> ||
        !is_convertible_v<decltype(get<1>(@\exposid{FWD}@(u))), @$\tcode{T}_1$@>
    \end{codeblock}
\end{itemdescr}

\begin{addedblock}
\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple> constexpr explicit(@\seebelow@) tuple(UTuple&& u);
\end{itemdecl}

\begin{itemdescr}
\pnum
Let \tcode{I} be the pack \tcode{0, 1, ..., (sizeof...(Types) - 1)}.\newline

\pnum
\constraints
\begin{itemize}
    \item \tcode{\placeholder{different-from}<UTuple, tuple>} [range.utility.helpers] is \tcode{true},
    \item \tcode{remove_cvref_t<UTuple>} is not a specialization of \tcode{ranges::subrange},
    \item
    \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<remove_cvref_t<UTuple>>},
    \item
    \tcode{(is_constructible_v<Types, decltype(get<I>(std::forward<UTuple>(u)))> \&\& ...)}
    is \tcode{true}, and
    \item
    either \tcode{sizeof...(Types)} is not 1, or
    (when \tcode{Types...} expands to \tcode{T})
    \tcode{is_convertible_v<UTuple, T>},
    \tcode{is_constructible_v<T, UTuple>} are both \tcode{false}.
\end{itemize}

\pnum
\effects
For all $i$, initializes the $i^\textrm{th}$ element of \tcode{*this}
with \tcode{get<$i$>(std::forward<UTuple>(u))}.

\pnum
\remarks
The expression inside \keyword{explicit} is equivalent to:
\begin{codeblock}
    !(is_convertible_v<decltype(get<I>(std::forward<UTuple>(u))), Types> && ...)
\end{codeblock}
\end{itemdescr}
\end{addedblock}

\indexlibraryctor{tuple}%
\begin{itemdecl}
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a);
    template<class Alloc>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const Types&...);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, UTypes&&...);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, const tuple&);
    template<class Alloc>
    constexpr tuple(allocator_arg_t, const Alloc& a, tuple&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&&);
    template<class Alloc, class... UTypes>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);
    template<class Alloc, class U1, class U2>
    constexpr explicit(@\seebelow@)
    tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);
    @\added{template<class Alloc, \placeholder{tuple-like} UTuple>}@
    @\added{constexpr explicit(\seebelow) tuple(allocator_arg_t, const Alloc\& a, UTuple\&\&);}@
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \expects
    \tcode{Alloc} meets the
    \oldconcept{Allocator} requirements (\tref{cpp17.allocator}).

    \pnum
    \effects
    Equivalent to the preceding constructors except that each element is constructed with
    uses-allocator construction\iref{allocator.uses.construction}.
\end{itemdescr}

\rSec3[tuple.assign]{Assignment}

\pnum
For each \tcode{tuple} assignment operator, an exception is thrown only if the
assignment of one of the types in \tcode{Types} throws an exception.
In the function descriptions that follow, let $i$ be in the range \range{0}{sizeof...\brk{}(Types)}
in order, $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Types},
and $\tcode{U}_i$ be the $i^\text{th}$ type in a
template parameter pack named \tcode{UTypes}, where indexing is zero-based.


\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    constexpr tuple& operator=(const tuple& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \effects
    Assigns each element of \tcode{u} to the corresponding
    element of \tcode{*this}.

    \pnum
    \returns
    \tcode{*this}.

    \pnum
    \remarks
    This operator is defined as deleted unless
    \tcode{is_copy_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
\end{itemdescr}

[...]

%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    constexpr const tuple& operator=(const tuple& u) const;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \tcode{(is_copy_assignable_v<const Types> \&\& ...)} is \tcode{true}.
%
%    \pnum
%    \effects
%    Assigns each element of \tcode{u} to the corresponding element of \tcode{*this}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}
%
%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    constexpr tuple& operator=(tuple&& u) noexcept(@\seebelow@);
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \tcode{is_move_assignable_v<$\tcode{T}_i$>} is \tcode{true} for all $i$.
%
%    \pnum
%    \effects
%    For all $i$, assigns \tcode{std::forward<$\tcode{T}_i$>(get<$i$>(u))} to
%    \tcode{get<$i$>(*this)}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%
%    \pnum
%    \remarks
%    The exception specification is equivalent to the logical \tcode{AND} of the
%    following expressions:
%
%    \begin{codeblock}
%        is_nothrow_move_assignable_v<@$\mathtt{T}_i$@>
%    \end{codeblock}
%    where $\mathtt{T}_i$ is the $i^\text{th}$ type in \tcode{Types}.
%\end{itemdescr}

%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    constexpr const tuple& operator=(tuple&& u) const;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \tcode{(is_assignable_v<const Types\&, Types> \&\& ...)} is \tcode{true}.
%
%    \pnum
%    \effects
%    For all $i$,
%    assigns \tcode{std::forward<T$_i$>(get<$i$>(u))} to \tcode{get<$i$>(*this)}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}
%
%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    template<class... UTypes> constexpr tuple& operator=(const tuple<UTypes...>& u);
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
%        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, const $\tcode{U}_i$\&>} is \tcode{true} for all $i$.
%    \end{itemize}
%
%    \pnum
%    \effects
%    Assigns each element of \tcode{u} to the corresponding element
%    of \tcode{*this}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}

%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    template<class... UTypes> constexpr const tuple& operator=(const tuple<UTypes...>& u) const;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item
%        \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
%        \item
%        \tcode{(is_assignable_v<const Types\&, const UTypes\&> \&\& ...)} is \tcode{true}.
%    \end{itemize}
%
%    \pnum
%    \effects
%    Assigns each element of \tcode{u} to the corresponding element of \tcode{*this}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}

%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    template<class... UTypes> constexpr tuple& operator=(tuple<UTypes...>&& u);
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
%        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, $\tcode{U}_i$>} is \tcode{true} for all $i$.
%    \end{itemize}
%
%    \pnum
%    \effects
%    For all $i$, assigns \tcode{std::forward<$\tcode{U}_i$>(get<$i$>(u))} to
%    \tcode{get<$i$>(*this)}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}

%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    template<class... UTypes> constexpr const tuple& operator=(tuple<UTypes...>&& u) const;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item
%        \tcode{sizeof...(Types)} equals \tcode{sizeof...(UTypes)} and
%        \item
%        \tcode{(is_assignable_v<const Types\&, UTypes> \&\& ...)} is \tcode{true}.
%    \end{itemize}
%
%    \pnum
%    \effects
%    For all $i$,
%    assigns \tcode{std::forward<U$_i$>(get<$i$>(u))} to \tcode{get<$i$>(*this)}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}

%\indexlibrarymember{operator=}{tuple}%
%\indexlibraryglobal{pair}%
%\begin{itemdecl}
%    template<class U1, class U2> constexpr tuple& operator=(const pair<U1, U2>& u);
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item \tcode{sizeof...(Types)} is 2 and
%        \item \tcode{is_assignable_v<$\tcode{T}_0$\&, const U1\&>} is \tcode{true}, and
%        \item \tcode{is_assignable_v<$\tcode{T}_1$\&, const U2\&>} is \tcode{true}.
%    \end{itemize}
%
%    \pnum
%    \effects
%    Assigns \tcode{u.first} to the first element of \tcode{*this}
%    and \tcode{u.second} to the second element of \tcode{*this}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}

%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    template<class U1, class U2> constexpr const tuple& operator=(const pair<U1, U2>& u) const;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item
%        \tcode{sizeof...(Types)} is 2,
%        \item
%        \tcode{is_assignable_v<const $\tcode{T}_0$\&, const U1\&>} is \tcode{true}, and
%        \item
%        \tcode{is_assignable_v<const $\tcode{T}_1$\&, const U2\&>} is \tcode{true}.
%    \end{itemize}
%
%    \pnum
%    \effects
%    Assigns \tcode{u.first} to the first element and
%    \tcode{u.second} to the second element.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}

%\indexlibrarymember{operator=}{tuple}%
%\indexlibraryglobal{pair}%
%\begin{itemdecl}
%    template<class U1, class U2> constexpr tuple& operator=(pair<U1, U2>&& u);
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item \tcode{sizeof...(Types)} is 2 and
%        \item \tcode{is_assignable_v<$\tcode{T}_0$\&, U1>} is \tcode{true}, and
%        \item \tcode{is_assignable_v<$\tcode{T}_1$\&, U2>} is \tcode{true}.
%    \end{itemize}
%
%    \pnum
%    \effects
%    Assigns \tcode{std::forward<U1>(u.first)} to the first
%    element of \tcode{*this} and\\ \tcode{std::forward<U2>(u.second)} to the
%    second element of \tcode{*this}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<class U1, class U2> constexpr const tuple& operator=(pair<U1, U2>&& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{sizeof...(Types)} is 2,
        \item
        \tcode{is_assignable_v<const $\tcode{T}_0$\&, U1>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<const $\tcode{T}_1$\&, U2>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Assigns \tcode{std::forward<U1>(u.first)} to the first element and\\
    \tcode{std::forward<U2>(u.second)} to the second element.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\begin{addedblock}
%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    template<@\placeholder{tuple-like}@ UTuple>
%    constexpr tuple& operator=(const UTuple& u);
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<UTuple>} and
%        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, const std::element_t<$i$, UTuple>\&>} is \tcode{true} for all $i$.
%    \end{itemize}
%
%    \pnum
%    \effects
%    Assigns each element of \tcode{u} to the corresponding element
%    of \tcode{*this}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}
%
%\indexlibrarymember{operator=}{tuple}%
%\begin{itemdecl}
%    template<@\placeholder{tuple-like}@ UTuple>
%    constexpr const tuple& operator=(const UTuple& u) const;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \begin{itemize}
%        \item
%        \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<UTuple>} and
%        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, const element_t<$i$, UTuple>\&>} is \tcode{true} for all $i$.
%    \end{itemize}
%
%    \pnum
%    \effects
%    Assigns each element of \tcode{u} to the corresponding element of \tcode{*this}.
%
%    \pnum
%    \returns
%    \tcode{*this}.
%\end{itemdescr}
%
%\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr tuple& operator=(UTuple&& u);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{\placeholder{different-from}<UTuple, tuple>} [range.utility.helpers] is \tcode{true},
        \item \tcode{remove_cvref_t<UTuple>} is not a specialization of \tcode{ranges::subrange},
        \item \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<remove_cvref_t<UTuple>>} and,
        \item \tcode{is_assignable_v<$\tcode{T}_i$\&, decltype(get<$i$>(std::forward<UTuple>(u)))>} is \tcode{true} for all $i$.
    \end{itemize}

    \pnum
    \effects
    For all $i$, assigns \tcode{get<$i$>(std::forward<UTuple>(u))} to
    \tcode{get<$i$>(*this)}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator=}{tuple}%
\begin{itemdecl}
    template<@\placeholder{tuple-like}@ UTuple>
    constexpr const tuple& operator=(UTuple&& u) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{\placeholder{different-from}<UTuple, tuple>} [range.utility.helpers] is \tcode{true},
        \item \tcode{remove_cvref_t<UTuple>} is not a specialization of \tcode{ranges::subrange},
        \item
        \tcode{sizeof...(Types)} equals \tcode{tuple_size_v<remove_cvref_t<UTuple>>} and,
        \item \tcode{is_assignable_v<const $\tcode{T}_i$\&, decltype(get<$i$>(std::forward<UTuple>(u)))>} is \tcode{true} for all $i$.
    \end{itemize}

    \pnum
    \effects
    For all $i$,
    assigns \tcode{get<$i$>(std::forward<UTuple>(u))} to \tcode{get<$i$>(*this)}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}
\end{addedblock}


\rSec2[tuple.creation]{Tuple creation functions}

\ednote{Modify the definition of \tcode{tuple_cat} as follow in 22.4.4}

\indexlibraryglobal{tuple_cat}
\begin{itemdecl}
    template<@\changed{class}{\placeholder{tuple-like}}@... Tuples>
    constexpr tuple<CTypes...> tuple_cat(Tuples&&... tpls);
\end{itemdecl}

\begin{itemdescr}  % NOCHECK: order
    \pnum
    \begin{addedblock}
    % Constructs a \tcode{tuple} that is a concatenation of all \placeholder{tuple-like} in \tcode{tpls}.

    Let $n$ be \tcode{sizeof...(Tuples)}.

    For every integer $0$ ≤ $i$ < $n$:
        \begin{itemize}
         \item Let $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Tuples}.
         \item Let $\tcode{U}_i$ be \tcode{remove_cvref_t<$\tcode{T}_i$>}
         \item Let $\tcode{tp}_i$ be the $i^\text{th}$ element in the function parameter pack \tcode{tpls}.
         \item Let $S_i$ be \tcode{tuple_size_v<U$_i$>}.
         \item Let $E_i^k$ be \tcode{tuple_element_t<$k$, U$_i$>}.
         \item Let $e_i^k$ be \tcode{get<$k$>(std::forward<$\tcode{T}_i$>($\tcode{tp}_i$))}.
         \item Let $Elems_i$ be a pack of the types $E_i^0, \cdots,  E_i^{S_i-1}$.
         \item Let $elems_i$ be a pack of the expressions $e_i^0, \cdots,  e_i^{S_i-1}$.
     \end{itemize}

    The types in \tcode{CTypes} are equal to the ordered
    sequence of the expanded packs of types \\
    $Elems_0\tcode{...} , Elems_1\tcode{...} , \cdots , Elems_{n-1}\tcode{...}$.

    Let \tcode{celems} be the ordered sequence of the expanded packs of expressions $elems_0..., \cdots, elems_{n-1}...$.

\mandates \tcode{(is_constructible_v<CTypes, decltype(celems)> \&\& ...)} is \tcode{true}.

\returns
    \tcode{tuple<CTypes...>(celems...)}.
    \end{addedblock}
    \begin{removedblock}



    In the following paragraphs, let $\tcode{T}_i$ be the $i^\text{th}$ type in \tcode{Tuples},
    $\tcode{U}_i$ be \tcode{remove_reference_t<T$_i$>}, and $\tcode{tp}_i$ be the $i^\text{th}$
    parameter in the function parameter pack \tcode{tpls}, where all indexing is
    zero-based.

    \pnum
    \expects
    For all $i$, $\tcode{U}_i$ is the type
    $\cv_i$ \tcode{tuple<$\tcode{Args}_i$...>}, where $\cv_i$ is the (possibly empty) $i^\text{th}$
    \grammarterm{cv-qualifier-seq} and $\tcode{Args}_i$ is the template parameter pack representing the element
    types in $\tcode{U}_i$. Let $\tcode{A}_{ik}$ be the ${k}^\text{th}$ type in $\tcode{Args}_i$. For all
    $\tcode{A}_{ik}$ the following requirements are met:


    \begin{itemize}
        \item If $\tcode{T}_i$ is deduced as an lvalue reference type, then
        \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&> == true}, otherwise
        \item \tcode{is_constructible_v<$\tcode{A}_{ik}$, $\cv{}_i\;\tcode{A}_{ik}$\&\&> == true}.
    \end{itemize}

    \pnum
    \remarks
    The types in \tcode{CTypes} are equal to the ordered
    sequence of the extended types
    \tcode{$\tcode{Args}_0$..., $\tcode{Args}_1$..., $\dotsc$, $\tcode{Args}_{n-1}$...},
    where $n$ is
    equal to \tcode{sizeof...(Tuples)}. Let \tcode{$\tcode{e}_i$...} be the $i^\text{th}$
    ordered sequence of tuple elements of the resulting \tcode{tuple} object
    corresponding to the type sequence $\tcode{Args}_i$.

    \pnum
    \returns
    A \tcode{tuple} object constructed by initializing the ${k_i}^\text{th}$
    type element $\tcode{e}_{ik}$ in \tcode{$\tcode{e}_i$...} with
    \begin{codeblock}
        get<@$k_i$@>(std::forward<@$\tcode{T}_i$@>(@$\tcode{tp}_i$@))
    \end{codeblock}
    for each valid $k_i$ and each group $\tcode{e}_i$ in order.

    \begin{note}
        An implementation can support additional types in the template parameter
        pack \tcode{Tuples} that support the \tcode{tuple}-like protocol, such as
        \tcode{pair} and \tcode{array}.
    \end{note}

    \end{removedblock}


\end{itemdescr}



\rSec2[tuple.apply]{Calling a function with a \tcode{tuple} of arguments}

\indexlibraryglobal{apply}%
\begin{itemdecl}
    template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
    constexpr decltype(auto) apply(F&& f, Tuple&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
namespace std {
    template<class F, @\changed{class}{\placeholder{tuple-like}}@ Tuple, size_t... I>
    constexpr decltype(auto) @\placeholdernc{apply-impl}@(F&& f, Tuple&& t, index_sequence<I...>) {
        // \expos
        return @\placeholdernc{INVOKE}@(std::forward<F>(f), get<I>(std::forward<Tuple>(t))...);     // see \ref{func.require}
    }
}
\end{codeblock}
Equivalent to:
\begin{codeblock}
    return @\placeholdernc{apply-impl}@(std::forward<F>(f), std::forward<Tuple>(t),
    make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\end{itemdescr}

\indexlibraryglobal{make_from_tuple}%
\begin{itemdecl}
    template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple>
    constexpr T make_from_tuple(@\changed{class}{\placeholder{tuple-like}}@&& t);
\end{itemdecl}

\begin{itemdescr}
\pnum
\effects
Given the exposition-only function:
\begin{codeblock}
namespace std {
    template<class T, @\changed{class}{\placeholder{tuple-like}}@ Tuple, size_t... I>
    requires is_constructible_v<T, decltype(get<I>(declval<Tuple>()))...>
    constexpr T @\placeholdernc{make-from-tuple-impl}@(Tuple&& t, index_sequence<I...>) {   // \expos
        return T(get<I>(std::forward<Tuple>(t))...);
    }
}
\end{codeblock}
Equivalent to:
\begin{codeblock}
    return @\placeholdernc{make-from-tuple-impl}@<T>(
    std::forward<Tuple>(t),
    make_index_sequence<tuple_size_v<remove_reference_t<Tuple>>>{});
\end{codeblock}
\begin{note}
    The type of \tcode{T} must be supplied
    as an explicit template parameter,
    as it cannot be deduced from the argument list.
\end{note}
\end{itemdescr}

\rSec2[tuple.rel]{Relational operators}

\indexlibrarymember{operator==}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
constexpr bool operator==(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr bool operator==(const tuple<TTypes...>& t, const UTuple& u);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
    \added{For the first overload let \tcode{UTuple} be \tcode{tuple<UTypes...>}.}

    \pnum
    \mandates
    For all \tcode{i},
    where $0 \leq \tcode{i} < \tcode{sizeof...(TTypes)}$,
    \tcode{get<i>(t) == get<i>(u)} is a valid expression
    returning a type that is convertible to \tcode{bool}.
    \tcode{sizeof...(TTypes)} equals
    \tcode{\changed{sizeof...(UTypes)}{tuple_size_v<UTuple>}}.

    \pnum
    \returns
    \tcode{true} if \tcode{get<i>(t) == get<i>(u)} for all
    \tcode{i}, otherwise \tcode{false}.
    \added{[Note:}
    \changed{For any two zero-length tuples \tcode{e} and \tcode{f}, \tcode{e == f}}{If \tcode{sizeof...(TTypes)} equals zero,} returns \tcode{true}.
    \added{]}

    \pnum
    \remarks
    The elementary comparisons are performed in order from the
    zeroth index upwards.  No comparisons or element accesses are
    performed after the first equality comparison that evaluates to
    \tcode{false}.

    \begin{addedblock}
    \remarks The second overload is to be found via argument-dependent lookup only.
    \end{addedblock}

\end{itemdescr}

\indexlibrarymember{operator<=>}{tuple}%
\begin{itemdecl}
template<class... TTypes, class... UTypes>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, UTypes>...>
operator<=>(const tuple<TTypes...>& t, const tuple<UTypes...>& u);
\end{itemdecl}
\begin{addedblock}
\begin{itemdecl}
template<class... TTypes, @\placeholder{tuple-like}@ UTuple>
constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<TTypes, Elems>...>
operator<=>(const tuple<TTypes...>& t, const UTuple& u);
\end{itemdecl}
\end{addedblock}

\begin{itemdescr}

    \begin{addedblock}
        For the second overload, \tcode{Elems} denotes the pack of types \tcode{tuple_element_t<0, UTuple>, tuple_element_t<1, UTuple>, ...,
        tuple_element_t<tuple_size_v<UTuple> -1, UTuple>}.
    \end{addedblock}

    \pnum
    \effects
    Performs a lexicographical comparison between \tcode{t} and \tcode{u}.
    \changed{For any two zero-length tuples \tcode{t} and \tcode{u},
    \tcode{t <=> u}}{If \tcode{sizeof...(TTypes)} equals zero,} returns \tcode{strong_ordering::equal}.
    Otherwise, equivalent to:
    \begin{codeblock}
        if (auto c = @\placeholder{synth-three-way}@(get<0>(t), get<0>(u)); c != 0) return c;
        return @$\tcode{t}_\mathrm{tail}$@ <=> @$\tcode{u}_\mathrm{tail}$@;
    \end{codeblock}
    where $\tcode{r}_\mathrm{tail}$ for some \removed{tuple} \tcode{r}
    is a tuple containing all but the first element of \tcode{r}.

    \begin{addedblock}
        \remarks The second overload is to be found via argument-dependent lookup only.
    \end{addedblock}
\end{itemdescr}


\pnum
\begin{note}
    The above definition does not require \tcode{t$_{\mathrm{tail}}$}
    (or \tcode{u$_{\mathrm{tail}}$}) to be constructed. It might not
    even be possible, as \tcode{t} and \tcode{u} are not required to be copy
    constructible. Also, all comparison operator functions are short circuited;
    they do not perform element accesses beyond what is required to determine the
    result of the comparison.
\end{note}


\begin{addedblock}
\rSec2[tuple.common_ref]{common_reference specialization}

\begin{addedblock}
    In the descriptions that follow:
    \begin{itemize}
        \item Let \tcode{TTypes} be a pack formed by the sequence of \tcode{tuple\char`_element\char`_t<$i$, TTuple>} for every integer $0$ ≤ $i$ < \tcode{tuple\char`_size\char`_v<TTuple>}.
        \item Let \tcode{UTypes} be a pack formed by the sequence of \tcode{tuple\char`_element\char`_t<$i$, UTuple>} for every integer $0$ ≤ $i$ < \tcode{tuple\char`_size\char`_v<UTuple>}.
    \end{itemize}


    %Let $\tcode{T}_i$ be the type denoted by \tcode{tuple\char`_element\char`_t<$i$, TTuple>} of a template parameter named \tcode{TTuple} satisfying \placeholder{tuple-like}. \tcode{TTypes} denotes a pack formed by the sequence of $\tcode{T}_i$.

    %Let $\tcode{U}_i$ be the type denoted by \tcode{tuple\char`_element\char`_t<$i$, UTuple>} of a template parameter named \tcode{UTuple} satisfying \placeholder{tuple-like}. \tcode{UTypes} denotes a pack formed by the sequence of $\tcode{U}_i$.
\end{addedblock}

\begin{itemdecl}
template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple, template<class> class TQual, template<class> class UQual>
struct basic_common_reference<TTuple, UTuple, TQual, UQual> {
    using type = @\seebelow@;
};
\end{itemdecl}

\begin{itemdescr}
\constraints
\begin{itemize}
    \item \tcode{TTuple} is a specialization of \tcode{tuple} or \tcode{UTuple} is a specialization of \tcode{tuple}.
    \item \tcode{is_same_v<TTuple, decay_t<TTuple>>} is \tcode{true}.
    \item \tcode{is_same_v<UTuple, decay_t<UTuple>>} is \tcode{true}.
    \item \tcode{tuple_size_v<TTuple>} equals \tcode{tuple_size_v<UTuple>}.
    \item \tcode{tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>} denotes a type.
\end{itemize}

The member \grammarterm{typedef-name} \tcode{type} denotes the type \tcode{tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>}.

\end{itemdescr}

\begin{itemdecl}
template<@\placeholder{tuple-like}@ TTuple, @\placeholder{tuple-like}@ UTuple>
struct common_type<TTuple, UTuple> {
    using type = @\seebelow@;
};
\end{itemdecl}
\begin{itemdescr}

\constraints
\begin{itemize}
    \item \tcode{TTuple} is a specialization of \tcode{tuple} or \tcode{UTuple} is a specialization of \tcode{tuple}.
    % add a constraint for the size
    \item \tcode{is_same_v<TTuple, decay_t<TTuple>>} is \tcode{true}.
    \item \tcode{is_same_v<UTuple, decay_t<UTuple>>} is \tcode{true}.
    \item \tcode{tuple_size_v<TTuple>} equals \tcode{tuple_size_v<UTuple>}.
    \item \tcode{tuple<common_type_t<TTypes, UTypes>...>} denotes a type.

\end{itemize}

The member \grammarterm{typedef-name} \tcode{type} denotes the type \tcode{tuple<common_type_t<TTypes, UTypes>...>}.

\end{itemdescr}
\end{addedblock}


\rSec1[pairs]{Pairs}

\rSec2[pairs.general]{In general}

\pnum
The library provides a template for heterogeneous pairs of values.
The library also provides a matching function template to simplify
their construction and several templates that provide access to \tcode{pair}
objects as if they were \tcode{tuple} objects (see~\ref{tuple.helper}
and~\ref{tuple.elem}).%
\indexlibraryglobal{pair}%
\indextext{\idxcode{pair}!tuple interface to}%
\indextext{\idxcode{tuple}!and pair@and \tcode{pair}}%

\rSec2[pairs.pair]{Class template \tcode{pair}}

\indexlibraryglobal{pair}%
\begin{codeblock}
namespace std {
    template<class T1, class T2>
    struct pair {
        using first_type  = T1;
        using second_type = T2;

        T1 first;
        T2 second;

        pair(const pair&) = default;
        pair(pair&&) = default;
        constexpr explicit(@\seebelow@) pair();
        constexpr explicit(@\seebelow@) pair(const T1& x, const T2& y);
        template<class U1 = T1, class U2 = T2>
        constexpr explicit(@\seebelow@) pair(U1&& x, U2&& y);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(pair<U1, U2>& p);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(const pair<U1, U2>& p);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(pair<U1, U2>&& p);
        template<class U1, class U2>
        constexpr explicit(@\seebelow@) pair(const pair<U1, U2>&& p);\end{codeblock}
        \begin{addedblock}
        \begin{codeblock}
        template<@\placeholder{pair-like}@ P>
        constexpr explicit(@\seebelow@) pair(P&& p);
        \end{codeblock}
        \end{addedblock}
        \begin{codeblock}
        template<class... Args1, class... Args2>
        constexpr pair(piecewise_construct_t,
        tuple<Args1...> first_args, tuple<Args2...> second_args);

        constexpr pair& operator=(const pair& p);
        constexpr const pair& operator=(const pair& p) const;
        template<class U1, class U2>
        constexpr pair& operator=(const pair<U1, U2>& p);
        template<class U1, class U2>
        constexpr const pair& operator=(const pair<U1, U2>& p) const;
        constexpr pair& operator=(pair&& p) noexcept(@\seebelow@);
        constexpr const pair& operator=(pair&& p) const;
        template<class U1, class U2>
        constexpr pair& operator=(pair<U1, U2>&& p);
        template<class U1, class U2>
        constexpr const pair& operator=(pair<U1, U2>&& p) const;\end{codeblock}
        \begin{addedblock}
        \begin{codeblock}
        template<@\placeholder{pair-like}@ P>
        constexpr pair& operator=(P&& p);
        template<@\placeholder{pair-like}@ P>
        constexpr const pair& operator=(P&& p) const;
        \end{codeblock}
        \end{addedblock}
        \begin{codeblock}
        constexpr void swap(pair& p) noexcept(@\seebelow@);
        constexpr void swap(const pair& p) const noexcept(@\seebelow@);
    };

    template<class T1, class T2>
    pair(T1, T2) -> pair<T1, T2>;
}
\end{codeblock}

\pnum
Constructors and member functions of \tcode{pair} do not throw exceptions unless one of
the element-wise operations specified to be called for that operation
throws an exception.

\pnum
The defaulted move and copy constructor, respectively, of \tcode{pair}
is a constexpr function if and only if all required element-wise
initializations for move and copy, respectively, would satisfy the
requirements for a constexpr function.

\pnum
If \tcode{(is_trivially_destructible_v<T1> \&\& is_trivially_destructible_v<T2>)}
is \tcode{true}, then the destructor of \tcode{pair} is trivial.

\pnum
\tcode{pair<T, U>} is a structural type\iref{temp.param}
if \tcode{T} and \tcode{U} are both structural types.
Two values \tcode{p1} and \tcode{p2} of type \tcode{pair<T, U>}
are template-argument-equivalent\iref{temp.type} if and only if
\tcode{p1.first} and \tcode{p2.first} are template-argument-equivalent and
\tcode{p1.second} and \tcode{p2.second} are template-argument-equivalent.

\indexlibraryctor{pair}%
\begin{itemdecl}
    constexpr explicit(@\seebelow@) pair();
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_default_constructible_v<T1>} is \tcode{true} and
        \item \tcode{is_default_constructible_v<T2>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Value-initializes \tcode{first} and \tcode{second}.

    \pnum
    \remarks
    The expression inside \keyword{explicit} evaluates to \tcode{true}
    if and only if either \tcode{T1} or
    \tcode{T2} is not implicitly default-constructible.
    \begin{note}
        This behavior can be implemented with a trait that checks
        whether a \tcode{const T1\&} or a \tcode{const T2\&}
        can be initialized with \tcode{\{\}}.
    \end{note}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    constexpr explicit(@\seebelow@) pair(const T1& x, const T2& y);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_copy_constructible_v<T1>} is \tcode{true} and
        \item \tcode{is_copy_constructible_v<T2>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes \tcode{first} with \tcode{x} and \tcode{second} with \tcode{y}.

    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<const T1&, T1> || !is_convertible_v<const T2&, T2>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<class U1 = T1, class U2 = T2> constexpr explicit(@\seebelow@) pair(U1&& x, U2&& y);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{is_constructible_v<T1, U1>} is \tcode{true} and
        \item \tcode{is_constructible_v<T2, U2>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes \tcode{first} with
    \tcode{std::forward<U1>(x)} and \tcode{second}
    with \tcode{std::forward<U2>(y)}.

    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<U1, T1> || !is_convertible_v<U2, T2>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(pair<U1, U2>& p);
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(const pair<U1, U2>& p);
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(pair<U1, U2>&& p);
    template<class U1, class U2> constexpr explicit(@\seebelow@) pair(const pair<U1, U2>&& p); \end{itemdecl}\begin{addedblock}\begin{itemdecl}
    template<@\placeholder{pair-like}@ P> constexpr explicit(@\seebelow@) pair(P&& p);\end{itemdecl}
\end{addedblock}

\begin{itemdescr}
    \pnum
    Let \tcode{\exposid{FWD}(u)} be \tcode{static_cast<decltype(u)>(u)}.

    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{is_constructible_v<T1, decltype(get<0>(\exposid{FWD}(p)))>}
        is \tcode{true} and
        \item
        \tcode{is_constructible_v<T2, decltype(get<1>(\exposid{FWD}(p)))>}
        is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes \tcode{first} with \tcode{get<0>(\exposid{FWD}(p))} and
    \tcode{second} with \tcode{get<1>(\exposid{FWD}(p))}.

    \pnum
    \remarks
    The expression inside \keyword{explicit} is equivalent to:
    \begin{codeblock}
        !is_convertible_v<decltype(get<0>(@\exposid{FWD}@(p))), T1> ||
        !is_convertible_v<decltype(get<1>(@\exposid{FWD}@(p))), T2>
    \end{codeblock}
\end{itemdescr}

\indexlibraryctor{pair}%
\begin{itemdecl}
    template<class... Args1, class... Args2>
    constexpr pair(piecewise_construct_t,
    tuple<Args1...> first_args, tuple<Args2...> second_args);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \mandates
    \begin{itemize}
        \item \tcode{is_constructible_v<T1, Args1...>} is \tcode{true} and
        \item \tcode{is_constructible_v<T2, Args2...>} is \tcode{true}.
    \end{itemize}

    \pnum
    \effects
    Initializes \tcode{first} with arguments of types
    \tcode{Args1...} obtained by forwarding the elements of \tcode{first_args}
    and initializes \tcode{second} with arguments of types \tcode{Args2...}
    obtained by forwarding the elements of \tcode{second_args}. (Here, forwarding
    an element \tcode{x} of type \tcode{U} within a \tcode{tuple} object means calling
    \tcode{get(x)}.) This form of construction, whereby constructor
    arguments for \tcode{first} and \tcode{second} are each provided in a separate
    \tcode{tuple} object, is called \defn{piecewise construction}.
\end{itemdescr}

[...]

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item
        \tcode{is_assignable_v<const T1\&, U1>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<const T2\&, U2>} is \tcode{true}.
    \end{itemize}
`
    \effects
    Assigns \tcode{std::forward<U1>(p.first)} to \tcode{first} and
    \tcode{std::forward<U2>(u.second)} to \tcode{second}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\begin{addedblock}

\indexlibrarymember{operator=}{pair}%

\begin{itemdecl}
    template<@\placeholder{pair-like}@ P> constexpr pair& operator=(P&& p);
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{\placeholder{different-from}<P, pair>} [range.utility.helpers] is \tcode{true},
        \item \tcode{remove_cvref_t<P>} is not a specialization of \tcode{ranges::subrange},
        \item
        \tcode{is_assignable_v<T1\&, decltype(get<0>(std::forward<P>(p)))>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<T2\&, decltype(get<1>(std::forward<P>(p)))>} is \tcode{true}.
    \end{itemize}

    \effects
    Assigns \tcode{get<0>(std::forward<P>(p))} to \tcode{first}\\ and
    \tcode{get<1>(std::forward<P>(p))} to \tcode{second}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}

\begin{itemdecl}
    template<@\placeholder{pair-like}@ P> constexpr const pair& operator=(P&& p) const;
\end{itemdecl}

\begin{itemdescr}
    \pnum
    \constraints
    \begin{itemize}
        \item \tcode{\placeholder{different-from}<P, pair>} is \tcode{true},
        \item \tcode{remove_cvref_t<P>} is not a specialization of \tcode{ranges::subrange},
        \item
        \tcode{is_assignable_v<const T1\&, decltype(get<0>(std::forward<P>(p)))>} is \tcode{true}, and
        \item
        \tcode{is_assignable_v<const T2\&, decltype(get<1>(std::forward<P>(p)))>} is \tcode{true}.
    \end{itemize}

    \effects
    Assigns \tcode{get<0>(std::forward<P>>(p))} to \tcode{first}\\ and
    \tcode{get<1>(std::forward<P>(p))} to \tcode{second}.

    \pnum
    \returns
    \tcode{*this}.
\end{itemdescr}
\end{addedblock}


%\rSec2[pairs.spec]{Specialized algorithms}
%
%
%\indexlibrarymember{operator==}{pair}%
%\begin{itemdecl}
%template<class T1, class T2>
%constexpr bool operator==(const pair<T1, T2>& x, const pair<T1, T2>& y);
%\end{itemdecl}
%\begin{addedblock}
%\begin{itemdecl}
%template<class T1, class T2, @\placeholder{pair-like}@ Pair>
%requires same_as<T1, tuple_element_t<0, Pair>> && same_as<T2, tuple_element_t<1, Pair>
%constexpr bool operator==(const pair<T1, T2>& x, const Pair& y);
%\end{itemdecl}
%\end{addedblock}
%
%\begin{itemdescr}
%    \pnum
%    \returns
%    \tcode{x.first == \changed{y.first}{get<0>(y)} \&\& x.second == \changed{y.second}{get<1>(y)}}.
%\end{itemdescr}
%
%\indexlibrarymember{operator<=>}{pair}%
%\begin{itemdecl}
%template<class T1, class T2>
%constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<T1>, @\placeholder{synth-three-way-result}@<T2>>
%operator<=>(const pair<T1, T2>& x, const pair<T1, T2>& y);
%\end{itemdecl}
%\begin{addedblock}
%\begin{itemdecl}
%template<class T1, class T2, @\placeholder{pair-like}@ Pair>
%requires same_as<T1, tuple_element_t<0, Pair>> && same_as<T2, tuple_element_t<1, Pair>
%constexpr common_comparison_category_t<@\placeholder{synth-three-way-result}@<T1>, @\placeholder{synth-three-way-result}@<T2>>
%operator<=>(const pair<T1, T2>& x, const Pair& y);
%\end{itemdecl}
%\end{addedblock}
%
%\begin{itemdescr}
%    \pnum
%    \effects
%    Equivalent to:
%    \begin{codeblock}
%        if (auto c = @\placeholdernc{synth-three-way}@(x.first, @\changed{y.first}{get<0>(y)}@); c != 0) return c;
%        return @\placeholdernc{synth-three-way}@(x.second, @\changed{y.second}{get<1>(y)}@);
%    \end{codeblock}
%\end{itemdescr}


%\rSec1[memory]{Memory}
%
%\rSec2[memory.general]{In general}
%
%\pnum
%Subclause~\ref{memory} describes the contents of the header
%
%\rSec2[memory.syn]{Header \tcode{<memory>} synopsis}
%
%\begin{codeblock}
%    namespace std {
%
%        // \ref{allocator.uses.construction}, uses-allocator construction
%        template<class T, class Alloc, class... Args>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%        Args&&... args) noexcept;
%        template<class T, class Alloc, class Tuple1, class Tuple2>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc, piecewise_construct_t,
%        Tuple1&& x, Tuple2&& y) noexcept;
%        template<class T, class Alloc>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc) noexcept;
%        template<class T, class Alloc, class U, class V>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%        U&& u, V&& v) noexcept;
%        template<class T, class Alloc, class U, class V>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%        pair<U, V>& pr) noexcept;
%        template<class T, class Alloc, class U, class V>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%        const pair<U, V>& pr) noexcept;
%        template<class T, class Alloc, class U, class V>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%        pair<U, V>&& pr) noexcept;
%        template<class T, class Alloc, class U, class V>
%        constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%        const pair<U, V>&& pr) noexcept;
%        @\added{template<class T, class Alloc, \placeholder{pair-like} Pair>}@
%        @\added{constexpr auto uses_allocator_construction_args(const Alloc\& alloc, Pair\&\& pr) noexcept;}@
%        template<class T, class Alloc, class... Args>
%        constexpr T make_obj_using_allocator(const Alloc& alloc, Args&&... args);
%        template<class T, class Alloc, class... Args>
%        constexpr T* uninitialized_construct_using_allocator(T* p, const Alloc& alloc,
%        Args&&... args);
%    }
%\end{codeblock}
%
%[....]
%
%\rSec3[allocator.uses.construction]{Uses-allocator construction}
%
%[...]
%
%\indexlibraryglobal{uses_allocator_construction_args}%
%\begin{itemdecl}
%    template<class T, class Alloc>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc) noexcept;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \tcode{T} is a specialization of \tcode{pair}.
%
%    \pnum
%    \effects
%    Equivalent to:
%    \begin{codeblock}
%        return uses_allocator_construction_args<T>(alloc, piecewise_construct,
%        tuple<>{}, tuple<>{});
%    \end{codeblock}
%\end{itemdescr}
%
%\indexlibraryglobal{uses_allocator_construction_args}%
%\begin{itemdecl}
%    template<class T, class Alloc, class U, class V>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%    U&& u, V&& v) noexcept;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \tcode{T} is a specialization of \tcode{pair}.
%
%    \pnum
%    \effects
%    Equivalent to:
%    \begin{codeblock}
%        return uses_allocator_construction_args<T>(alloc, piecewise_construct,
%        forward_as_tuple(get(u)),
%        forward_as_tuple(std::forward<V>(v)));
%    \end{codeblock}
%\end{itemdescr}
%
%\indexlibraryglobal{uses_allocator_construction_args}%
%\begin{itemdecl}
%    template<class T, class Alloc, class U, class V>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc, pair<U, V>& pr) noexcept;
%    template<class T, class Alloc, class U, class V>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc, const pair<U, V>& pr) noexcept;
%\end{itemdecl}
%\begin{addedblock}
%\begin{itemdecl}
%    template<class T, class Alloc, class U, class V>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc, pair<U, V>&& pr) noexcept;
%    template<class T, class Alloc, class U, class V>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc, const pair<U, V>&& pr) noexcept;
%
%    template<class T, class Alloc, @\placeholder{pair-like}@ Pair>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc, Pair&& pr) noexcept;
%
%\end{itemdecl}
%\end{addedblock}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \tcode{T} is a specialization of \tcode{pair}.
%
%    \pnum
%    \effects
%    Equivalent to:
%    \begin{codeblock}
%        return uses_allocator_construction_args<T>(alloc, piecewise_construct,
%        forward_as_tuple(@\changed{pr.first}{get<0>(std::forward<Pair>(pr)}@),
%        forward_as_tuple(@\changed{pr.second}{get<1>(std::forward<Pair>(pr)}@);
%    \end{codeblock}
%\end{itemdescr}
%
%\begin{removedblock}
%\indexlibraryglobal{uses_allocator_construction_args}%
%\begin{itemdecl}
%    template<class T, class Alloc, class U, class V>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%    pair<U, V>&& pr) noexcept;
%    template<class T, class Alloc, class U, class V>
%    constexpr auto uses_allocator_construction_args(const Alloc& alloc,
%    const pair<U, V>&& pr) noexcept;
%\end{itemdecl}
%
%\begin{itemdescr}
%    \pnum
%    \constraints
%    \tcode{T} is a specialization of \tcode{pair}.
%
%    \pnum
%    \effects
%    Equivalent to:
%    \begin{codeblock}
%        return uses_allocator_construction_args<T>(alloc, piecewise_construct,
%        forward_as_tuple(get<0>(std::move(pr))),
%        forward_as_tuple(get<1>(std::move(pr))));
%    \end{codeblock}
%\end{itemdescr}
%
%\ednote{The above wording changes intend to merge all the pair-related \tcode{uses_allocator_construction_args} overloads specification by always calling \tcode{forward}, for each of the 4 existing overload, and the new one.}
%
%\end{removedblock}

\rSec1[containers]{Containers}

\rSec1[associative]{Associative containers}

\ednote{We probably need to modify the requirements table, which I have found challenging as requirements apply equally to sets and maps.
    In particular, we probably want to requiere \tcode{is_constructible<value_type, T>} where T is either the type passed to insert, or the \tcode{InputIterator}'s \tcode{value_type}.
    Currently, we only seem to require \tcode{convertible_to}, which may not be sufficient?.
    An alternative is to add explicit insert overloads for \tcode{pair-like} objects}.

\rSec2[associative.general]{In general}

\pnum
The header map defines the class templates \tcode{map} and
\tcode{multimap}; the header set defines the class templates
\tcode{set} and \tcode{multiset}.

\pnum
The following exposition-only alias templates may appear in deduction guides for associative containers:
\begin{codeblock}
    template<class InputIterator>
    using @\placeholder{iter-value-type}@ =
    typename iterator_traits<InputIterator>::value_type;                // \expos
    template<class InputIterator>
    using @\placeholder{iter-key-type}@ = remove_const_t<
    @\changed{typename iterator_traits<InputIterator>::value_type::first_type}{\\tuple_element_t<0, \placeholder{iter-value-type}<InputIterator>>}@>;   // \expos
    template<class InputIterator>
    using @\placeholder{iter-mapped-type}@ =
    @\changed{typename iterator_traits<InputIterator>::value_type::second_type}{\\tuple_element_t<1, \placeholder{iter-value-type}<InputIterator>>}@;   // \expos
    template<class InputIterator>
    using @\placeholder{iter-to-alloc-type}@ = pair<
    add_const_t<@\changed{typename iterator_traits<InputIterator>::value_type::first_type}{\\tuple_element_t<0, \placeholder{iter-value-type}<InputIterator>>}@>,
    @\changed{typename iterator_traits<InputIterator>::value_type::second_type}{\\tuple_element_t<1, \placeholder{iter-value-type}<InputIterator>>}@>;  // \expos
\end{codeblock}


\rSec1[range.utility]{Range utilities}
\rSec2[range.subrange]{Sub-ranges}

\pnum
The \tcode{subrange} class template combines together an
iterator and a sentinel into a single object that models the
\libconcept{view} concept. Additionally, it models the
\libconcept{sized_range} concept when the final template parameter is
\tcode{subrange_kind::sized}.

\indexlibraryglobal{subrange}%
\begin{codeblock}
namespace std::ranges {
    template<class From, class To>
    concept @\defexposconcept{convertible-to-non-slicing}@ =                    // \expos
    convertible_to<From, To> &&
    !(is_pointer_v<decay_t<From>> &&
    is_pointer_v<decay_t<To>> &&
    @\exposconcept{not-same-as}@<remove_pointer_t<decay_t<From>>, remove_pointer_t<decay_t<To>>>);

\end{codeblock}
\begin{removedblock}
\begin{codeblock}
    template<class T>
    concept @\defexposconcept{pair-like}@ =                                     // \expos
    !is_reference_v<T> && requires(T t) {
        typename tuple_size<T>::type;                       // ensures \tcode{tuple_size<T>} is complete
        requires @\libconcept{derived_from}@<tuple_size<T>, integral_constant<size_t, 2>>;
        typename tuple_element_t<0, remove_const_t<T>>;
        typename tuple_element_t<1, remove_const_t<T>>;
        { get<0>(t) } -> @\libconcept{convertible_to}@<const tuple_element_t<0, T>&>;
        { get<1>(t) } -> @\libconcept{convertible_to}@<const tuple_element_t<1, T>&>;
    };
\end{codeblock}
\end{removedblock}
\begin{codeblock}
    template<class T, class U, class V>
    concept @\defexposconcept{pair-like-convertible-from}@ =                    // \expos
    !@\libconcept{range}@<T> && @\added{!is_reference_v<T> \&\&}@ @\exposconcept{pair-like}@<T> &&
    @\libconcept{constructible_from}@<T, U, V> &&
    @\exposconcept{convertible-to-non-slicing}@<U, tuple_element_t<0, T>> &&
    @\libconcept{convertible_to}@<V, tuple_element_t<1, T>>;
\end{codeblock}

\rSec2[range.elements]{Elements view}
\rSec3[range.elements.view]{Class template \tcode{elements_view}}

\indexlibraryglobal{elements_view}%
\indexlibrarymember{base}{elements_view}%
\indexlibrarymember{begin}{elements_view}%
\indexlibrarymember{end}{elements_view}%
\indexlibrarymember{size}{elements_view}%
\begin{codeblock}

namespace std::ranges {
    template<class T, size_t N>
    concept @\defexposconcept{has-tuple-element}@ =                   // \expos
    @\added{\exposconcept{tuple-like}<T> \&\& N < tuple_size_v<T>;}@
     @\removed{  requires(T t) \{ }@
        @\removed{    typename tuple_size<T>::type;}@
        @\removed{    requires N < tuple_size_v<T>;}@
        @\removed{  typename tuple_element_t<N, T>;}@
        @\removed{  \{ std::get<N>(t) \} -> convertible_to<const tuple_element_t<N, T>\&>;}@
    @\removed{ \};}@
}
\end{codeblock}


\rSec3[range.zip.view]{Class template \tcode{zip_view}}


\rSec3[range.zip.view]{Class template \tcode{zip_view}}

\indexlibrarymember{begin}{zip_view}%
\indexlibrarymember{end}{zip_view}%
\indexlibrarymember{size}{zip_view}%
\begin{codeblock}
namespace std::ranges {
    template<class... Rs>
    concept @\defexposconcept{zip-is-common}@ =                             // \expos
    (sizeof...(Rs) == 1 && (@\libconcept{common_range}@<Rs> && ...)) ||
    (!(@\libconcept{bidirectional_range}@<Rs> && ...) && (@\libconcept{common_range}@<Rs> && ...)) ||
    ((@\libconcept{random_access_range}@<Rs> && ...) && (@\libconcept{sized_range}@<Rs> && ...));

    @\removed{template<class... Ts>}@
    @\removed{using \exposid{tuple-or-pair} = \seebelow;                 // \expos}@

    template<class F, class Tuple>
    constexpr auto @\exposid{tuple-transform}@(F&& f, Tuple&& tuple) { // \expos
        return apply([&]<class... Ts>(Ts&&... elements) {
            return @\exposid{tuple-or-pair}@<invoke_result_t<F&, Ts>...>(
            invoke(f, std::forward<Ts>(elements))...
            );
        }, std::forward<Tuple>(tuple));
    }
\end{codeblock}


\ednote{Remove [range.zip.view]p1}

\begin{removedblock}
\pnum
Given some pack of types \tcode{Ts},
the alias template \exposid{tuple-or-pair} is defined as follows:
\begin{itemize}
    \item
    If \tcode{sizeof...(Ts)} is 2,
    \tcode{\exposid{tuple-or-pair}<Ts...>} denotes \tcode{pair<Ts...>}.
    \item
    Otherwise, \tcode{\exposid{tuple-or-pair}<Ts...>} denotes \tcode{tuple<Ts...>}.
\end{itemize}
\end{removedblock}

\ednote{Replace all usages of \exposid{tuple-or-pair} by \tcode{tuple} in the range clause.
This includes [range.zip], [range.adjacent.iterator] as well as [range.cartesian] if P2374 is adopted}


\section{Feature test macros}

Insert into [version.syn]

\begin{addedblock}
\begin{codeblock}
#define __cpp_lib_tuple_like <DATE OF ADOPTION> // also in <utility>, <tuple>
\end{codeblock}
\end{addedblock}

%
%\rSec2[map]{Class template \tcode{map}}
%
%\rSec3[map.overview]{Overview}
%
%\indexlibraryglobal{map}%
%\pnum
%[...]
%\indexlibrarymember{comp}{map::value_compare}%
%\indexlibrarymember{operator()}{map::value_compare}%
%\begin{codeblock}
%namespace std {
%    template<class Key, class T, class Compare = less<Key>,
%    class Allocator = allocator<pair<const Key, T>>>
%    class map {
%        public:
%        // types
%        using key_type               = Key;
%        using mapped_type            = T;
%        using value_type             = pair<const Key, T>;
%        using key_compare            = Compare;
%        using allocator_type         = Allocator;
%        using pointer                = typename allocator_traits<Allocator>::pointer;
%        using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
%        using reference              = value_type&;
%        using const_reference        = const value_type&;
%        using size_type              = @\impdefx{type of \tcode{map::size_type}}@; // see \ref{container.requirements}
%        using difference_type        = @\impdefx{type of \tcode{map::difference_type}}@; // see \ref{container.requirements}
%        using iterator               = @\impdefx{type of \tcode{map::iterator}}@; // see \ref{container.requirements}
%        using const_iterator         = @\impdefx{type of \tcode{map::const_iterator}}@; // see \ref{container.requirements}
%        using reverse_iterator       = std::reverse_iterator<iterator>;
%        using const_reverse_iterator = std::reverse_iterator<const_iterator>;
%        using node_type              = @\unspec@;
%        using insert_return_type     = @\placeholdernc{insert-return-type}@<iterator, node_type>;
%
%        class value_compare {
%            friend class map;
%            protected:
%            Compare comp;
%            value_compare(Compare c) : comp(c) {}
%            public:
%            bool operator()(const value_type& x, const value_type& y) const {
%                return comp(x.first, y.first);
%            }
%        };
%
%        // \ref{map.cons}, construct/copy/destroy
%        map() : map(Compare()) { }
%        explicit map(const Compare& comp, const Allocator& = Allocator());
%        template<class InputIterator>
%        map(InputIterator first, InputIterator last,
%        const Compare& comp = Compare(), const Allocator& = Allocator());
%        map(const map& x);
%        map(map&& x);
%        explicit map(const Allocator&);
%        map(const map&, const Allocator&);
%        map(map&&, const Allocator&);
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        map(initializer_list<@\changed{value_type}{P}@>, const Compare& = Compare(), const Allocator& = Allocator());
%        template<class InputIterator>
%        map(InputIterator first, InputIterator last, const Allocator& a)
%        : map(first, last, Compare(), a) { }
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        map(initializer_list<@\changed{value_type}{P}@> il, const Allocator& a)
%        : map(il, Compare(), a) { }
%        ~map();
%        map& operator=(const map& x);
%        map& operator=(map&& x)
%        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
%        is_nothrow_move_assignable_v<Compare>);
%
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        map& operator=(initializer_list<@\changed{value_type}{P}@>);
%        allocator_type get_allocator() const noexcept;
%
%        // iterators
%        iterator               begin() noexcept;
%        const_iterator         begin() const noexcept;
%        iterator               end() noexcept;
%        const_iterator         end() const noexcept;
%
%        reverse_iterator       rbegin() noexcept;
%        const_reverse_iterator rbegin() const noexcept;
%        reverse_iterator       rend() noexcept;
%        const_reverse_iterator rend() const noexcept;
%
%        const_iterator         cbegin() const noexcept;
%        const_iterator         cend() const noexcept;
%        const_reverse_iterator crbegin() const noexcept;
%        const_reverse_iterator crend() const noexcept;
%
%        // capacity
%        [[nodiscard]] bool empty() const noexcept;
%        size_type size() const noexcept;
%        size_type max_size() const noexcept;
%
%        // \ref{map.access}, element access
%        mapped_type& operator[](const key_type& x);
%        mapped_type& operator[](key_type&& x);
%        mapped_type&       at(const key_type& x);
%        const mapped_type& at(const key_type& x) const;
%
%        // \ref{map.modifiers}, modifiers
%        template<class... Args> pair<iterator, bool> emplace(Args&&... args);
%        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
%        pair<iterator, bool> insert(const value_type& x);
%        pair<iterator, bool> insert(value_type&& x);
%        template<class P> pair<iterator, bool> insert(P&& x);
%        iterator insert(const_iterator position, const value_type& x);
%        iterator insert(const_iterator position, value_type&& x);
%        template<class P>
%        iterator insert(const_iterator position, P&&);
%        template<class InputIterator>
%        void insert(InputIterator first, InputIterator last);
%
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        void insert(initializer_list<@\changed{value_type}{P}@>);
%
%        node_type extract(const_iterator position);
%        node_type extract(const key_type& x);
%        insert_return_type insert(node_type&& nh);
%        iterator           insert(const_iterator hint, node_type&& nh);
%
%        template<class... Args>
%        pair<iterator, bool> try_emplace(const key_type& k, Args&&... args);
%        template<class... Args>
%        pair<iterator, bool> try_emplace(key_type&& k, Args&&... args);
%        template<class... Args>
%        iterator try_emplace(const_iterator hint, const key_type& k, Args&&... args);
%        template<class... Args>
%        iterator try_emplace(const_iterator hint, key_type&& k, Args&&... args);
%        template<class M>
%        pair<iterator, bool> insert_or_assign(const key_type& k, M&& obj);
%        template<class M>
%        pair<iterator, bool> insert_or_assign(key_type&& k, M&& obj);
%        template<class M>
%        iterator insert_or_assign(const_iterator hint, const key_type& k, M&& obj);
%        template<class M>
%        iterator insert_or_assign(const_iterator hint, key_type&& k, M&& obj);
%
%        iterator  erase(iterator position);
%        iterator  erase(const_iterator position);
%        size_type erase(const key_type& x);
%        iterator  erase(const_iterator first, const_iterator last);
%        void      swap(map&)
%        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
%        is_nothrow_swappable_v<Compare>);
%        void      clear() noexcept;
%
%        template<class C2>
%        void merge(map<Key, T, C2, Allocator>& source);
%        template<class C2>
%        void merge(map<Key, T, C2, Allocator>&& source);
%        template<class C2>
%        void merge(multimap<Key, T, C2, Allocator>& source);
%        template<class C2>
%        void merge(multimap<Key, T, C2, Allocator>&& source);
%
%        // observers
%        key_compare key_comp() const;
%        value_compare value_comp() const;
%
%        // map operations
%        iterator       find(const key_type& x);
%        const_iterator find(const key_type& x) const;
%        template<class K> iterator       find(const K& x);
%        template<class K> const_iterator find(const K& x) const;
%
%        size_type      count(const key_type& x) const;
%        template<class K> size_type count(const K& x) const;
%
%        bool           contains(const key_type& x) const;
%        template<class K> bool contains(const K& x) const;
%
%        iterator       lower_bound(const key_type& x);
%        const_iterator lower_bound(const key_type& x) const;
%        template<class K> iterator       lower_bound(const K& x);
%        template<class K> const_iterator lower_bound(const K& x) const;
%
%        iterator       upper_bound(const key_type& x);
%        const_iterator upper_bound(const key_type& x) const;
%        template<class K> iterator       upper_bound(const K& x);
%        template<class K> const_iterator upper_bound(const K& x) const;
%
%        pair<iterator, iterator>               equal_range(const key_type& x);
%        pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
%        template<class K>
%        pair<iterator, iterator>             equal_range(const K& x);
%        template<class K>
%        pair<const_iterator, const_iterator> equal_range(const K& x) const;
%    };
%
%    template<class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>,
%    class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
%    map(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
%    -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Compare, Allocator>;
%
%    template<@\added{\placeholder{pair-like} T}@ @\removed{class Key, class T}@, class Compare = less<@\changed{Key}{tuple_element_t<0, T>}@>,
%    class Allocator = allocator<pair<const @\changed{Key}{tuple_element_t<0, T>}@,  @\changed{T}{tuple_element_t<1, T>}@>>>
%    map(initializer_list<@\changed{pair<Key, T>}{T}@>, Compare = Compare(), Allocator = Allocator())
%    -> map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Compare, Allocator>;
%
%    template<class InputIterator, class Allocator>
%    map(InputIterator, InputIterator, Allocator)
%    -> map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%    less<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
%    map(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
%    -> map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, less<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%}
%\end{codeblock}
%
%
%\rSec2[multimap]{Class template \tcode{multimap}}
%
%\rSec3[multimap.overview]{Overview}
%
%\pnum
%\indexlibraryglobal{multimap}%
%A
%\tcode{multimap}
%is an associative container that supports equivalent keys (possibly containing multiple copies of
%the same key value) and provides for fast retrieval of values of another type
%\tcode{T}
%based on the keys.
%The
%\tcode{multimap}
%class
%supports bidirectional iterators.
%
%\pnum
%[...]
%\begin{codeblock}
%namespace std {
%template<class Key, class T, class Compare = less<Key>,
%class Allocator = allocator<pair<const Key, T>>>
%class multimap {
%    public:
%    // types
%    using key_type               = Key;
%    using mapped_type            = T;
%    using value_type             = pair<const Key, T>;
%    using key_compare            = Compare;
%    using allocator_type         = Allocator;
%    using pointer                = typename allocator_traits<Allocator>::pointer;
%    using const_pointer          = typename allocator_traits<Allocator>::const_pointer;
%    using reference              = value_type&;
%    using const_reference        = const value_type&;
%    using size_type              = @\impdefx{type of \tcode{multimap::size_type}}@; // see \ref{container.requirements}
%    using difference_type        = @\impdefx{type of \tcode{multimap::difference_type}}@; // see \ref{container.requirements}
%    using iterator               = @\impdefx{type of \tcode{multimap::iterator}}@; // see \ref{container.requirements}
%    using const_iterator         = @\impdefx{type of \tcode{multimap::const_iterator}}@; // see \ref{container.requirements}
%    using reverse_iterator       = std::reverse_iterator<iterator>;
%    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
%    using node_type              = @\unspec@;
%
%    class value_compare {
%        friend class multimap;
%        protected:
%        Compare comp;
%        value_compare(Compare c) : comp(c) { }
%        public:
%        bool operator()(const value_type& x, const value_type& y) const {
%            return comp(x.first, y.first);
%        }
%    };
%
%    // \ref{multimap.cons}, construct/copy/destroy
%    multimap() : multimap(Compare()) { }
%    explicit multimap(const Compare& comp, const Allocator& = Allocator());
%    template<class InputIterator>
%    multimap(InputIterator first, InputIterator last,
%    const Compare& comp = Compare(),
%    const Allocator& = Allocator());
%    multimap(const multimap& x);
%    multimap(multimap&& x);
%    explicit multimap(const Allocator&);
%    multimap(const multimap&, const type_identity_t<Allocator>&);
%    multimap(multimap&&, const type_identity_t<Allocator>&);
%
%    @\added{template<\placeholder{pair-like} P = value_type>}@
%    @\added{requires convertible_to<P, value_type>}@
%    multimap(initializer_list<@\changed{value_type}{P}@>,
%        const Compare& = Compare(),
%        const Allocator& = Allocator());
%    template<class InputIterator>
%    multimap(InputIterator first, InputIterator last, const Allocator& a)
%    : multimap(first, last, Compare(), a) { }
%    @\added{template<\placeholder{pair-like} P = value_type>}@
%    @\added{requires convertible_to<P, value_type>}@
%    multimap(initializer_list<value_type> il, const Allocator& a)
%    : multimap(il, Compare(), a) { }
%    ~multimap();
%    multimap& operator=(const multimap& x);
%    multimap& operator=(multimap&& x)
%    noexcept(allocator_traits<Allocator>::is_always_equal::value &&
%    is_nothrow_move_assignable_v<Compare>);
%    @\added{template<\placeholder{pair-like} P = value_type>}@
%    @\added{requires convertible_to<P, value_type>}@
%    multimap& operator=(initializer_list<@\changed{value_type}{P}@>);
%    allocator_type get_allocator() const noexcept;
%
%    // iterators
%    iterator               begin() noexcept;
%    const_iterator         begin() const noexcept;
%    iterator               end() noexcept;
%    const_iterator         end() const noexcept;
%
%    reverse_iterator       rbegin() noexcept;
%    const_reverse_iterator rbegin() const noexcept;
%    reverse_iterator       rend() noexcept;
%    const_reverse_iterator rend() const noexcept;
%
%    const_iterator         cbegin() const noexcept;
%    const_iterator         cend() const noexcept;
%    const_reverse_iterator crbegin() const noexcept;
%    const_reverse_iterator crend() const noexcept;
%
%    // capacity
%    [[nodiscard]] bool empty() const noexcept;
%    size_type size() const noexcept;
%    size_type max_size() const noexcept;
%
%    // \ref{multimap.modifiers}, modifiers
%    template<class... Args> iterator emplace(Args&&... args);
%    template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
%    iterator insert(const value_type& x);
%    iterator insert(value_type&& x);
%    template<class P> iterator insert(P&& x);
%    iterator insert(const_iterator position, const value_type& x);
%    iterator insert(const_iterator position, value_type&& x);
%    template<class P> iterator insert(const_iterator position, P&& x);
%    template<class InputIterator>
%    void insert(InputIterator first, InputIterator last);
%    @\added{template<\placeholder{pair-like} P = value_type>}@
%    @\added{requires convertible_to<P, value_type>}@
%    void insert(initializer_list<@\changed{value_type}{P}@>);
%
%    node_type extract(const_iterator position);
%    node_type extract(const key_type& x);
%    template<class K> node_type extract(K&& x);
%    iterator insert(node_type&& nh);
%    iterator insert(const_iterator hint, node_type&& nh);
%
%    iterator  erase(iterator position);
%    iterator  erase(const_iterator position);
%    size_type erase(const key_type& x);
%    template<class K> size_type erase(K&& x);
%    iterator  erase(const_iterator first, const_iterator last);
%    void      swap(multimap&)
%    noexcept(allocator_traits<Allocator>::is_always_equal::value &&
%    is_nothrow_swappable_v<Compare>);
%    void      clear() noexcept;
%
%    template<class C2>
%    void merge(multimap<Key, T, C2, Allocator>& source);
%    template<class C2>
%    void merge(multimap<Key, T, C2, Allocator>&& source);
%    template<class C2>
%    void merge(map<Key, T, C2, Allocator>& source);
%    template<class C2>
%    void merge(map<Key, T, C2, Allocator>&& source);
%
%    // observers
%    key_compare key_comp() const;
%    value_compare value_comp() const;
%
%    // map operations
%    iterator       find(const key_type& x);
%    const_iterator find(const key_type& x) const;
%    template<class K> iterator       find(const K& x);
%    template<class K> const_iterator find(const K& x) const;
%
%    size_type      count(const key_type& x) const;
%    template<class K> size_type count(const K& x) const;
%
%    bool           contains(const key_type& x) const;
%    template<class K> bool contains(const K& x) const;
%
%    iterator       lower_bound(const key_type& x);
%    const_iterator lower_bound(const key_type& x) const;
%    template<class K> iterator       lower_bound(const K& x);
%    template<class K> const_iterator lower_bound(const K& x) const;
%
%    iterator       upper_bound(const key_type& x);
%    const_iterator upper_bound(const key_type& x) const;
%    template<class K> iterator       upper_bound(const K& x);
%    template<class K> const_iterator upper_bound(const K& x) const;
%
%    pair<iterator, iterator>               equal_range(const key_type& x);
%    pair<const_iterator, const_iterator>   equal_range(const key_type& x) const;
%    template<class K>
%    pair<iterator, iterator>             equal_range(const K& x);
%    template<class K>
%    pair<const_iterator, const_iterator> equal_range(const K& x) const;
%};
%
%template<class InputIterator, class Compare = less<@\placeholder{iter-key-type}@<InputIterator>>,
%class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
%multimap(InputIterator, InputIterator, Compare = Compare(), Allocator = Allocator())
%-> multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%Compare, Allocator>;
%
%template<@\added{\placeholder{pair-like} T}@ @\removed{class Key, class T}@, class Compare = less<@\changed{Key}{tuple_element_t<0, T>}@>,
%class Allocator = allocator<pair<const @\changed{Key}{tuple_element_t<0, T>}@,  @\changed{T}{tuple_element_t<1, T>}@>>>
%multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, Compare = Compare(), Allocator = Allocator())
%-> multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Compare, Allocator>;
%
%template<class InputIterator, class Allocator>
%multimap(InputIterator, InputIterator, Allocator)
%-> multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%less<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%template<@\added{\placeholder{pair-like} T}@ @\removed{class Key, class T}@, class Allocator>
%multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
%-> multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, less<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%}
%\end{codeblock}%
%\indexlibrarymember{multimap}{operator==}%
%\indexlibrarymember{multimap}{operator<}
%
%
%\rSec2[unord.map]{Class template \tcode{unordered_map}}%
%\indexlibraryglobal{unordered_map}
%
%[...]
%\indexlibraryglobal{unordered_map}%
%\begin{codeblock}
%namespace std {
%    template<class Key,
%    class T,
%    class Hash = hash<Key>,
%    class Pred = equal_to<Key>,
%    class Allocator = allocator<pair<const Key, T>>>
%    class unordered_map {
%        public:
%        // types
%        using key_type             = Key;
%        using mapped_type          = T;
%        using value_type           = pair<const Key, T>;
%        using hasher               = Hash;
%        using key_equal            = Pred;
%        using allocator_type       = Allocator;
%        using pointer              = typename allocator_traits<Allocator>::pointer;
%        using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
%        using reference            = value_type&;
%        using const_reference      = const value_type&;
%        using size_type            = @\impdefx{type of \tcode{unordered_map::size_type}}@; // see \ref{container.requirements}
%        using difference_type      = @\impdefx{type of \tcode{unordered_map::difference_type}}@; // see \ref{container.requirements}
%
%        using iterator             = @\impdefx{type of \tcode{unordered_map::iterator}}@; // see \ref{container.requirements}
%        using const_iterator       = @\impdefx{type of \tcode{unordered_map::const_iterator}}@; // see \ref{container.requirements}
%        using local_iterator       = @\impdefx{type of \tcode{unordered_map::local_iterator}}@; // see \ref{container.requirements}
%        using const_local_iterator = @\impdefx{type of \tcode{unordered_map::const_local_iterator}}@; // see \ref{container.requirements}
%        using node_type            = @\unspec@;
%        using insert_return_type   = @\placeholdernc{insert-return-type}@<iterator, node_type>;
%
%        // \ref{unord.map.cnstr}, construct/copy/destroy
%        unordered_map();
%        explicit unordered_map(size_type n,
%        const hasher& hf = hasher(),
%        const key_equal& eql = key_equal(),
%        const allocator_type& a = allocator_type());
%        template<class InputIterator>
%        unordered_map(InputIterator f, InputIterator l,
%        size_type n = @\seebelow@,
%        const hasher& hf = hasher(),
%        const key_equal& eql = key_equal(),
%        const allocator_type& a = allocator_type());
%        unordered_map(const unordered_map&);
%        unordered_map(unordered_map&&);
%        explicit unordered_map(const Allocator&);
%        unordered_map(const unordered_map&, const type_identity_t<Allocator>&);
%        unordered_map(unordered_map&&, const type_identity_t<Allocator>&);
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_map(initializer_list<@\changed{value_type}{P}@> il,
%        size_type n = @\seebelow@,
%        const hasher& hf = hasher(),
%        const key_equal& eql = key_equal(),
%        const allocator_type& a = allocator_type());
%        unordered_map(size_type n, const allocator_type& a)
%        : unordered_map(n, hasher(), key_equal(), a) { }
%        unordered_map(size_type n, const hasher& hf, const allocator_type& a)
%        : unordered_map(n, hf, key_equal(), a) { }
%        template<class InputIterator>
%        unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
%        : unordered_map(f, l, n, hasher(), key_equal(), a) { }
%        template<class InputIterator>
%        unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf,
%        const allocator_type& a)
%        : unordered_map(f, l, n, hf, key_equal(), a) { }
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_map(initializer_list<@\changed{value_type}{P}@> il, size_type n, const allocator_type& a)
%        : unordered_map(il, n, hasher(), key_equal(), a) { }
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_map(initializer_list<@\changed{value_type}{P}@> il, size_type n, const hasher& hf,
%        const allocator_type& a)
%        : unordered_map(il, n, hf, key_equal(), a) { }
%        ~unordered_map();
%        unordered_map& operator=(const unordered_map&);
%        unordered_map& operator=(unordered_map&&)
%        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
%        is_nothrow_move_assignable_v<Hash> &&
%        is_nothrow_move_assignable_v<Pred>);
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_map& operator=(initializer_list<@\changed{value_type}{P}@>);
%        allocator_type get_allocator() const noexcept;
%
%        // iterators
%        iterator       begin() noexcept;
%        const_iterator begin() const noexcept;
%        iterator       end() noexcept;
%        const_iterator end() const noexcept;
%        const_iterator cbegin() const noexcept;
%        const_iterator cend() const noexcept;
%
%        // capacity
%        [[nodiscard]] bool empty() const noexcept;
%        size_type size() const noexcept;
%        size_type max_size() const noexcept;
%
%        // \ref{unord.map.modifiers}, modifiers
%        template<class... Args> pair<iterator, bool> emplace(Args&&... args);
%        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
%        pair<iterator, bool> insert(const value_type& obj);
%        pair<iterator, bool> insert(value_type&& obj);
%        template<class P> pair<iterator, bool> insert(P&& obj);
%        iterator       insert(const_iterator hint, const value_type& obj);
%        iterator       insert(const_iterator hint, value_type&& obj);
%        template<class P> iterator insert(const_iterator hint, P&& obj);
%        template<class InputIterator> void insert(InputIterator first, InputIterator last);
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        void insert(initializer_list<@\changed{value_type}{P}@>);
%
%        node_type extract(const_iterator position);
%        node_type extract(const key_type& x);
%        template<class K> node_type extract(K&& x);
%        insert_return_type insert(node_type&& nh);
%        iterator           insert(const_iterator hint, node_type&& nh);
%
%        //[..]
%    };
%
%template<class InputIterator,
%class Hash = hash<@\placeholder{iter-key-type}@<InputIterator>>,
%class Pred = equal_to<@\placeholder{iter-key-type}@<InputIterator>>,
%class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
%unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type = @\seebelow@,
%Hash = Hash(), Pred = Pred(), Allocator = Allocator())
%-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash, Pred,
%Allocator>;
%
%template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash = hash<Key>,
%class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
%unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>,
%typename @\seebelow@::size_type = @\seebelow@, Hash = Hash(),
%Pred = Pred(), Allocator = Allocator())
%-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, Pred, Allocator>;
%
%template<class InputIterator, class Allocator>
%unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
%-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%hash<@\placeholder{iter-key-type}@<InputIterator>>,
%equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%template<class InputIterator, class Allocator>
%unordered_map(InputIterator, InputIterator, Allocator)
%-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%hash<@\placeholder{iter-key-type}@<InputIterator>>,
%equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%template<class InputIterator, class Hash, class Allocator>
%unordered_map(InputIterator, InputIterator, typename @\seebelow@::size_type, Hash, Allocator)
%-> unordered_map<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash,
%equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
%unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type,
%Allocator)
%-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%
%template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
%unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
%-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%
%template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash, class Allocator>
%unordered_map(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type, Hash,
%Allocator)
%-> unordered_map<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%}
%\end{codeblock}
%
%\rSec2[unord.multimap]{Class template \tcode{unordered_multimap}}%
%\indexlibraryglobal{unordered_multimap}
%
%\rSec3[unord.multimap.overview]{Overview}
%
%[...]
%
%\indexlibraryglobal{unordered_multimap}%
%\begin{codeblock}
%namespace std {
%    template<class Key,
%    class T,
%    class Hash = hash<Key>,
%    class Pred = equal_to<Key>,
%    class Allocator = allocator<pair<const Key, T>>>
%    class unordered_multimap {
%        public:
%        // types
%        using key_type             = Key;
%        using mapped_type          = T;
%        using value_type           = pair<const Key, T>;
%        using hasher               = Hash;
%        using key_equal            = Pred;
%        using allocator_type       = Allocator;
%        using pointer              = typename allocator_traits<Allocator>::pointer;
%        using const_pointer        = typename allocator_traits<Allocator>::const_pointer;
%        using reference            = value_type&;
%        using const_reference      = const value_type&;
%        using size_type            = @\impdefx{type of \tcode{unordered_multimap::size_type}}@; // see \ref{container.requirements}
%        using difference_type      = @\impdefx{type of \tcode{unordered_multimap::difference_type}}@; // see \ref{container.requirements}
%
%        using iterator             = @\impdefx{type of \tcode{unordered_multimap::iterator}}@; // see \ref{container.requirements}
%        using const_iterator       = @\impdefx{type of \tcode{unordered_multimap::const_iterator}}@; // see \ref{container.requirements}
%        using local_iterator       = @\impdefx{type of \tcode{unordered_multimap::local_iterator}}@; // see \ref{container.requirements}
%        using const_local_iterator = @\impdefx{type of \tcode{unordered_multimap::const_local_it\-erator}}@; // see \ref{container.requirements}
%        using node_type            = @\unspec@;
%
%        // \ref{unord.multimap.cnstr}, construct/copy/destroy
%        unordered_multimap();
%        explicit unordered_multimap(size_type n,
%        const hasher& hf = hasher(),
%        const key_equal& eql = key_equal(),
%        const allocator_type& a = allocator_type());
%        template<class InputIterator>
%        unordered_multimap(InputIterator f, InputIterator l,
%        size_type n = @\seebelow@,
%        const hasher& hf = hasher(),
%        const key_equal& eql = key_equal(),
%        const allocator_type& a = allocator_type());
%        unordered_multimap(const unordered_multimap&);
%        unordered_multimap(unordered_multimap&&);
%        explicit unordered_multimap(const Allocator&);
%        unordered_multimap(const unordered_multimap&, const type_identity_t<Allocator>&);
%        unordered_multimap(unordered_multimap&&, const type_identity_t<Allocator>&);
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_multimap(initializer_list<@\changed{value_type}{P}@> il,
%        size_type n = @\seebelow@,
%        const hasher& hf = hasher(),
%        const key_equal& eql = key_equal(),
%        const allocator_type& a = allocator_type());
%        unordered_multimap(size_type n, const allocator_type& a)
%        : unordered_multimap(n, hasher(), key_equal(), a) { }
%        unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)
%        : unordered_multimap(n, hf, key_equal(), a) { }
%        template<class InputIterator>
%        unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)
%        : unordered_multimap(f, l, n, hasher(), key_equal(), a) { }
%        template<class InputIterator>
%        unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf,
%        const allocator_type& a)
%        : unordered_multimap(f, l, n, hf, key_equal(), a) { }
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_multimap(initializer_list<@\changed{value_type}{P}@> il, size_type n, const allocator_type& a)
%        : unordered_multimap(il, n, hasher(), key_equal(), a) { }
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_multimap(initializer_list<@\changed{value_type}{P}@> il, size_type n, const hasher& hf,
%        const allocator_type& a)
%        : unordered_multimap(il, n, hf, key_equal(), a) { }
%        ~unordered_multimap();
%        unordered_multimap& operator=(const unordered_multimap&);
%        unordered_multimap& operator=(unordered_multimap&&)
%        noexcept(allocator_traits<Allocator>::is_always_equal::value &&
%        is_nothrow_move_assignable_v<Hash> &&
%        is_nothrow_move_assignable_v<Pred>);
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        unordered_multimap& operator=(initializer_list<@\changed{value_type}{P}@>);
%        allocator_type get_allocator() const noexcept;
%
%        // iterators
%        iterator       begin() noexcept;
%        const_iterator begin() const noexcept;
%        iterator       end() noexcept;
%        const_iterator end() const noexcept;
%        const_iterator cbegin() const noexcept;
%        const_iterator cend() const noexcept;
%
%        // capacity
%        [[nodiscard]] bool empty() const noexcept;
%        size_type size() const noexcept;
%        size_type max_size() const noexcept;
%
%        // \ref{unord.multimap.modifiers}, modifiers
%        template<class... Args> iterator emplace(Args&&... args);
%        template<class... Args> iterator emplace_hint(const_iterator position, Args&&... args);
%        iterator insert(const value_type& obj);
%        iterator insert(value_type&& obj);
%        template<class P> iterator insert(P&& obj);
%        iterator insert(const_iterator hint, const value_type& obj);
%        iterator insert(const_iterator hint, value_type&& obj);
%        template<class P> iterator insert(const_iterator hint, P&& obj);
%        template<class InputIterator> void insert(InputIterator first, InputIterator last);
%        @\added{template<\placeholder{pair-like} P = value_type>}@
%        @\added{requires convertible_to<P, value_type>}@
%        void insert(initializer_list<@\changed{value_type}{P}@>);
%
%        // [...]
%    };
%
%    template<class InputIterator,
%    class Hash = hash<@\placeholder{iter-key-type}@<InputIterator>>,
%    class Pred = equal_to<@\placeholder{iter-key-type}@<InputIterator>>,
%    class Allocator = allocator<@\placeholder{iter-to-alloc-type}@<InputIterator>>>
%    unordered_multimap(InputIterator, InputIterator,
%    typename @\seebelow@::size_type = @\seebelow@,
%    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
%    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%    Hash, Pred, Allocator>;
%
%    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash = hash<Key>,
%    class Pred = equal_to<Key>, class Allocator = allocator<pair<const Key, T>>>
%    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>,
%    typename @\seebelow@::size_type = @\seebelow@,
%    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
%    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, Pred, Allocator>;
%
%    template<class InputIterator, class Allocator>
%    unordered_multimap(InputIterator, InputIterator, typename @\seebelow@::size_type, Allocator)
%    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%    hash<@\placeholder{iter-key-type}@<InputIterator>>,
%    equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%    template<class InputIterator, class Allocator>
%    unordered_multimap(InputIterator, InputIterator, Allocator)
%    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>,
%    hash<@\placeholder{iter-key-type}@<InputIterator>>,
%    equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%    template<class InputIterator, class Hash, class Allocator>
%    unordered_multimap(InputIterator, InputIterator, typename @\seebelow@::size_type, Hash,
%    Allocator)
%    -> unordered_multimap<@\placeholder{iter-key-type}@<InputIterator>, @\placeholder{iter-mapped-type}@<InputIterator>, Hash,
%    equal_to<@\placeholder{iter-key-type}@<InputIterator>>, Allocator>;
%
%    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
%    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type,
%    Allocator)
%    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%
%    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Allocator>
%    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, Allocator)
%    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, hash<@\changed{Key}{tuple_element_t<0, T>}@>, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%
%    template<@\changed{class Key, class T}{\placeholder{pair-like} T}@, class Hash, class Allocator>
%    unordered_multimap(initializer_list<@\changed{pair<Key, T>}{T}@>, typename @\seebelow@::size_type,
%    Hash, Allocator)
%    -> unordered_multimap<@\changed{Key}{tuple_element_t<0, T>}@, @\changed{T}{tuple_element_t<1, T>}@, Hash, equal_to<@\changed{Key}{tuple_element_t<0, T>}@>, Allocator>;
%}
%\end{codeblock}

\section{Acknowledgments}

Thanks to Casey Carter, Alisdair Meredith, Christopher Di Bella and Tim Song for their invaluable feedbacks!

\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[N4901]{N4901}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4901}


\end{thebibliography}
\end{document}
