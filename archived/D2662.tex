% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\title{Pack Indexing}
\docnumber{P2662R3}
\audience{EWG}
\author{Corentin Jabot}{corentin.jabot@gmail.com}
\authortwo{Pablo Halpern}{phalpern@halpernwightsoftware.com}

\usepackage{color, colortbl}
\begin{document}
\maketitle

\section{Abstract}

This paper expands on the pack indexing feature described in \paper{P1858R2} and provides wording.

\section{Revisions}

\subsection{R3}

\begin{itemize}
\item Wording improvements, as reviewed by CWG in Kona
\end{itemize}

\subsection{R2}

\begin{itemize}
\item Wording improvements, as reviewed by CWG in Varna
\item Add a section about ways types could be deduced from an index-type-specifier.
\item expand the "future evolutions" section.
\end{itemize}

\subsection{R1}

\begin{itemize}
\item At EWG's request, we explained in more detail the syntax choices and explored alternatives.
\item Wording improvements
\end{itemize}

\subsection{R0}

\begin{itemize}
\item{Initial revision}
\end{itemize}

\section{Motivation}

The motivation for pack indexing is covered in \paper{P1858R2} and
 \paper{P2632R0}.

The short background version is that packs are sequences of types or expressions
and indexing is a fundamental operation on sequences.
C++ and its users have so far relied on deduction or library facilities, such as \tcode{index_sequence}, or full-fledged template metaprogramming libraries, such as
mp11 and boost.hana, to extract the Nth element of a pack, which has a high cost both in terms of code complexity and compiler throughput.

This paper proposes a new code language syntax to index packs of types (yielding a type) and packs of expressions (yielding an expression).

Previous works in this area also include \paper{P0565R0}, \paper{P1803R0}, \paper{N3761} and \paper{N4235}.

\section{Syntax}

The general syntax is \tcode{\placeholder{name-of-a-pack} ... [constant-expression]}.
The syntax has the benefit of reusing familiar elements (\tcode{...} usually denotes a pack expansion) and \tcode{[]} subscripts.
That indexing a pack expansion reuses these elements is, therefore, natural:

\begin{colorblock}
template <typename... T>
constexpr auto first_plus_last(T... values) ->  T...[0] {
    return T...[0](values...[0] + values...[sizeof...(values)-1]);
}
int main() {
    //first_plus_last(); // ill formed
    static_assert(first_plus_last(1, 2, 10) == 11);
}
\end{colorblock}

This syntax is used by Circle and was initially proposed by \paper{P1858R2}.

\subsection{Other syntactic options considered}

The \tcode{pack...[index]}
syntax was selected for this proposal after considering a
number of other options, some of which have been proposed by other
committee members.
\begin{itemize}
\item \tcode{pack.[index]}; see \paper{N4235}
\item \tcode{pack<index>} or \tcode{pack...<index>}
\item \tcode{std::nth_type<index, pack...>} or \tcode{std::nth_value<index>(pack...)}
\item \tcode{packexpr(args, I)}; see \paper{P1803R0}
\item \tcode{[index]pack}; see \paper{P0535R0}
\item Pack objects; see \paper{P2671R0}
\end{itemize}

\subsection{So, which syntax is the best choice?}

Any syntax would be better than
\href{https://twitter.com/incomputable/status/1590733659694583808}{the status quo}.
However, having considered the different options, the original choice,

\tcode{Pack...[N]}, still seems to be the best option, as it is straightforward
and consistent with existing pack features.  What follows is a detailed
analysis of the different options, but readers who find the proposed syntax acceptable might want to skip forward to
the "Pack Index" section.

Before arguing what the best syntax is, which is ultimately subjective, we need to understand the constraints.
\begin{itemize}
\item An indexed pack can produce a type, an expression, and maybe in the future a template template parameter, a universal template, and so on; thus we need a syntax
that can work in all contexts.

\item We want a syntax that can be expanded to support slicing in the future.

\item Pack elements can be array-like or tuple like, so we need to be careful
  about ambiguities. In particular, directly applying a subscript to a pack
  (\tcode{P[i]}, where \tcode{P} is a pack) is nonviable. Indeed, indexing a
  pack of arrays (\tcode{ArrayPack...[index]}), indexing each array in a pack
  (\tcode{ArrayPack[index]...}), indexing a single array with a pack of indexes
  (\tcode{Array[IndexPack]...}), and indexing each array in a pack of arrays
  with an index from an (equal-length) pack of indexes
  (\tcode{ArrayPack[IndexPack]...}) are different operations, all of which are
  useful. [\href{https://compiler-explorer.com/z/E86h8eMG1}{This example}]
  shows how, using the proposed syntax, one can distinguish between indexing
  the arrays from a pack with indexes from a pack
  (\tcode{ArrayPack[IndexPack]...}) and indexing a pack of arrays with a pack
  of indexes (\tcode{ArrayPack...[IndexPack]...}).
\end{itemize}

\subsubsection{\tcode{pack.[index]}}

Historically in C++ (and C++-like languages), a single dot denotes member access.
Reusing that syntax for pack indexing would introduce a semantics inconsistency and, more importantly, could close the door to future evolutions.

\paper{P1858R0} proposes \tcode{tuple-like.[N]} as syntactic sugar over
\tcode{get<N>(tuple-like)}
and \tcode{aggregate.[N]} returning the $Nth$ data member of an aggregate. % lah: WHAT is "returning the $Nth$ data member of an aggregate"---just the aggregate.[N] or BOTH get<N>(tuple-like) AND aggregate.[N]?

Ideally, \tcode{tuple[N]} would simply work.
A few proposals have tried to improve the user-friendliness
of tuple indexing (see
\paper{P2726R0} and \paper{P0311R0}).

We see no technical limitation to making \tcode{tuple-like[N]} work on types that do not otherwise define a \tcode{operator[]}.
\paper{P1858R2} prefers \tcode{.[]} to \tcode{[]} because the paper proposes to index not only tuple-like but also any other decomposable types, such as aggregates.
An aggregate might have an \tcode{operator[]} already, so disambiguating is unnecessary.
Note that array-like classes are tuple-like, but their \tcode{operator[]} has the same semantics as what tuple indexing would do. % lah: I know this seems weird, but in "array-like classes," the "array-like" is functioning as a two-word adjective for a noun, so it gets a hyphen, and "tuple like" is functioning as a predicate adjective, so it doesn't get a hyphen.

Whether tuple-indexing should be written as \tcode{.[]} or \tcode{[]} depends on whether indexing an aggregate is a frequent enough use case
to warrant a specific syntax, rather than indexing the pack formed by unpacking an aggregate (\tcode{aggregate[:]} --- in the syntax of \paper{P1858R2}, \tcode{aggregate.[N]} is a shorthand for \tcode{aggregate[:]...[N]}).

If % lah: When are you using "we" to mean the authors and when are you using it to mean "the Committee" or "the C++ community"?
a shorthand syntax to index the fields of an aggregate doesn't seem useful, then we can index tuple-like objects with \tcode{tuple[N]}, which would make
\tcode{pack.[N]} up for grabs. But that does not mean we should. We see little motivation --- other than availability --- for using syntax that usually denotes member access for packs.

\subsubsection{Angle brackets}

We could use angle brackets instead of square brackets, the argument, we suppose, being argument is that \tcode{<>} is more template-like and that pack indexing is also template-like.
However, most languages have existing practices in which \tcode{[]} is to be used for both indexing and slicing.
Being consistent with existing practice doesn't hurt.
Besides, pack indexing will often occur in angle-bracket-heavy code, so using brackets for indexing too would not look better.

\subsection{\tcode{std::nth_type<index, pack...>} or \tcode{std::nth_value<index>(pack...)}}

As mentioned in the motivation section, there already exist library-only
approaches to indexing a pack in mp11, boost.hana, and other libraries.
Indeed, most implementations of the C++ Standard Library contain a private
metafunction or two for this purpose.

The implementations are not complicated, but they are hard to write correctly
and, in non-optimized compiles, can result in the generation of a large number
of symbols and small functions:

\begin{colorblock}
template <size_t Index, class P0, class... Pack>
struct __nth_type_imp
{
    using type = typename __nth_type_imp<Index - 1, Pack...>::type;
};

template <class P0, class... Pack>
struct __nth_type_imp<0, P0, Pack...>
{
    using type = P0;
};

template <size_t Index, class P0, class... Pack>
using nth_type = typename __nth_type_imp<Index, P0, Pack...>::type;

template <size_t Index, class T0, class... Types>
constexpr decltype(auto) nth_value(T0&& p0, Types&&... pack) noexcept
{
    if constexpr (0 == Index)
        return std::forward<T0>(p0);
    else
        return nth_value<Index-1>(std::forward<Types>(pack)...);
}
\end{colorblock}

The obvious advantage of this approach is that it is implemented entirely in
the library, with no language changes necessary.  However, the disadvantages
are significant:

\begin{itemize}
\item Not only is the syntax harder to use but there are different syntaxes
  for packs of types versus packs of values. A metafunction for indexing a pack
  of templates (not shown) would have a third name and require yet another
  syntax.
\item The recursion level for each of these facilities is
  $O(index)$. The instantiations for each index value is not re-used for
  other index values, so \tcode{nth_type<5, pack...>} and
  \tcode{nth_type<6, pack...>} produce 11 instantiations total, even with the
  same \tcode{pack}.  Retrieving every element of a pack of size $N$,
  requires $\mathtt{O(N^2)}$ template instantiations.  If implemented entirely as
  a library, the drag on compile time can be quite large.

  A compiler can reduce the instantiation expense through the use of an
  intrinsic, and several compilers have implemented such intrinsics.  However,
  there is no guarantee that every implementation will do so.  Moreover, even
  if the library template invoked an intrinsic, one level of pack expansion is
  still needed for the indirection, making the best-case scenario
  $\mathtt(O(index))$.
\item The library solution does not have a future path for
  treating a subset of a pack as an unexpanded pack (slicing). Because packs
  are not first-class objects or types, it is doubtful that any metafunction
  could yield an unexpanded pack without language changes, thus eliminating the
  advantages of a library-only approach.
\item The library solution would also not work for universal template
  parameters, as described in \paper{P1985R1}.
\end{itemize}

\subsubsection{Magic function}

\paper{P1803R0} proposed \tcode{packexpr(pack, N)}, i.e., \tcode{reserved-identifier(pack, N)}.
We would need to find an identifier that is meaningful for all types of packs (not just expressions) and is not widely used.
The identifier would most certainly have to be a globally reserved keyword (not a contextual one), as pack indexing can appear anywhere either a type, or an expression can appear, which is everywhere.

Perhaps \tcode{packelement(pack, index)} would work, but we would arguably need another identifier for slicing.

\subsubsection{\tcode{[N]pack...}}

\paper{P0535R0} explored putting the index before the pack, and this method
would probably work, although some looking ahead might be necessary to distinguish that syntax from that of lambdas.
We see no logic to this choice other than, again, availability.

\subsubsection{Pack objects}

\paper{P2671R0} proposes a syntax (rather arbitrarily given it's currently unused), to create a \textit{pack object} or, rather, to instruct the compiler to manipulate
a pack without expanding it.
The one motivating use case is for the expansion statement, where that syntax allows us to distinguish \textit{looping} over a tuple versus looping over a pack in a nonambiguous manner.
Other examples, including pack indexing and slicing, look similar but arguably worse using this \textit{pack object} mechanism.

As noted, an expansion statement can be used with a pack using

\begin{colorblock}
    template for (auto elem : std::tuple(ts...)) { ... }
\end{colorblock}

Revzin observes this use is "wasteful," which is true, but a big part of the problem is that a tuple is a much heavier type than it ought to be,
and pack indexing is one of the tools we need to make tuples lighter - along with forwarding references deduction and member packs.

In this model, \tcode{pack!} is a pack object (the syntax seems to have been chosen rather arbitrarily on the fact it's currently not used),
and then that object can be indexed using \tcode{pack![N]}.

The pack object can be modeled by taking a reflection of the pack and then indexing that object splices the Nth element, as explained in \paper{P2671R0}

\begin{colorblock}
template <std::vector<std::meta::info> V>
struct PackObject {
    constexpr auto operator[](std::ptrdiff_t idx) const {
        return [: V[idx] :];
    }
};
\end{colorblock}

This model does not explain how it would deal with packs of types, template parameters, universal templates, and anything that is not an expression as an \tcode{operator[]}
has to return an expression.
Note that it could arguably return a meta::info and then let the user do the splicing itself, at which point any proclaimed syntax advantage would be lost.

We probably should discuss the concept of pack-objects, because they raise an interesting question:
Do we need a syntax to reflect on a pack, that would be a shorthand for \tcode{std::vector\{\^{}ts...\}}? Maybe?
Because I think that's the question that "pack-objects" fundamentally tries to answer.

And it is true that pack indexing is equivalent to
\begin{colorblock}
 [: std::vector{^pack...}[N] :]
\end{colorblock}

And slicing can probably be emulated with

\begin{colorblock}
...[: std::vector{^pack...} | std::views::drop(N) | std::views::take(M) ] :]...
\end{colorblock}

Note that \paper{P2671R0} seems to propose a slicing operator (\tcode{pack[N:M]}) anyway,
because the code above is not exactly terse.

Barry observes that slicing through a pack object creates more questions than it solves.
If slicing a pack creates a pack - which seems fairly obvious, does slicing a pack object create a pack object or a pack?

Both answers seem equally justified, however, if slicing a pack object produces a pack object, now we need another syntax
to turn the pack object back into a pack, and this is how \paper{P2671R0}
ends up suggesting \tcode{ts![1:]\~...} or \tcode{ts![1..]\~...}.

Which is a lot of new syntax constructs that do try to offer a consistent story.
And only work for expressions!

In terms of compile time, an implementation could either do what the paper proposes,
ie create a pack object, which includes a constexpr vector, evaluate that, and splice it to get the resulting expression
which would be less than optimal (and yet faster than any existing solution!), or an implementation
could be cleaver and treat \tcode{![N]} as a single "pack indexing" construct, which would be efficient but would be, in effect,
a pack indexing operation spelled \tcode{![]} instead of \tcode{...[]}.

I will not claim that one is prettier than the other, but one is certainly a natural extension of the current grammar.\subsubsection{Something else?}

We could entertain all sorts of syntaxes that are not yet used: two dots, four dots, \tcode{!}, \tcode{@} \$, and so on.
None of them would be a logical extension of the existing grammar, and since we are extending an existing facility, we should aim for something more justified than simply "it's not yet used by something else."

\subsubsection{Too many dots?}

One of the arguments heard against the \tcode{T...[N]} syntax is the "too many dots" argument.
And it's true that code that performs a lot of pack manipulation has numerous dots.
However, the code does make sense and is readable; e.g., see this \href{https://github.com/seanbaxter/circle/blob/master/tuple/tuple.hxx}{linked implementation of tuple}.
A few advantages come along with \tcode{...} for pack expansions.
\begin{itemize}
\item Seeing at a glance which pattern is expanded and where is useful.
\item The syntax of pack declarations and pack expansion has so far been rather consistent and follows a given pattern. Multiple paper authors
 have come up with the same syntax independently because it's an obvious extension of existing syntax.
\item Using \tcode{...\placeholder{postfix-syntax}} for this feature --- and future pack-related features (and nothing else) --- gives us a clear, reserved design space for packs.
\end{itemize}

\section{Allowable values for the pack index}

The index of a pack indexing expression or specifier is an integral constant expression between 0 and \tcode{sizeof...(pack) - 1}.
Empty packs can't be indexed.

In other proposals, a negative index, \tcode{-N}, would be interpreted as
indexing from the end of the pack --- as an alias of \tcode{T...[sizeof...(T)-N]}.
However, a negative index could occur by accident, yielding surprising results:

\begin{colorblock}
// Return the index of the first type convertible to Needle in Pack
// @\textbf{or -1 if Pack does not contain a suitable type}@.
template <typename Needle, typename... Pack>
auto find_convertible_in_pack;

// if find_convertible_in_pack<Foo, Types...> is -1, T will be the last type, erroneously.
using T = Types...[find_convertible_in_pack<Foo, Types...>];
\end{colorblock}

In general, incorrect computations in an index can lead to a negative value that should make the program ill-formed but would instead
yield an incorrect type.

Note, however, that Circle does support from-the-end indexing using a negative index, and Sean Baxter reports no surprises from using this feature.

An alternative for indexing from the end is to provide a specific syntax; for example, C\# uses \tcode{\^{}} to mean "from the end", and Dlang interprets \tcode{\${}}
as the size of the array:
\begin{colorblock}
using Foo = T...[0];
using Bar = T...[^1]; // first from the end
using Bar = T...[$ - 1]; // first from the end
\end{colorblock}

Given that alternatives are available, all of which can be added later and for which we do not have usage experience, this paper does not propose
from-the-end indexing.

\section{Indexing a pack of types}

Indexing a pack of types is a type specifier that can, like \tcode{decltype}, appear as
\begin{itemize}
    \item a simple-type-specifier
    \item a base class specifier
    \item a nested name specifier
    \item the type of an explicit destructor call
\end{itemize}

\section{Type deduction}

Pack indexing specifiers should not allow deducing the pack from such an expression:

\begin{colorblock}
template <typename... T>
void f(T...[0]);
f(0);
\end{colorblock}

However, CWG in Varna realized a way where a pack indexing type specifier could be deduced, and is asking EWG to chime in
as changing something to be deducible after the fact is always going to be a breaking change.

Consider the following example, graciously provided by Jens Maurer:
\begin{colorblock}
template<class ...T>
int f( T...[0], std::tuple<T...> );
int x = f(-1, std::tuple(5u, 1));
\end{colorblock}

Here \tcode{T...} is deduced from \tcode{5u, 1} to be \tcode{unsigned, int},
the first parameter of \tcode{f} is unsigned and \tcode{-1} is converted to unsigned.

This is what we propose.

But, we could imagine to instead, in that case, consider \tcode{T...}
to be a sparse, infinitely-sized pack of a sort - as we don't know its \tcode{size},
deduced \tcode{T...[0]} to be \tcode{int} (from \tcode{-1}),
then deduce the remaining of the pack (here the 2nd element) from the
remaining arguments, and then check we have deduced a type for each
element of the pack.

However, allowing parts of packs to be deduced only makes sense if the size of the pack is independently deduced.
Consider:
\begin{colorblock}
template <typename... T>
int f(T...[0], int) {
    static_assert(sizeof...(T) == ???);
}
int a = f(0, 1);
\end{colorblock}

Is the intent that \tcode{T...} is \tcode{int} (size 1) or \tcode{int, int} (size 2)?
Both seem reasonable options.
We could add a rule that the size of a deduced pack is deduced to be the size of the smallest pack that can be deduced,
but this would surely not make sense in all cases, and the implementation costs seem impossible to justify.

So the only context in which a pack indexing specifier could be deduced seems to be when the entire pack is
otherwise deduced, or when the size of a pack is deduced independently, which only ever happens for empty (non-indexable packs),
which is awfully limited, and yet very complex.

And this is before we consider whether this would impact partial ordering rules, which it certainly would, for example, what should this do?

\begin{colorblock}
template <typename... T>
int f(T...[0], tuple<T...>);  // #1

template <typename F, typename... T>
int f(F, tuple<T...>);  // #2

int a = f(0, tuple{1});   // #1 or #2
\end{colorblock}


We are sure there may be cases where this feature could be useful, yet we failed to come up
with genuine motivation for it. The reason for this discussion is that it would be a breaking change to adopt something like that
in a subsequent standard.

Going back to the first example, if \tcode{T...[0]} is not a deduced context,
it will correspond to unsigned, and if we allow it to be deduced it will be deduced to \tcode{int}
in the first parameter and in the second, which would be ill-formed.

In this proposal, we simply always consider pack indexing to be a non-deduced context.

% https://godbolt.org/z/GqhPMMTT1


\section{Indexing a pack of expressions}

The intent is that a pack indexing expression behaves exactly as the underlying expression would.
In particular, \tcode{decltype(id-dexpression) and \tcode{decltype(pack-index-expression)}} behave the same.

\section{Future evolutions}

The syntax can be extended in subsequent proposals to support

\begin{itemize}
\item Indexing packs introduced by structured bindings or other non-dependent packs.
      This should just work without further modification when both this paper and \paper{P1061R5} are both adopted.
\item Indexing packs of template template parameters. To avoid confusing merge conflicts,
      we aim to progress concept, variable template, and universal template parameters before proposing indexing
      of template parameters packs. But our hope is to complete the feature for C++26 so that indexing works on all kinds of packs.
      Packs of universal template parameters could and should be indexed in the same way.
\end{itemize}

Other features are more evolutionary but this paper left the design open to allow coherent design of:
\begin{itemize}
\item From-the-end-indexing
\item Pack slicing (returning a subset of a pack as an unexpanded pack) as discussed in \paper{P1858R0} and \paper{P2632R0}.
\item Indexing packs of arbitrary expressions, as described below.
\end{itemize}


\subsection{Extending pack indexing to arbitrary expressions}

In this proposal, we limit pack-index expressions to index a pack of \grammarterm{id-expression}{s},
which then denotes a function parameter pack, NTTP pack or, the pack introduced by a structured binding.

The reasons for that is that it is more readable and easier on the compiler to first index a pack,
and then construct an expression around that, rather than construct an arbitrarily complex pattern,
expand it, and reject all but one of the expanded elements - especially as substitution failures could occur.

Nevertheless, in the presence of multiple packs, being able to index arbitrary complex might improve code readability slightly,
which would be the one motivation for this feature.

\begin{colorblock}
void g(auto&&);
template <typename...T>
void f(T&&... t) {
    g(std::forward<T...[0]>(t...[0])); // current proposal
    g(std::forward<T>(t)...[0]); // not proposed nor implemented
}
\end{colorblock}

This is a possible evolution of this feature that can be explored but we should understand what would be the viable implementation strategies so that a compiler can avoid instantiating expressions that are not used.

\section{Potential impact on existing code}

In C++23, \tcode{T... [N]} is a valid syntax for declaring a function parameter matching a pack of unnamed arrays of size N:

\begin{colorblock}
template <typename... T>
void f(T... [1]); //
int main() {
    f<int, double>(nullptr, nullptr); // void f<int, double>(int [1], double [1])
}
\end{colorblock}

Neither MSVC nor GCC supports this syntax and this pattern does not appear outside of compiler test suites (from a search on \href{https://cs.github.com/}{Github}, \href{https://codesearch.isocpp.org/cgi-bin/cgi_ppsearch?q=...%5B&search=Search}{isocpp} and in VCPKG).
The fact that 2 major compilers did not implement this syntax in over a decade is indicative of its lack of usefulness.

Should anyone be affected, a workaround is to name the variable:

\begin{colorblock}
template <typename... T>
void f(T... foo[1]);
\end{colorblock}

See this linked \href{https://godbolt.org/z/T7v3ETz1G}{demonstration}.

\section{Implementation}

This proposal is inspired by features implemented in the Circle compiler (with the same syntax).
The provided wording is based on an implementation in a fork of Clang, which is available on \href{https://compiler-explorer.com/z/WKobTEq6x}{Compiler Explorer}.

\section{Wording}

\rSec2[basic.lookup.qual]{Qualified name lookup}

\rSec3[basic.lookup.qual.general]{General}

\pnum
\indextext{lookup!qualified name|(}%
\indextext{name!qualified}%
\indextext{qualification!explicit}%
Lookup of an \grammarterm{identifier}
followed by a \tcode{::} scope resolution operator
considers only
namespaces, types, and templates whose specializations are types.
If a name, \grammarterm{template-id}, or \grammarterm{\changed{decltype-specifier}{computed-type-specifier}}
is followed by a \tcode{::},
it shall designate a namespace, class, enumeration, or dependent type,
and the \tcode{::} is never interpreted as
a complete \grammarterm{nested-name-specifier}.


\rSec2[expr.prim.id]{Names}

\rSec3[expr.prim.id.general]{General}

\begin{bnf}
	\nontermdef{id-expression}\br
	unqualified-id\br
	qualified-id\br
\begin{addedblock}
	pack-index-expression
\end{addedblock}
\end{bnf}

\rSec3[expr.prim.id.unqual]{Unqualified names}


% Modify id-expression to add another level for (un)qualified-id (id)
% a pack-expression => restrict to identifier

% check the order of pack specifier to appear last everywhere it is mentioned.

% introduce complex type specifier

\begin{bnf}
    \nontermdef{unqualified-id}\br
    identifier\br
    operator-function-id\br
    conversion-function-id\br
    literal-operator-id\br
    \terminal{\~} type-name\br
    \terminal{\~} \changed{decltype-specifier}{computed-type-specifier}\br
    template-id
\end{bnf}

\pnum
\indextext{identifier}
An \grammarterm{identifier} is only
an \grammarterm{id-expression} if it has
been suitably declared \iref{dcl.dcl}
or if it appears as part of a \grammarterm{declarator-id} \iref{dcl.decl}.
An \grammarterm{identifier} that names a coroutine parameter
refers to the copy of the parameter \iref{dcl.fct.def.coroutine}.

\begin{note}
    For \grammarterm{operator-function-id}{s}, see~\ref{over.oper}; for
    \grammarterm{conversion-function-id}{s}, see~\ref{class.conv.fct}; for
    \grammarterm{literal-operator-id}{s}, see~\ref{over.literal}; for
    \grammarterm{template-id}{s}, see~\ref{temp.names}.
    A \grammarterm{type-name} or \grammarterm{ \changed{decltype-specifier}{computed-type-specifier}}
    prefixed by \tcode{\~} denotes the destructor of the type so named;
    see~\ref{expr.prim.id.dtor}.
    Within the definition of a non-static member function, an
    \grammarterm{identifier} that names a non-static member is transformed to a
    class member access expression \iref{class.mfct.non.static}.
\end{note}

\pnum
A \defn{component name} of an \grammarterm{unqualified-id} $U$ is
\begin{itemize}
    \item
    $U$ if it is a name or
    \item
    the component name of
    the \grammarterm{template-id} or \grammarterm{type-name} of $U$, if any.
\end{itemize}

\begin{note}
    Other constructs that contain names to look up can have several
    component names \iref{expr.prim.id.qual, dcl.type.simple, dcl.type.elab,
        dcl.mptr, namespace.udecl, temp.param, temp.names, temp.res}.
\end{note}

The \defnadj{terminal}{name} of a construct is
the component name of that construct that appears lexically last.


\rSec3[expr.prim.id.qual]{Qualified names}

\indextext{operator!scope resolution}%
\indextext{\idxcode{::}|see{operator, scope resolution}}%
%
\begin{bnf}
    \nontermdef{qualified-id}\br
    nested-name-specifier \opt{\keyword{template}} unqualified-id
\end{bnf}

\indextext{operator!scope resolution}%
\indextext{name hiding}%
%
\begin{bnf}
    \nontermdef{nested-name-specifier}\br
    \terminal{::}\br
    type-name \terminal{::}\br
    namespace-name \terminal{::}\br
    \changed{decltype-specifier}{computed-type-specifier} \terminal{::}\br
    nested-name-specifier identifier \terminal{::}\br
    nested-name-specifier \opt{\keyword{template}} simple-template-id \terminal{::}
\end{bnf}

\pnum
\indextext{component name}%
The component names of a \grammarterm{qualified-id} are those of
its \grammarterm{nested-name-specifier} and \grammarterm{unqualified-id}.
The component names of a \grammarterm{nested-name-specifier} are
its \grammarterm{identifier} (if any) and those of its
\grammarterm{type-name},
\grammarterm{namespace-name},
\grammarterm{simple-template-id}, and/or
\grammarterm{nested-name-specifier}.

\pnum
A \grammarterm{nested-name-specifier} is \defn{declarative} if it is part of
\begin{itemize}
    \item
    a \grammarterm{class-head-name},
    \item
    an \grammarterm{enum-head-name},
    \item
    a \grammarterm{qualified-id}
    that is the \grammarterm{id-expression} of a \grammarterm{declarator-id}, or
    \item
    a declarative \grammarterm{nested-name-specifier}.
\end{itemize}
A declarative \grammarterm{nested-name-specifier}
shall not have a \grammarterm{decltype-specifier}.
A declaration that uses a declarative \grammarterm{nested-name-specifier}
shall be a friend declaration or
inhabit a scope that contains the entity being redeclared or specialized.

\pnum
The \grammarterm{nested-name-specifier} \tcode{::} nominates
the global namespace.
A \grammarterm{nested-name-specifier} with a \grammarterm{\changed{decltype-specifier}{computed-type-specifier}}
nominates the type denoted by the \grammarterm{\changed{decltype-specifier}{computed-type-specifier}},
which shall be a class or enumeration type.
If a \grammarterm{nested-name-specifier} $N$
is declarative and
has a \grammarterm{simple-template-id} with a template argument list $A$
that involves a template parameter,
let $T$ be the template nominated by $N$ without $A$.
$T$ shall be a class template.
\begin{itemize}
    \item
    {If $A$ is the template argument list \iref{temp.arg} of
    the corresponding \grammarterm{template-head} $H$ \iref{temp.mem},
    $N$ nominates the primary template of $T$;
    $H$ shall be equivalent to
    the \grammarterm{template-head} of $T$ \iref{temp.over.link}.}
    \item
    {Otherwise, $N$ nominates the partial specialization \iref{temp.spec.partial} of $T$
    whose template argument list is equivalent to $A$ \iref{temp.over.link};
    the program is ill-formed if no such partial specialization exists.}
\end{itemize}
Any other \grammarterm{nested-name-specifier} nominates
the entity denoted by its
\grammarterm{type-name},
\grammarterm{namespace-name},
\grammarterm{identifier}, \removed{or}
\grammarterm{simple-template-id}.
If the \grammarterm{nested-name-specifier} is not declarative,
the entity shall not be a template.

\pnum
A \grammarterm{qualified-id} shall not be of the form
\grammarterm{nested-name-specifier} \opt{\keyword{template}} \tcode{\~}
\grammarterm{\changed{decltype-specifier}{computed-type-specifier}} nor of the form
\grammarterm{\changed{decltype-specifier}{computed-type-specifier}} \tcode{::} \tcode{\~} \grammarterm{type-name}.

\pnum
The result of a \grammarterm{qualified-id} $Q$ is
the entity it denotes \iref{basic.lookup.qual}.
The type of the expression is the type of the result.
The result is an lvalue if the member is
\begin{itemize}
    \item
    a function other than a non-static member function,
    \item
    a non-static member function
    if $Q$ is the operand of a unary \tcode{\&} operator,
    \item
    a variable,
    \item
    a structured binding \iref{dcl.struct.bind}, or
    \item
    a data member,
\end{itemize}
and a prvalue otherwise.

\begin{addedblock}
\ednote{Add a new section after [expr.prim.id.qual]}

\rSec3[expr.prim.pack.index]{Pack indexing expression}

\begin{bnf}
    \nontermdef{pack-index-expression}\br
    id-expression \terminal{...} \terminal{[} constant-expression \terminal{]}  \br
\end{bnf}

The \grammarterm{id-expression} $P$  in a \grammarterm{pack-index-expression} shall be an \grammarterm{identifier} that denotes a pack.

The \grammarterm{constant-expression} shall be a converted constant expression [expr.const] of type \tcode{std::size_t} whose value $V$, termed the index, is such that $0 \le V < \tcode{sizeof...(P)}$.

A \grammarterm{pack-index-expression} is a pack expansion ([temp.variadic]).

\begin{note}
A \grammarterm{pack-index-expression} denotes the $V$\textsuperscript{th} element of the pack ([temp.variadic]).
\end{note}

\end{addedblock}

\rSec3[expr.unary.op]{Unary operators}

\ednote{Modify [expr.unary.op]/p10}

\pnum
\indextext{operator!ones' complement}%
The operand of the \tcode{\~{}} operator shall have integral or unscoped enumeration type.
Integral promotions are performed.
The type of the result is the type of the promoted operand.
% FIXME: [basic.fundamental]/p5 uses $x_i$; [expr] uses $\tcode{x}_i$.
Given the coefficients $\tcode{x}_i$
of the base-2 representation\iref{basic.fundamental}
of the promoted operand \tcode{x},
the coefficient $\tcode{r}_i$
of the base-2 representation of the result \tcode{r}
is 1 if $\tcode{x}_i$ is 0, and 0 otherwise.
\begin{note}
	The result is the ones' complement of the operand
	(where operand and result are considered as unsigned).
\end{note}
There is an ambiguity
in the grammar when \tcode{\~{}} is followed by
a \grammarterm{type-name} or \grammarterm{\changed{decltype-specifier}{computed-type-specifier}}.
The ambiguity is resolved by treating \tcode{\~{}} as the
operator rather than as the start of an \grammarterm{unqualified-id}
naming a destructor.
\begin{note}
	Because the grammar does not permit an operator to follow the
	\tcode{.}, \tcode{->}, or \tcode{::} tokens, a \tcode{\~{}} followed by
	a \grammarterm{type-name} or \grammarterm{\changed{decltype-specifier}{computed-type-specifier}} in a
	member access expression or \grammarterm{qualified-id} is
	unambiguously parsed as a destructor name.
\end{note}

\rSec2[dcl.name]{Type names}

\pnum
\indextext{type name}%
To specify type conversions explicitly,
\indextext{operator!cast}%
and as an argument of
\tcode{sizeof},
\tcode{alignof},
\keyword{new},
or
\tcode{typeid},
the name of a type shall be specified.
This can be done with a
\grammarterm{type-id},
which is syntactically a declaration for a variable or function
of that type that omits the name of the entity.

\begin{bnf}
    \nontermdef{type-id}\br
    type-specifier-seq \opt{abstract-declarator}
\end{bnf}

\begin{bnf}
    \nontermdef{defining-type-id}\br
    defining-type-specifier-seq \opt{abstract-declarator}
\end{bnf}

\begin{bnf}
    \nontermdef{abstract-declarator}\br
    ptr-abstract-declarator\br
    \opt{noptr-abstract-declarator} parameters-and-qualifiers trailing-return-type\br
    abstract-pack-declarator
\end{bnf}

\begin{bnf}
    \nontermdef{ptr-abstract-declarator}\br
    noptr-abstract-declarator\br
    ptr-operator \opt{ptr-abstract-declarator}
\end{bnf}

\begin{bnf}
    \nontermdef{noptr-abstract-declarator}\br
    \opt{noptr-abstract-declarator} parameters-and-qualifiers\br
    \opt{noptr-abstract-declarator} \terminal{[} \opt{constant-expression} \terminal{]} \opt{attribute-specifier-seq}\br
    \terminal{(} ptr-abstract-declarator \terminal{)}
\end{bnf}

\begin{bnf}
    \nontermdef{abstract-pack-declarator}\br
    noptr-abstract-pack-declarator\br
    ptr-operator abstract-pack-declarator
\end{bnf}

\begin{bnf}
    \nontermdef{noptr-abstract-pack-declarator}\br
    noptr-abstract-pack-declarator parameters-and-qualifiers\br
    \removed{noptr-abstract-pack-declarator \terminal{[} \opt{constant-expression} \terminal{]} \opt{attribute-specifier-seq}}\br
    \terminal{...}
\end{bnf}

\ednote{The sequence \tcode{...[constant-expression]} should always be treated as pack indexing. However we may want to allow \tcode{T(\&...)[constant-expression]},
which is the object of \paper{CWG1488}}

\ednote{[...]}

\rSec3[dcl.type.simple]{Simple type specifiers}%
\indextext{type specifier!simple}

\pnum
The simple type specifiers are

\begin{bnf}
\nontermdef{simple-type-specifier}\br
\opt{nested-name-specifier} type-name\br
nested-name-specifier \keyword{template} simple-template-id\br\textbf{}
\changed{decltype-specifier}{computed-type-specifier}\br
placeholder-type-specifier\br
\opt{nested-name-specifier} template-name\br
\end{bnf}

\begin{addedblock}
\begin{bnf}
\nontermdef{computed-type-specifier}\br
decltype-specifier\br
pack-index-specifier\br
\end{bnf}
\end{addedblock}

\textcolor{noteclr}{[...]}

\begin{simpletypetable}
    {\grammarterm{simple-type-specifier}{s} and the types they specify}
    {dcl.type.simple}
    {ll}
    \topline
    \hdstyle{Specifier(s)}            &   \hdstyle{Type}                  \\ \capsep
    \grammarterm{type-name}           & the type named                    \\
    \grammarterm{simple-template-id}  & the type as defined in [temp.names]\\
    \grammarterm{decltype-specifier}  & the type as defined in [dcl.type.decltype]\\
    \added{\grammarterm{pack-index-specifier}} & \added{the type as defined in [dcl.type.pack.indexing]} \\
    \grammarterm{placeholder-type-specifier}
    & the type as defined in [dcl.spec.auto]\\
    \grammarterm{template-name}       & the type as defined in [dcl.type.class.deduct]\\
    \tcode{char}                      & ``\tcode{char}''                  \\
    \tcode{unsigned char}             & ``\tcode{unsigned char}''         \\
    \tcode{signed char}               & ``\tcode{signed char}''           \\
    \keyword{char8_t}                   & ``\tcode{char8_t}''               \\
    \keyword{char16_t}                  & ``\tcode{char16_t}''              \\
    ... & \\
\end{simpletypetable}


\pnum
When multiple \grammarterm{simple-type-specifier}{s} are allowed, they can be
freely intermixed with other \grammarterm{decl-specifier}{s} in any order.
\begin{note}
    It is \impldef{signedness of \tcode{char}} whether objects of \tcode{char} type are
    represented as signed or unsigned quantities. The \tcode{signed} specifier
    forces \tcode{char} objects to be signed; it is redundant in other contexts.
\end{note}


\ednote{Add a new section after [dcl.type.simple]}


\begin{addedblock}

\rSec3[dcl.type.pack.indexing]{Pack indexing specifier}

\begin{bnf}
    \nontermdef{pack-index-specifier}\br
    typedef-name \terminal{...} \terminal{[} constant-expression \terminal{]}  \br
\end{bnf}

The \grammarterm{typedef-name} $P$ in a \grammarterm{pack-index-specifier} shall denote a pack.

The \grammarterm{constant-expression} shall be a converted constant expression [expr.const] of type \tcode{std::size_t} whose value $V$, termed the index, is such that $0 \le V < \tcode{sizeof...(P)}$.

A \grammarterm{pack-index-specifier} is a pack expansion ([temp.variadic]).

\begin{note}
The \grammarterm{pack-index-specifier} denotes the type of the ${V}$\textsuperscript{th} element of the pack ([temp.variadic]).
\end{note}

\end{addedblock}



\rSec3[dcl.type.decltype]{Decltype specifiers}%
\indextext{type specifier!\idxcode{decltype}}%

\begin{bnf}
    \nontermdef{decltype-specifier}\br
    \keyword{decltype} \terminal{(} expression \terminal{)}
\end{bnf}

\pnum
\indextext{type specifier!\idxcode{decltype}}%
For an expression $E$, the type denoted by \tcode{decltype($E$)} is defined as follows:
\begin{itemize}
\item if $E$ is an unparenthesized \grammarterm{id-expression}
naming a structured binding \iref{dcl.struct.bind},
\tcode{decltype($E$)} is the referenced type as given in
the specification of the structured binding declaration;

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression}
naming a non-type \grammarterm{template-parameter} \iref{temp.param},
\tcode{decltype($E$)} is the type of the \grammarterm{template-parameter}
after performing any necessary
type deduction \iref{dcl.spec.auto, dcl.type.class.deduct};

\item otherwise, if $E$ is an unparenthesized \grammarterm{id-expression} or
an unparenthesized
class
member access \iref{expr.ref}, \tcode{decltype($E$)} is the
type of the entity named by $E$.
If there is no such entity, the program is ill-formed;

\item otherwise, if $E$ is
an xvalue, \tcode{decltype($E$)} is \tcode{T\&\&}, where \tcode{T} is the type
of $E$;

\item otherwise, if $E$ is an lvalue, \tcode{decltype($E$)}
is \tcode{T\&}, where \tcode{T} is the type of $E$;

\item otherwise, \tcode{decltype($E$)} is the type of $E$.
\end{itemize}

The operand of the \keyword{decltype} specifier is an unevaluated
operand \iref{term.unevaluated.operand}.

\begin{example}
    \begin{codeblock}
        const int&& foo();
        int i;
        struct A { double x; };
        const A* a = new A();
        decltype(foo()) x1 = 17;        // type is \tcode{const int\&\&}
        decltype(i) x2;                 // type is \tcode{int}
        decltype(a->x) x3;              // type is \tcode{double}
        decltype((a->x)) x4 = x3;       // type is \tcode{const double\&}
        \end{codeblock}
        \begin{addedblock}
        \begin{codeblock}
        [](auto... pack){
            decltype(pack...[0])   x5;  // type is \tcode{int}
            decltype((pack...[0])) x6;  // type is \tcode{int\&}
        }(0);
        \end{codeblock}
        \end{addedblock}
\end{example}


\rSec1[class]{Classes}

\rSec2[class.dtor]{Destructors}%


\pnum
\indextext{destructor!explicit call}%
In an explicit destructor call, the destructor is specified by a
\tcode{\~{}}
followed by a
\grammarterm{type-name} or \grammarterm{\changed{decltype-specifier}{computed-type-specifier}}
that denotes the destructor's class type.
The invocation of a destructor is subject to the usual rules for member
functions \iref{class.mfct};
that is, if the object is not of the destructor's class type and
not of a class derived from the destructor's class type (including when
the destructor is invoked via a null pointer value), the program has
undefined behavior.

\rSec1[class.derived]{Derived classes}%

\rSec2[class.derived.general]{General}%
\indextext{derived class|(}

\indextext{virtual base class|see{base class, virtual}}
\indextext{virtual function|see{function, virtual}}
\indextext{dynamic binding|see{function, virtual}}

\pnum
\indextext{base class}%
\indextext{inheritance}%
\indextext{multiple inheritance}%
A list of base classes can be specified in a class definition using
the notation:

\begin{bnf}
    \nontermdef{base-clause}\br
    \terminal{:} base-specifier-list
\end{bnf}


\begin{bnf}
    \nontermdef{base-specifier-list}\br
    base-specifier \opt{\terminal{...}}\br
    base-specifier-list \terminal{,} base-specifier \opt{\terminal{...}}
\end{bnf}

\begin{bnf}
    \nontermdef{base-specifier}\br\br
   \small{\opt{attribute-specifier-seq} \changed{class-or-decltype}{class-or-computed-type-specifier}}\br\br
    \opt{attribute-specifier-seq} \keyword{virtual} \opt{access-specifier}    \changed{class-or-decltype}{class-or-computed-type-specifier}\br\br
    \opt{attribute-specifier-seq} access-specifier \opt{\keyword{virtual}} \changed{class-or-decltype}{class-or-computed-type-specifier}\br
\end{bnf}


\begin{bnf}
    \nontermdef{\changed{class-or-decltype}{class-or-computed-type-specifier}}\br
    \opt{nested-name-specifier} type-name\br
    nested-name-specifier \keyword{template} simple-template-id\br
    \changed{decltype-specifier}{computed-type-specifier}
\end{bnf}

\indextext{specifier access|see{access specifier}}%
%
\begin{bnf}
    \nontermdef{access-specifier}\br
    \keyword{private}\br
    \keyword{protected}\br
    \keyword{public}
\end{bnf}


\rSec1[temp.type]{Type equivalence}

\pnum
If an expression $e$ is type-dependent \iref{temp.dep.expr},
\tcode{decltype($e$)}
denotes a unique dependent type. Two such \grammarterm{decltype-specifier}{s}
refer to the same type only if their \grammarterm{expression}{s} are
equivalent \iref{temp.over.link}.
\begin{note} % lah: Thios note in the Standard draft is label "Note 1", not just "Note".
    However, such a type might be aliased,
    e.g., by a \grammarterm{typedef-name}.
\end{note}

\begin{addedblock}
For a type template parameter pack \tcode{T}, \tcode{T...[\grammarterm{constant-expression}{}]} denotes a unique dependent type.

If the \grammarterm{constant-expression} of a \grammarterm{pack-index-specifier} is value-dependent, two such \grammarterm{pack-index-specifier}{s} refer to the same type only if their \grammarterm{constant-expression}{s} are equivalent \iref{temp.over.link}.

Otherwise, two such \grammarterm{pack-index-specifier}{s} refer to the same type only if their indexes have the same value.

\end{addedblock}

\rSec2[temp.variadic]{Variadic templates}

\textcolor{noteclr}{[...]}

\pnum
\indextext{pattern|see{pack expansion, pattern}}%
A \defn{pack expansion}
consists of a \defnx{pattern}{pack expansion!pattern} and an ellipsis, the instantiation of which
produces zero or more instantiations of the pattern in a list (described below).
The form of the pattern
depends on the context in which the expansion occurs. Pack
expansions can occur in the following contexts:

\begin{itemize}
    \item In a function parameter pack \iref{dcl.fct}; the pattern is the
    \grammarterm{parameter-declaration} without the ellipsis.

    \item In a \grammarterm{using-declaration} \iref{namespace.udecl};
    the pattern is a \grammarterm{using-declarator}.

    \item In a template parameter pack that is a pack expansion \iref{temp.param}:
    \begin{itemize}
        \item
        if the template parameter pack is a \grammarterm{parameter-declaration};
        the pattern is the \grammarterm{parameter-declaration} without the ellipsis;

        \item
        if the template parameter pack is a \grammarterm{type-parameter};
        the pattern is the corresponding \grammarterm{type-parameter}
        without the ellipsis.
    \end{itemize}

    \item In an \grammarterm{initializer-list} \iref{dcl.init};
    the pattern is an \grammarterm{initializer-clause}.

    \item In a \grammarterm{base-specifier-list} \iref{class.derived};
    the pattern is a \grammarterm{base-specifier}.

    \item In a \grammarterm{mem-initializer-list} \iref{class.base.init} for a
    \grammarterm{mem-initializer} whose \grammarterm{mem-initializer-id} denotes a
    base class; the pattern is the \grammarterm{mem-initializer}.

    \item In a \grammarterm{template-argument-list} \iref{temp.arg};
    the pattern is a \grammarterm{template-argument}.

    \item In an \grammarterm{attribute-list} \iref{dcl.attr.grammar}; the pattern is
    an \grammarterm{attribute}.

    \item In an \grammarterm{alignment-specifier} \iref{dcl.align}; the pattern is
    the \grammarterm{alignment-specifier} without the ellipsis.

    \item In a \grammarterm{capture-list} \iref{expr.prim.lambda.capture}; the pattern is
    the \grammarterm{capture} without the ellipsis.

    \item In a \tcode{sizeof...} expression \iref{expr.sizeof}; the pattern is an
    \grammarterm{identifier}.

    \begin{addedblock}
    \item In a \grammarterm{pack-index-expression}; the pattern is an
    \grammarterm{identifier}.
    \item In a \grammarterm{pack-index-specifier}; the pattern is a
    \grammarterm{typedef-name}.
    \end{addedblock}

    \item In a \grammarterm{fold-expression} \iref{expr.prim.fold};
    the pattern is the \grammarterm{cast-expression}
    that contains an unexpanded pack.
\end{itemize}

\begin{example} % lah: this is labeled Example 4 in the Standard's draft.
    \begin{codeblock}
        template<class ... Types> void f(Types ... rest);
        template<class ... Types> void g(Types ... rest) {
            f(&rest ...);     // ``\tcode{\&rest ...}'' is a pack expansion; ``\tcode{\&rest}'' is its pattern
        }
    \end{codeblock}
\end{example}

\pnum
For the purpose of determining whether a pack satisfies a rule
regarding entities other than packs, the pack is
considered to be the entity that would result from an instantiation of
the pattern in which it appears.

\pnum
A pack whose name appears within the pattern of a pack
expansion is expanded by that pack expansion. An appearance of the name of
a pack is only expanded by the innermost enclosing pack expansion.
The pattern of a pack expansion shall name one or more packs that
are not expanded by a nested pack expansion; such packs are called
\defnx{unexpanded packs}{pack!unexpanded} in the pattern. All of the packs expanded
by a pack expansion shall have the same number of arguments specified. An
appearance of a name of a pack that is not expanded is
ill-formed.
\begin{example} % lah: this is labeled Example 5 in the Standard's draft.
    \begin{codeblock}
        template<typename...> struct Tuple {};
        template<typename T1, typename T2> struct Pair {};

        template<class ... Args1> struct zip {
            template<class ... Args2> struct with {
                typedef Tuple<Pair<Args1, Args2> ... > type;
            };
        };

        typedef zip<short, int>::with<unsigned short, unsigned>::type T1;
        // \tcode{T1} is \tcode{Tuple<Pair<short, unsigned short>, Pair<int, unsigned>>}
        typedef zip<short>::with<unsigned short, unsigned>::type T2;
        // error: different number of arguments specified for \tcode{Args1} and \tcode{Args2}

        template<class ... Args>
        void g(Args ... args) {                   // OK, \tcode{Args} is expanded by the function parameter pack \tcode{args}
            f(const_cast<const Args*>(&args)...);   // OK, ``\tcode{Args}'' and ``\tcode{args}'' are expanded
            f(5 ...);                               // error: pattern does not contain any packs
            f(args);                                // error: pack ``\tcode{args}'' is not expanded
            f(h(args ...) + args ...);              // OK, first ``\tcode{args}'' expanded within \tcode{h},
            // second ``\tcode{args}'' expanded within \tcode{f}
        }
    \end{codeblock}
\end{example}

\pnum
The instantiation of a pack expansion considers
items $\tcode{E}_1, \tcode{E}_2, \dotsc, \tcode{E}_N$,
where
$N$ is the number of elements in the pack expansion parameters.
Each $\tcode{E}_i$ is generated by instantiating the pattern and
replacing each pack expansion parameter with its $i^\text{th}$ element.
Such an element, in the context of the instantiation, is interpreted as
follows:
\begin{itemize}
    \item
    if the pack is a template parameter pack, the element is
    an \grammarterm{id-expression}
    (for a non-type template parameter pack),
    a \grammarterm{typedef-name}
    (for a type template parameter pack declared without \tcode{template}), or
    a \grammarterm{template-name}
    (for a type template parameter pack declared with \tcode{template}),
    designating the $i^\text{th}$ corresponding type or value template argument;

    \item
    if the pack is a function parameter pack, the element is an
    \grammarterm{id-expression}
    designating the $i^\text{th}$ function parameter
    that resulted from instantiation of
    the function parameter pack declaration;
    otherwise

    \item
    if the pack is an \grammarterm{init-capture} pack,
    the element is an \grammarterm{id-expression}
    designating the variable introduced by
    the $i^\text{th}$ \grammarterm{init-capture}
    that resulted from instantiation of
    the \grammarterm{init-capture} pack.
\end{itemize}
When $N$ is zero, the instantiation of a pack expansion
does not alter the syntactic interpretation of the enclosing construct,
even in cases where omitting the pack expansion entirely would
otherwise be ill-formed or would result in an ambiguity in the grammar.

\pnum
The instantiation of a \tcode{sizeof...} expression \iref{expr.sizeof} produces
an integral constant with value $N$.

\begin{addedblock}
\pnum

When instantiating a \grammarterm{pack-index-expression} $P$,
let $K$ be the index of $P$.
The instantiation of $P$ is the \grammarterm{id-expression} \tcode{$\mathtt{E}_K$}.


When instantiating a \grammarterm{pack-index-specifier} $P$,
let $K$ be the index of $P$.
The instantiation of $P$ is the \grammarterm{typedef-name} \tcode{$\mathtt{E}_K$}.
\end{addedblock}


\rSec3[temp.dep.type]{Dependent types}

\ednote{Add a bullet in paragraph 7}

\pnum
A type is dependent if it is
\begin{itemize}
	\item
	a template parameter,
	\item
	denoted by a dependent (qualified) name,
	\item
	a nested class or enumeration that is a direct member of
	a class that is the current instantiation,
	\item
	a cv-qualified type where the cv-unqualified type is dependent,
	\item
	a compound type constructed from any dependent type,
	\item
	an array type whose element type is dependent or whose
	bound (if any) is value-dependent,
	\item
	a function type whose parameters include one or more function parameter packs,
	\item
	a function type whose exception specification is value-dependent,
	\item
	denoted by a \grammarterm{simple-template-id}
	in which either the template name is a template parameter or any of the
	template arguments is a dependent type or an expression that is type-dependent
	or value-dependent or is a pack expansion,
\begin{addedblock}
	\item a \grammarterm{pack-index-specifier},
\end{addedblock}
	or
	\item denoted by \tcode{decltype(}\grammarterm{expression}{}\tcode{)},
	where \grammarterm{expression} is type-dependent\iref{temp.dep.expr}.
\end{itemize}

\rSec3[temp.dep.expr]{Type-dependent expressions}

\ednote{Add a paragraph at the end of temp.dep.expr}

\pnum
A \grammarterm{braced-init-list} is type-dependent if any element is
type-dependent or is a pack expansion.

\pnum
A \grammarterm{fold-expression} is type-dependent.

\begin{addedblock}
	\pnum
	A \grammarterm{pack-index-expression} is type-dependent if its \grammarterm{id-expression} is type-dependent.
\end{addedblock}

\textcolor{noteclr}{[...]}

\rSec3[temp.deduct.type]{Deducing template arguments from a type}

% An id-expression is type-dependent if it is a template-id that is not a concept-id and is dependent; OR it it a pack expression whose constant expression is a constant expression OR or if its terminal name is

% modify class.base.init.

\pnum
The non-deduced contexts are:

\indextext{context!non-deduced}%
\begin{itemize}
    \item
    The
    \grammarterm{nested-name-specifier}
    of a type that was specified using a
    \grammarterm{qualified-id}.
    \begin{addedblock}
    \item A \grammarterm{pack-index-specifier} or a \grammarterm{pack-index-expression}.
    \end{addedblock}
    \item
    The \grammarterm{expression} of a \grammarterm{decltype-specifier}.
    \item
    A non-type template argument or an array bound in which a subexpression
    references a template parameter.
    \item
    A template parameter used in the parameter type of a function parameter that
    has a default argument that is being used in the call for which argument
    deduction is being done.
    \item
    A function parameter for which the associated argument is an
    overload set \iref{over.over}, and one or more of the following apply:
    \begin{itemize}
        \item
        more than one function matches the function parameter type (resulting in
        an ambiguous deduction), or
        \item
        no function matches the function parameter type, or
        \item
        the overload set supplied as an argument contains one or more function templates.
    \end{itemize}
    \item A function parameter for which the associated argument is an initializer
    list \iref{dcl.init.list} but the parameter does not have
    a type for which deduction from an initializer list is specified \iref{temp.deduct.call}.
    \begin{example}
        \begin{codeblock}
            template<class T> void g(T);
            g({1,2,3});                 // error: no argument deduced for \tcode{T}
        \end{codeblock}
    \end{example}
    \item A function parameter pack that does not occur at the end of the
    \grammarterm{parameter-declaration-list}.
\end{itemize}


\begin{addedblock}

\rSec1[diff.cpp23]{C++ and ISO C++23}

\rSec2[diff.cpp23.dcl.dcl]{Declarations}

\rSec3[decl.array]
\change
Previously, \tcode{T...[$n$]} would declare a pack of function parameters.
\tcode{T...[$n$]} is now a \grammarterm{pack-index-specifier}.
\rationale
Improve the handling of packs.
\effect
Valid C++23 code that declares a pack of parameter without specifying a \tcode{declarator-id} becomes ill-formed.

\begin{codeblock}
template <typename... T>
void f(T... [1]);
template <typename... T>
void g(T... ptr[1]);

int main() {
    f<int, double>(nullptr, nullptr); // ill-formed, previously void f<int, double>(int [1], double [1])
    g<int, double>(nullptr, nullptr); // ok
}
\end{codeblock}

\begin{colorblock}

\end{colorblock}

\end{addedblock}

\section{Feature test macros}

\ednote{Add a new macro in \tcode{[tab:cpp.predefined.ft]} : \tcode{__cpp_pack_indexing} set to the date of adoption}.


\section{Acknowledgments}

We extend our appreciation to Sean Baxter for his work on Circle and to Barry Revzin for his work on \paper{P1858R2}, both works being the foundation of the design presented here.

Thanks also to Lewis Baker for his valuable feedback on this paper, Nina Dinka Ranns for her help with wording, and Lori Hughes for editing this paper.

\section{References} % lah: Correct your citation style. Books, proceedings, conference names, and Standards use italics. Articles, presentations, and talks use quotes. Harvard style is the general UK convention. https://intranet.birmingham.ac.uk/as/libraryservices/library/referencing/icite/harvard/referencelist.aspx

\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21, extra}

\begin{thebibliography}{9}

\bibitem[P2632R0]{P2632R0}
Corentin Jabot, Pablo Halpern, John Lakos, Alisdair Meredith, Joshua Berne, and Gašper Ažman\newline
\emph{A plan for better template meta programming facilities in C++26}\newline
\url{https://wg21.link/P2632R0}\newline
October 2022

\bibitem[N4885]{N4885}
Thomas Köppe
\emph{Working Draft, Standard for Programming Language C++}\newline
\url{https://wg21.link/N4885}


\end{thebibliography}

\end{document}
