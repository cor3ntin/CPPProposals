% !TeX program = luatex
% !TEX encoding = UTF-8


\RequirePackage{luatex85}%
\documentclass{wg21}
\usepackage{threeparttable}
\usepackage{adjustbox}
\usepackage{xcolor,colortbl}
\usepackage{array}
\newcolumntype{?}{!{\vrule width 1pt}}

\title{\tcode{std::generator}: Synchronous Coroutine Generator for Ranges}
\docnumber{D2168R5}
\audience{LEWG}
\author{Lewis Baker}{lewissbaker@gmail.com}
\authortwo{Corentin Jabot}{corentin.jabot@gmail.com}

\begin{document}
\maketitle


\section{Abstract}

We propose a standard library type \tcode{std::generator} which implements a coroutine generator compatible with ranges.


\section{Revisions}

\subsection{R4}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{R3}
\begin{itemize}
\item Wording improvements
\end{itemize}

\subsection{R2}
\begin{itemize}
\item Some wording fixes
\item Improve the section on allocator support
\item Updated implementation
\end{itemize}

\subsection{R1}
\begin{itemize}
\item Add benchmarks results and discussion about performance
\item Introduce \tcode{elements_of} to avoid ambiguities when a generator is convertible to the reference type of the parent generator.
\item Add allocator support
\item Symmetric transfer works with generators of different value / allocator types
\item Remove \tcode{iterator::operator->}
\item Put \tcode{generator} in a new \tcode{<generator>} header.
\item Add an other example to motivate the \tcode{Value} template parameter
\end{itemize}


\section{Example}

\begin{colorblock}
    std::generator<int> fib (int max) {
        co_yield 0;
        auto a = 0, b = 1;

        for(auto n : std::views::iota(0, max))  {
            auto next = a + b;
            a = b, b = next;
            co_yield next;
        }
    }

    int answer_to_the_universe() {
        auto coro = fib(7) ;
        return std::accumulate(coro | std::views::drop(5), 0);
    }

\end{colorblock}

\section{Motivation}

C++ 20 had very minimalist library support for coroutines.
Synchronous generators are an important use case for coroutines, one that cannot be supported without
the machinery presented in this paper.
Writing an efficient and correctly behaving recursive generator is non-trivial. The standard should provide one.


\section{Design}

While the proposed \tcode{std::generator} interface is fairly straightforward, a few decisions are worth pointing out.

\subsection{\tcode{input_view}}

\tcode{std::generator} is a non-copyable \tcode{view} which models \tcode{input_range} and spawn move-only iterators.
This is because the coroutine state is a unique resource (even if the coroutine \textit{handle} is copyable).
Unfortunately, some generators can satisfy the \tcode{view} constraints but fail to model the \tcode{view} O(1)
destruction requirement:

\begin{colorblock}

    template <class T>
    std::generator<T> all (vector<T> vec) {
        for(auto & e : vec)  {
            co_yield e;
        }
    }

\end{colorblock}



\subsection{Header}

Multiple options are available as to where put the \tcode{generator} class.

\begin{itemize}
    \item \tcode{<coroutine>}, but \tcode{<coroutine>} is a low level header, and \tcode{generator} depends on bits of \tcode{<type_traits>} and \tcode{<iterator>}.

    \item \tcode{<ranges>}

    \item A new \tcode{<generator>}

\end{itemize}

\section{Reference type}

\tcode{generator} takes 3 template parameters:

\tcode{generator<Type, Value, Allocator>}

\begin{itemize}
\item a \tcode{Type} from which the \tcode{reference} type is derived
\item a \tcode{Value} type, whose default is derived from the Reference type, and which has a \mbox{\tcode{common\_reference}} with the reference type
\item An allocator or \tcode{use_allocator_arg} which is the default value.
\end{itemize}

Only the first parameter is required, and we expect most users to concern themselves with that first parameter, as good defaults are provided for the other two.
That first parameter controls the iterator's \tcode{reference} type. But that in turns informs both the types passed to \tcode{yield_value},
which also impacts how values are stored in the implementation.

This first \tcode{Type} parameter, therefore, does a lot of heavy lifting.
In earlier versions of this paper, the reference type was exactly the first template parameter.
This had the advantage of being simple.
But it was a terrible performance trap:

Consider the behavior of the following code assuming the reference type is exactly the first template argument:

\begin{colorblock}

generator<std::string> f() {
    std::string hello = "hello";
    co_yield hello;   // 0 or 1 copy depending on implementation
    co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
}

for(auto && str : f()) {} // 1 copy (*it returns std::string)
\end{colorblock}

Of course the solution, which we advocated for, is for the user to specify manually specify an explicit reference type:

\begin{colorblock}
    generator<const std::string&> f() {
        co_yield hello;   // 0 or 1 copy depending on implementation
        co_yield "Hello"; // 1 copy (conversion from const char* to std::string)
    }

    for(auto && str : f()) {} // 0 copy

\end{colorblock}

This works can be explained and is even logical. You get what you asked for.
It is nonetheless surprising for non-experts that it would create 2 copies.

To hope users would not routinely forget to use a reference type when using \tcode{std::generator} calls for a heaping barrel of optimism.

Instead we propose that for a \tcode{generator<T>}, its reference type be defined as\\
\tcode{conditional_t<is_reference<T>, T, std::add_lvalue_reference_t<std::add_const_t<T>>>}.

\newcommand{\cellif}{\cellcolor{red!25}IF}
\newcommand{\cellid}{\cellcolor{red!70}IF}
\newcommand{\cellbl}{\cellcolor{green!70}0}
\newcommand{\cellzr}{\cellcolor{green!25}0}
\newcommand{\cellon}{\cellcolor{orange!25}1}


\begin{tabular}{|c|c|c|c|c|}
    \hline
    First parameter &  reference type & default value& can yield mutable lvalue ref?\\ \hline
    \tcode{int} & \tcode{const int\&} & \tcode{int} & No \\ \hline
    \tcode{const int\&} & \tcode{const int\&} & \tcode{int} & No \\ \hline
    \tcode{int\&} & \tcode{int\&} & \tcode{int} & Yes \\ \hline
    \tcode{int\&\&} & \tcode{int\&\&} & \tcode{int} & No \\ \hline
    \tcode{const int\&\&} & \tcode{const int\&\&} & \tcode{int} & No \\ \hline
\end{tabular}

Attempts have been made to characterize the exact relations between reference, value, storage, and co_yield exception types and categories.
Ultimately, a simpler mental model is to characterize what expressions can be yielded for a given reference type and how many copies are made for each scenario.

\begin{tabular}{|c|c|c|c|c|}
    \hline
    First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&}& \tcode{co_yield U\&\&}\\ \hline
    \tcode{T}           & \cellbl & \cellbl & \cellbl & \cellon \\ \hline
    \tcode{const T\&}   & \cellzr & \cellzr & \cellzr & \cellon \\ \hline
    \tcode{T\&}         & \cellif & \cellzr & \cellif & \cellif \\ \hline
    \tcode{T\&\&}       & \cellif & \cellif & \cellzr & \cellon \\ \hline
    \tcode{const T\&\&} & \cellif & \cellif & \cellzr & \cellon \\ \hline
\end{tabular}

In this table, we see that only \tcode{co_yield} that requires conversion incurs copy, which is expected.
Coroutines guarantee that the yielded expression exceeds the lifetime of the \tcode{co_yield} expression,
so \tcode{generator} can only store a pointer to that reference.

\tcode{co_yield} expressions involving conversion can store the yielded value in an awaiter.
The type of the stored expression is the reference type with its reference qualifiers stripped, but that is an implementation
detail that is not observable and is therefore of limited interest. Of course, that type needs to be constructible from yielded values.

Besides the T case, this behaves very much like returning from a function that is intended.

\subsection{Move-only and immovable types}

LEWG was interested in how this works with \tcode{generator} of move-only and immovable types.


\begin{tabular}{|c|c|c|c|}
\hline
First parameter & \tcode{co_yield const T\&} & \tcode{co_yield T\&} & \tcode{co_yield T\&\&}\\ \hline
\tcode{move_only}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const move_only\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{move_only\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{move_only\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const move_only\&\&} & \cellif & \cellif & \cellzr \\ \hline \hline

\tcode{immovable}           & \cellbl & \cellbl & \cellbl \\ \hline
\tcode{const immovable\&}   & \cellzr & \cellzr & \cellzr \\ \hline
\tcode{immovable\&}         & \cellif & \cellzr & \cellif \\ \hline
\tcode{immovable\&\&}       & \cellif & \cellif & \cellzr \\ \hline
\tcode{const immovable\&\&} & \cellif & \cellif & \cellzr \\ \hline
\end{tabular}

As that table shows, these types work exactly like other types.
However, to be able to move from a move only reference type, the coroutine has to explicitely state so:

\begin{colorblock}
auto f = []() -> std::generator<move_only> { co_yield move_only{}; }();
for(auto&& x : f) {
    move_only mo = std::move(x); // ill-formed, decltype(x) is const move_only&
}

auto f = []() -> std::generator<move_only&&> { co_yield move_only{}; }();
for(auto&& x : f) {
    move_only mo = x // ok
}

auto f = []() -> std::generator<move_only&> { move_only m; co_yield m; }();
for(auto&& x : f) {
    move_only mo = std::move(x) // dicey but okay
}

\end{colorblock}

\subsection{Potential downsides}


\begin{colorblock}
auto f = []() -> std::generator<MyType> { 
    MyType t; 
    co_yield std::move(t);
}();
\end{colorblock}

In the example above \tcode{std::move} doesn't move. Arguably more than usual.
Indedd the code expands to something similar to:

\begin{colorblock}

auto && __temp = std::move(t);
yield_value(_temp); // <=> promise.value = std::addressof(__temp); // no move

\end{colorblock}

Of course, a move would not have occured for a \tcode{std::generator<const MyType\&>} either as these things are identical.
It might be suprising?
The only way to avoid that is to create temporary value for rvalue reference, which would force a move to actually occurs,
at the cost of performance.


\subsection{Alternatives considered}

\subsubsection{Mandating a reference as the first parameter}

We could make \tcode{generator<int>} ill-formed and force people to specify a reference type like \tcode{generator<const int\&>}.
We do not think this is very user-friendly, given that we can provide a reasonable default.

We rejected this option.

\subsubsection{Using \tcode{T\&} as the default}

There are two issues with mutable references:
\begin{itemize}
\item They are mutable (They allow mutating the coroutine frame), which would be an \emph{interesting} default.
\item They are very restrictive as to the set of \tcode{co_yield} expression allowed with them.
\end{itemize}

We rejected this option.

\subsubsection{Using \tcode{T\&\&} as the default}

This avoids a copy when doing \tcode{auto object = *it`} (where it is a \tcode{std::generator::iterator}),
but it is very easy to missuse, consider:

\begin{colorblock}
auto f = []() -> std::generator<std::string> { co_yield "footgun"; }();
for(auto && x : f) {
    auto y = x; // nothing suggest a move
    y.transform();
    if(x != y) {
        // always triggers, likely to be supprising
    }
}

\end{colorblock}
We rejected this option.


\subsubsection{Doing something clever for move-only types}

We considered returning \tcode{T\&} for move_only types so that they can be moved from by default.
We realized this was too clever and inconsistent.
Notably, adding a copy constructor to \tcode{T} would change the meaning of the code.

We rejected this option.

\subsubsection{Doing something clever for reference types}

By default \tcode{generator<reference_wrapper<T>>} could yield \tcode{reference_wrapper<T>} has that is already a "reference-like" type.
However, no other view does that, "reference-like" is fuzzily defined, and this would probably cause more trouble than it's worth.

We rejected this option.

\subsubsection{Keeping the R4 design}

Returning values has the potential to severely impact performance, is inconsistent with other views, and is not necessary.
It also did not work with non-copyable types.

The change, along with an implementation strategy described in the "How to store the yielded value in the promise type?" guarantees that
no copy needs to be made if the reference and yielded types are the same (with qualifiers stripped).

We think this new approach keeps the simplicity of the original design, improves performance, and works with more types.

Thank you LEWG, and in particular Mathias, for highlighting these concerns!

\subsection{Separately specifyable Value Type}

This proposal supports specifying both the "yielded" type, which is the iterator ""reference"" type (not required to be a reference) and its corresponding value type.
This allow ranges to handle proxy types and wrapped \tcode{reference}, like this implementation of \tcode{zip}:

\begin{colorblock}
    template<std::ranges::input_range Rng1,
    std::ranges::input_range Rng2>
    generator<
    std::tuple<std::ranges::range_reference_t<Rng1>,
    std::ranges::range_reference_t<Rng2>,
    std::tuple<std::ranges::range_value_type_t<Rng1>,
    std::ranges::range_value_type_t<Rng2>>>
    zip(Rng1 r1, Rng2 r2) {
        auto it1 = std::ranges::begin(r1);
        auto it2 = std::ranges::begin(r2);
        auto end1 = std::ranges::end(r1);
        auto end2 = std::ranges::end(r2);
        while (it1 != end1 && it2 != end2) {
            co_yield {*it1, *it2};
            ++it1; ++it2;
        }
    }
\end{colorblock}

In this second example, using \tcode{string} as value type ensures that calling code can take the necessary steps
to make sure iterating over a generator would not invalidate any of the yielded values

\begin{colorblock}

// Yielding string literals : always fine
std::generator<std::string_view> string_views() {
    co_yield "foo";
    co_yield "bar";
}

std::generator<std::string_view, std::string> strings() {
    co_yield "start";
    std::string s;
    for (auto sv : string_views()) {
        s = sv;
        s.push_back('!');
        co_yield s;
    }
    co_yield "end";
}

// conversion to a vector of strings
// If the value_type was string_view, it would convert to a vector of string_view,
// which would lead to undefined beavior as the string_views may get invalidated upon iteration!
auto v = std::ranges::to<vector>(strings()); // (@{\paper{P1206R3}}@)

\end{colorblock}


\subsection{How to store the yielded value in the promise type?}

There are multiple implementation strategies possible to store the value in the generator.
A previous revision of this paper always stored a copy of the yielded value, leading to an extra copy.

However, the yielded expression is guaranteed to be alive until the coroutine resumes. It is, therefore, sufficient to store
its address.

We can take advantage of that fact by only storing a pointer in the generator. When a copy needs to be made
by \tcode{yield_value} (because the yielded value is not of the same type or cannot bind to the reference type), we can store the value in an awaiter that will remain alive until the end of the co_yield expression.

\begin{colorblock}

    std::suspend_always yield_value(const Ref& x) {
        auto &root = rootOrLeaf_.promise();
        root.valuePtr_ = std::addressof(x);
        return {};
    }

    std::suspend_always yield_value(Ref& x) {
        auto &root = rootOrLeaf_.promise();
        root.valuePtr_ = std::addressof(x);
        return {};
    }

    template<typename T = std::remove_cvref_t<Ref>>
    requires !is_reference_v<Ref> && is_constructible_v<Ref, T>
    auto yield_value(T&& x) {
        struct yield_value_holder {
            Ref ref;

            bool await_ready() noexcept { return false; }

            template<typename Promise>
            void await_suspend(coroutine_handle<Promise> h) noexcept {
                h.promise().valuePtr_ = addressof(ref);
            }
            void await_resume() noexcept {}
        };
        return yield_value_holder{forward<T>(x)};
    }
\end{colorblock}


A drawback of this solution is that the yielded value is only destroyed at the end of the
full expression:
\begin{colorblock}
    (co_yield x, co_yield y); // x is destroyed after y is yielded.
\end{colorblock}

We think this is a reasonable tradeoff as it avoids a copy.
Further optimization could be done to copy small values - and avoid an indirection.
But it is unclear what the cost of this indirection is, as none of these accesses should result in cache misses).

To support this implementation strategy, the wording does not specify a type for the return value of \tcode{yield_value}.


\subsection{Recursive generator}

A "recursive generator" is a coroutine that supports the ability to directly \tcode{co_yield}
a generator of the same type as a way of emitting the elements of that \tcode{generator}
as elements of the current \tcode{generator}.

Example: A \tcode{generator} can \tcode{co_yield} other generators of the same type
\begin{colorblock}
    generator<const std::string&> delete_rows(std::string table, std::vector<int> ids) {
        for (int id : ids) {
            co_yield std::format("DELETE FROM {0} WHERE id = {1}", table, id);
        }
    }

    generator<const std::string&> all_queries() {
        co_yield elements_of(delete_rows("user", {4, 7, 9 10}));
        co_yield elements_of(delete_rows("order", {11, 19}));
    }
\end{colorblock}

Example: A \tcode{generator} can also be used recursively
\begin{colorblock}
    struct Tree {
        Tree* left;
        Tree* right;
        int value;
    };

    generator<int> visit(Tree& tree) {
        if (tree.left) co_yield elements_of(visit(*tree.left));
        co_yield tree.value;
        if (tree.right) co_yield elements_of(visit(*tree.right));
    }
\end{colorblock}

In addition to being more concise, the ability to directly yield a nested generator has some
performance benefits compared to iterating over the contents of the nested generator and
manually yielding each of its elements.

Yielding a nested \tcode{generator} allows the consumer of the top-level coroutine to
directly resume the current leaf generator when incrementing the iterator, whereas a solution that has each generator manually iterating over elements of the child generator
requires O(depth) coroutine resumptions/suspensions per element of the sequence.

Example: Non-recursive form incurs O(depth) resumptions/suspensions per element
and is more cumbersome to write

\begin{colorblock}
    generator<int> slow_visit(Tree& tree) {
        if (tree.left) {
            for (int x : elements_of(visit(*tree.left)))
            co_yield x;
        }
        co_yield tree.value;
        if (tree.right) {
            for (int x : elements_of(visit(*tree.right)))
            co_yield x;
        }
    }
\end{colorblock}

Exceptions that propagate out of the body of nested \tcode{generator} coroutines
are rethrown into the parent coroutine from the \tcode{co_yield} expression rather
than propagating out of the top-level \tcode{iterator::operator++()}. This follows the mental model that  \tcode{co_yield someGenerator} is semantically equivalent to manually
iterating over the elements and yielding each element.

For example: \tcode{nested_ints()} is semantically equivalent to \tcode{manual_ints()}
\begin{colorblock}
    generator<int> might_throw() {
        co_yield 0;
        throw some_error{};
    }

    generator<int> nested_ints() {
        try {
            co_yield elements_of(might_throw());
        } catch (const some_error&) {}
        co_yield 1;
    }

    // nested_ints() is semantically equivalent to the following:
    generator<int> manual_ints() {
        try {
            for (int x : might_throw()) {
                co_yield x;
            }
        } catch (const some_error&) {}
        co_yield 1;
    }

    void consumer() {
        for (int x : nested_ints()) {
            std::cout << x << " "; // outputs 0 1
        }

        for (int x : manual_ints()) {
            std::cout << x << " "; // also outputs 0 1
        }
    }
\end{colorblock}

\subsection{\tcode{elements_of}}

\tcode{elements_of} is a utility function that prevents ambiguity when a nested generator type is convertible to the value type
of the present generator

\begin{colorblock}
    generator<int> f()
    {
        co_yield 42;
    }

    generator<any> g()
    {
        co_yield f(); // should we yield 42 or generator<int> ?
    }

\end{colorblock}

To avoid this issue, we propose that:

\begin{itemize}
    \item \tcode{co_yield <expression>} always yield the value directly.
    \item \tcode{co_yield elements_of(<expression>)} yield the values of the nested generator.
\end{itemize}


For convenience, we further propose that \tcode{co_yield elements_of(x)} be extended to support
yielding the values of arbitrary ranges beyond generators, ie

\begin{colorblock}
    generator<int> f()
    {
        std::vector<int> v = /*... */;
        co_yield elements_of(v);
    }

\end{colorblock}

\subsection{Symmetric transfer}

The recursive form can be implemented efficiently with symmetric transfer.
Earlier works in \cite{CppCoro} implemented this feature in a distinct \tcode{recursive_generator} type.

However, it appears that a single type is reasonably efficient thanks to HALO optimizations and symmetric transfer.
The memory cost of that feature is three extra pointers per generator.
It is difficult to evaluate the runtime cost of our design given the current coroutine support in compilers.
However our tests show no noticeable difference between a \tcode{generator} and a \tcode{recursive_generator}
which is called non-recursively. It is worth noting that the proposed design makes sure that HALO \cite{P0981R0} optimizations are possible.

While we think a single \tcode{generator} type is sufficient and offers a better API, there are three options:

\begin{itemize}
    \item A single \tcode{generator} type supporting recursive calls (this proposal).

    \item A separate type \tcode{recursive_generator} that can yield values from either \tcode{recursive_generator} or a \tcode{generator}. That may offer very negligible performance benefits, same memory usage.

    \item A separate {recursive_generator} type which can only yield values from other \tcode{recursive_generator}.

    That third option would make the following ill-formed:

    \begin{colorblock}
        generator<int> f();
        recursive_generator<int> g() {
            co_yield f(); // incompatible types
        }
    \end{colorblock}

    Instead you would need to write:
    \begin{colorblock}
        recursive_generator<int> g() {
            for (int x : f()) co_yield x;
        }
    \end{colorblock}

    Such a limitation can make it difficult to decide at the time of writing a generator
    coroutine whether or not you should return a \tcode{generator} or \tcode{recursive_generator}
    as you may not know at the time whether or not this particular generator will be used
    within \tcode{recursive_generator} or not.

    If you choose the \tcode{generator} return-type and then later someone wants to yield its
    elements from a \tcode{recursive_generator} then you either need to manually yield its
    elements one-by-one or use a helper function that adapts the \tcode{generator} into a
    \tcode{recursive_generator}. Both of these options can add runtime cost compared to the case where the generator was originally written to return a \tcode{recursive_generator},
    as it requires two coroutine resumptions per element instead of a single coroutine resumption.

    Because of these limitations, we are not recommending this approach.
\end{itemize}

Symmetric transfer is possible for different generator types as long as the \tcode{reference} type is the same, aka,
different value type or allocator type does not preclude symmetric transfer (see the section on allocators).

\section{Allocator support}

In line with the design exploration done in section 2 of \paper{P1681R0}, \tcode{std::generator} can support both stateless and stateful allocators and strive to minimize the interface verbosity for stateless allocators by templating both the generator itself and the \tcode{promise_type}'s \tcode{new} operator
on the allocator type. Details for this interface are found in \paper{P1681R0}.

\tcode{coroutine_parameter_preview_t} such as discussed in section 3 of \paper{P1681R0} has not been explored in this paper.

\begin{colorblock}
    std::generator<int> stateless_example() {
        co_yield 42;
    }

    template <class Allocator>
    std::generator<int>
    allocator_example(std::allocator_arg_t, Allocator alloc) {
        co_yield 42;
    }

    my_allocator<std::byte> alloc;
    input_range auto rng = allocator_example<my_allocator<std::byte>>(std::allocator_arg, alloc);

\end{colorblock}

The proposed interface requires that, if an allocator is provided, it is the second argument to the coroutine function,
immediately preceded by an instance of \tcode{std::allocator_arg_t}.
This approach is necessary to distinguish the allocator desired to allocate the coroutine state from allocators whose purpose is to be used in the body of the coroutine function.
The required argument order might be a limitation if any other argument is required to be the first. However, we cannot think of any scenario where that would be the case.

We think it is important that all standard and user coroutines types can accommodate similar interfaces for allocator support.
In fact, the implementation for that allocator support can be shared amongst \tcode{generator}, \tcode{lazy}, and other standard types.


\textbf{By default \tcode{std::generator} type erases the allocator type, and uses \tcode{std::allocator} unless an allocator is provided to
the coroutine function}.
Then:

\textbf{Type erased allocator(default)}

\begin{colorblock}
template <class Allocator>
std::generator<int> f(std::allocator_arg_t, Allocator alloc) {}

f(std::allocator_arg, my_alloc{});
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, void>} where \tcode{void} denotes that the allocator is type erased.
The allocator is store on the coroutine state if it is stateful or not default constructible; a pointer is always stored so that the \tcode{deallocate} method of the type erased allocator can be called.


\textbf{No allocator}

\begin{colorblock}
std::generator<int> f() {}
f();
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, void>} where \tcode{void} denotes that the allocator is type erased.
A pointer is stored so that the \tcode{deallocate} method of the type erased allocator can be called. The allocator is \tcode{std::allocator} and is not stored on the frame (because it is stateless)

\textbf{Explicit stateless allocator}

\begin{colorblock}
std::generator<int, int, std::stateless_allocator<int>> f() {}
f();
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, std::stateless_allocator<int>>}
No extra storage is used for the allocator because it is stateless.

\textbf{Explicit stateful allocator}

\begin{colorblock}
std::generator<int, int, some_statefull_allocator<int>>
    f(std::allocator_arg_t,  some_statefull_allocator<int> alloc) {}
f(std::allocator_arg, some_allocator); // must be convertible to some_statefull_allocator
\end{colorblock}

Returns a generator of type \tcode{std::generator<int, int, some_statefull_allocator<int>>}
The allocator is copied in the coroutine state.


\subsection{Interaction with symmetric transfer and allocator support}

The allocator must be part of the promise type.
Our implementation uses a base class so that generators of different allocator types can yield each other.
This leaves with two implementation strategies
\begin{itemize}
\item Storing a pointer to the base class in the promise handle
\item Leave implementers find the best implementation strategy and can bell their own implementation to be well-formed
\item Modify the wording as follow to allow \tcode{coroutine_handle<promise_base>::from_address(coro.address());} to be well-formed:
\end{itemize}

To support yielding nested generator of different allocator types we then have several options:
\begin{itemize}
\item Leaving implementers find the best strategy with compiler magic
\item Modify from_address to allow construcruction from a coroutine of layout compatible type
\end{itemize}
\begin{quote}
\indexlibrarymember{from_address}{coroutine_handle}%
\begin{itemdecl}
static constexpr coroutine_handle<Promise> coroutine_handle<Promise>::from_address(void* addr);
\end{itemdecl}

\begin{itemdescr}
\expects
\tcode{addr} was obtained via a prior call to \tcode{address}
on an object of type \cv \changed{\tcode{coroutine_handle<Promise>}}{of type \cv \tcode{coroutine_Â­handle<T}> where\tcode{T} is any type such that \tcode{is_layout_compatible_v<T, Promise>} is \tcode{true}}.
\end{itemdescr}
\end{quote}

Supporting allocators requires storing, in all cases, a function pointer adjacent to the coroutine state (to track a deallocation function),
along with the allocator itself in the case of stateful allocators.


\subsection{Can we postpone adding support for allocator later?}

A case can be made that allocator support could be added to \tcode{std::generator} later.
However, because the proposed design has the allocator as a template parameter,
adding allocator after \tcode{std::generator} ships would represent an ABI break.
We recommend that we add allocator support as proposed in this paper now and make sure that the design remains consistent as work on \tcode{std::lazy}
is made in this cycle.
However, it would be possible to extend support for different mechanisms (such as presented in section 3 of \paper{P1681R0} later.

\section{Implementation and experience}

\tcode{generator} has been provided as part of cppcoro and folly.
However, cppcoro offers a separate \tcode{recursive_generator} type, which is different than the proposed design.

Folly uses a single \tcode{generator} type, which can be recursive but doesn't implement symmetric transfer. Despite that,
Folly users found the use of \tcode{Folly:::Generator} to be a lot more efficient than the eager algorithm they replaced with it.

\tcode{ranges-v3} also implements a \tcode{generator} type, which is never recursive and predates the work on move-only views and
iterators \cite{P1456R1}, \cite{P1207R0} which forces this implementation to ref-count the coroutine handler.

Our implementation \cite{Implementation} consists of a single type that takes advantage of symmetric transfer to implement
recursion.

\section{Performance \& benchmarks}

Because implementations are still being perfected, and because performance is extremely dependent on whether HALO optimization (see \paper{P0981R1})
occurs, it is difficult at this time to make definitive statements about the performance of the proposed design.

At the time of the writing of this paper, Clang is able to inline non-nested coroutines whether the implementation
supports nested coroutines or not, while GCC never performs HALO optimization.

When the coroutine is not inlined, support for recursion does not noticeably impact performance.
And, when the coroutine yields another generator, the performance of the recursive version is noticeably faster than
yielding each element of the range. This is especially noticeable with deep recursion.

\begin{adjustbox}{center}
\texttt{
\begin{threeparttable}
\begin{tabular}{|l?r|r?r|r?r|r|}
    \hline
    & Clang & Clang ST\tnote{1} & GCC & GCC ST\tnote{1} & MSVC & MSVC ST\tnote{1} \\
    \hline
    Single value & (1) 0.235 &  (2) 2.36 & 12.4 & 13.4 & 61.9 & 63.7 \\
    \hline
    Single value, noinline (3) & 13.5  & 13.7 & 14.1 & 15.2 & 63.8 & 64.4\\
    \hline
    Deep nesting & 43670266.0 & (4) 427955.0 & 58801348 & 338736 & 224052033 & 4760914\\
    \hline
\end{tabular}
\begin{tablenotes}
\item[1] Symmetric transfer.
\end{tablenotes}
\end{threeparttable}
}
\end{adjustbox}


The values are expressed in nanoseconds. However, please note that the comparison of the same result across compiler is not meaningful, notably because the MSVC results were obtained on different hardware.
That being said, we observe:

\begin{itemize}
    \item Only Clang can perform constant folding of values yielded by simple coroutine (1)
    \item When the \tcode{generator} supports symmetric transfer, clang is not able to fully inline the generator construction, but HALO is still performed (2).
    \item When HALO is not performed, the relative performance of both approaches is similar (3).
    \item Supporting recursion is greatly beneficial to nested/recursive algorithms (4).
\end{itemize}

The code for these benchmarks, as well as more detailed results, can be found on \href{https://github.com/cor3ntin/coro_benchmark}{Github}.


\section{Wording}

The following wording is meant to illustrate the proposed API.



\rSec2[ranges.syn]{Header \tcode{<ranges>} synopsis}

\begin{codeblock}

namespace std::ranges {

...

template<@\libconcept{input_or_output_iterator}@ I, @\libconcept{sentinel_for}@<I> S, subrange_kind K>
inline constexpr bool enable_borrowed_range<subrange<I, S, K>> = true;

// \ref{range.dangling}, dangling iterator handling
struct dangling;

\end{codeblock}

\begin{addedblock}
\begin{codeblock}
template<std::ranges::input_range R, class Allocator = std::allocator<std::byte>>
struct elements_of;
\end{codeblock}
\end{addedblock}
\begin{codeblock}
template<@\libconcept{range}@ R>
using borrowed_iterator_t = conditional_t<@\libconcept{borrowed_range}@<R>, iterator_t<R>, dangling>;

...

}

\end{codeblock}


\begin{addedblock}

\rSec2[ranges.elementsof]{ranges::element_of}


\tcode{elements_of} is a template that encapsulates a range and acts as a tag in overload sets to disambiguate when a range should be treated as a sequence rather than a single value in generic contexts.

\begin{example}
    \begin{codeblock}
        generator<any> f(input_range auto&& rng) {
            co_yield rng; // yield rng as a single value
            co_yield elements_of(rng); // yield each element of rng
        }
    \end{codeblock}
\end{example}


\begin{codeblock}
namespace std::ranges {
    template<std::ranges::input_range R, class Allocator = std::allocator<std::byte>>
    struct elements_of {
        private:
        [[no_unique_address]] Allocator allocator_; // \expos
        R&& range_; // \expos

        public:
        explicit constexpr elements_of(R&& r) noexcept
        requires std::is_default_constructible_v<Allocator>;

        explicit constexpr elements_of(R&& r, Allocator allocator) noexcept;

        constexpr elements_of(elements_of&&) = default;

        elements_of(const elements_of&) = delete;

        constexpr R&& range() noexcept;
        constexpr Allocator get_allocator() const noexcept;
    };
    template<std::ranges::input_range R>
    elements_of(R&&) -> return elements_of<R>;

    template<std::ranges::input_range R, typename Allocator>
    elements_of(R&&, Allocator) -> elements_of<R, Allocator>;
}
\end{codeblock}

\rSec2[ranges.elementsof.cons]{ranges::elements_of Constructors}

\begin{itemdecl}
explicit constexpr elements_of(R&& r) noexcept
requires std::is_default_constructible_v<Allocator>
\end{itemdecl}

\begin{itemdescr}
\effects   Initializes \tcode{range_} with \tcode{std::forward<R>(r)}.
\end{itemdescr}


\begin{itemdecl}
explicit constexpr elements_of(R&& r, Allocator allocator) noexcept
\end{itemdecl}

\begin{itemdescr}
\effects   Initializes \tcode{range_} with \tcode{std::forward<R>(r)} and \tcode{allocator_} with \tcode{std::move(allocator)}.
\end{itemdescr}

\rSec2[ranges.elementsof.access]{ranges::elements_of Access}

\begin{itemdecl}
constexpr R&& range() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{std::forward<R>(range_)}.
\end{itemdescr}

\begin{itemdecl}
constexpr Allocator get_allocator() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{allocator_}.
\end{itemdescr}

\pagebreak

\rSec2[generator.syn]{Header \tcode{<generator>} synopsis}


\begin{codeblock}

#include <coroutine>
#include <ranges>

namespace std {

    template<class Ref,
        class Value = remove_cvref_t<Ref>,
        class Allocator = void>
    class generator;

    template <class Ref, class Value, class Allocator>
    inline constexpr bool ranges::enable_view<generator<Ref, Value, Allocator>> = true;
}

\end{codeblock}


\rSec2[coroutine.generator]{Generator View}

\rSec3[coroutine.generator.overview]{Overview}


\tcode{generator} generates a sequence of elements by repeatedly resuming the coroutine it was returned from.
When the coroutine is resumed, it is executed until it reaches either a \tcode{co_yield} expression or the end of the coroutine.

Elements of the sequence are produced by the coroutine each time a \tcode{co_yield} expression is evaluated.

When the \tcode{co_yield} expression is of the form \tcode{co_yield elements_of(rng)}, each element of the range \tcode{rng} is successively produced
as an element of the generator.

\tcode{generator} models \tcode{view} and \tcode{input_range}.


\begin{example}
    \begin{codeblock}
        generator<int> iota(int start = 0) {
            while(true)
                co_yield start++;
        }

        void f() {
            for(auto i : iota() | views::take(3))
            cout << i << " " ; // prints 0 1 2
        }

    \end{codeblock}
\end{example}


\rSec3[coroutine.generator.class]{Class template \tcode{generator}}

\begin{codeblock}

namespace std {

template <class Ref, Value = remove_cvref_t<Ref>,
          class Allocator = void>
requires  common_reference_with<Ref&&, value&>
class generator  {
    class promise_type_; // \expos

public:
    using promise_type = promise_type_;

    class iterator; // \expos

    generator(const generator &other) = delete;
    generator(generator && other) noexcept;

    ~generator();

    generator &operator=(generator&& other) noexcept;

    iterator begin();
    default_sentinel_t end() const noexcept;

private:
    std::coroutine_handle<promise_type> coroutine_ = nullptr; // \expos
    bool started_ = false; // \expos

    explicit generator(std::coroutine_handle<promise_type> coroutine) noexcept; // \expos

};
}


\end{codeblock}

\begin{itemize}
\item \tcode{coroutine_traits<generator<Ref, Value, Allocator>>::promise_type} is valid an denotes a type,
\item \tcode{Allocator} either meets the \tcode{Cpp17Allocator} requirements or is \tcode{void}.
\end{itemize}

\begin{itemdecl}
generator(std::coroutine_handle<promise_type> coro) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{coroutine_} with \tcode{coro}.
\end{itemdescr}



\begin{itemdecl}
generator(generator &&other) noexcept;
\end{itemdecl}

\begin{itemdescr}
Initializes \tcode{coroutine_} with \tcode{exchange(other.coroutine_, \{\})}, \\and \tcode{started_} with \tcode{exchange(other.started_, false)}.
\end{itemdescr}

\begin{itemdecl}
~generator();
\end{itemdecl}

\begin{itemdescr}
    \effects equivalent to:
    \begin{codeblock}
    if (started_ && !coroutine_.done()) {
        coroutine_.promise().destruct_value_();
    }
    coroutine_.destroy();
    \end{codeblock}
\end{itemdescr}

\begin{itemdecl}
generator &operator=(generator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects equivalent to:
\begin{codeblock}
    swap(coro_, other.coro_);
    swap(started_, other.started_);
\end{codeblock}
\end{itemdescr}



\begin{itemdecl}
iterator begin();
\end{itemdecl}


\begin{itemdescr}
\preconditions
\begin{itemize}
\item \tcode{coroutine_} refers to a coroutine
suspended at its initial suspend-point,
\item \tcode{started_} is false.
\end{itemize}

\effects
Equivalent to:
\begin{codeblock}
    started_ = true;
    coroutine_.resume();
    return iterator(coroutine_);
\end{codeblock}

\begin{note}
    It is undefined behavior to call \tcode{begin} multiple times on the same coroutine.
\end{note}
\end{itemdescr}


\begin{itemdecl}
default_sentinel_t end() const noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{default_sentinel_t\{\}}.
\end{itemdescr}


\rSec3[coroutine.generator.promise]{Exposition-only class template \tcode{generator::promise_type_}}

\begin{codeblock}

template <class Ref, class Value, class Allocator>
class generator<Ref, Value, Allocator>::promise_type_ {

    friend generator;

    // \textbf{This doesn't work if a Ref is a reference type}
    // \textbf{we either need some kind of wrapper (see manual_lifetime in our \\   implementation, or only store a pointer in all cases)}

    union {
        Ref value_; // \expos
    };

    void destruct_value_() { // \expos
        if constexpr(!is_lvalue_reference_v<Ref>) {
            value_.~decay_t<Ref>();
    }

public:

    generator<Ref, Value, Allocator> get_return_object() noexcept;

    suspend_always initial_suspend() noexcept;

    auto final_suspend() noexcept;

    @\unspec@ yield_value(const Ref & value)
    noexcept(is_nothrow_move_constructible_v<Ref>);

    template <class T>
    requires is_convertible_v<T, Ref>
    @\unspec@ yield_value(T&& x) noexcept(is_nothrow_constructible_v<Ref, T>);

    template <class TVal, class TAlloc>
    @\unspec@ yield_value(elements_of<generator<Ref, TVal, TAlloc>> g) noexcept; // \seebelownc

    template<ranges::input_range R, typename Allocator>
    requires convertible_to<ranges::range_reference_t<R>, Ref>
    @\unspec@ yield_value(elements_of<R, Allocator> rng); // \seebelownc

    void await_transform() = delete;

    void return_void() noexcept {};

    void unhandled_exception();

    static void* operator new(size_t size) requires same_as<Allocator, void>;
    static void* operator new(size_t size) requires (!same_as<Allocator, void> && is_default_constructible_v<Allocator>);

    template<typeame Alloc, class... Args>
    static void* operator new(size_t size, allocator_arg_t, Alloc& alloc, Args&...);

    template<class This, typeame Alloc, class... Args>
    static void* operator new(size_t size, This&, allocator_arg_t, Alloc& alloc, Args&...);

    static void operator delete(void* pointer, size_t size) noexcept;
};
\end{codeblock}




\begin{itemdecl}
generator<Ref, Value, Allocator> get_return_object() noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to:
\begin{codeblock}
    return generator<Ref, Value, Allocator>{
        coroutine_handle<promise_type>::from_promise(*this)};
\end{codeblock}
\end{itemdescr}

\begin{itemdecl}
suspend_always initial_suspend() noexcept;
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{suspend_always\{\}}.
\end{itemdescr}


\begin{itemdecl}
@\unspec@ yield_value(const Ref& x)
    noexcept(is_nothrow_move_constructible_v<Ref>);
\end{itemdecl}
\begin{itemdecl}
template <class T>
requires is_convertible_v<T, Ref>
@\unspec@ yield_value(T&& x)
    noexcept(is_nothrow_constructible_v<Ref, T>);
\end{itemdecl}

\begin{itemdescr}
\effects
Initialises \tcode{value_} from \tcode{static_cast<decltype(x)>(x)};
\returns An implementation-defined awaitable type.

\end{itemdescr}


\begin{itemdecl}
template <class TVal, class TAlloc>
auto yield_value(elements_of<generator<Ref, TVal, TAlloc>> g) noexcept;
\end{itemdecl}

\begin{itemdescr}

\mandates
\begin{itemize}
\item \tcode{TAlloc} meets the \tcode{Cpp17Allocator} requirements,
\end{itemize}

\effects
Execution is transferred to the coroutine represented by \tcode{g.coroutine_} until its completion.
After \tcode{g.coroutine_} completes, the current coroutine is resumed.
If \tcode{g.coroutine_} completes with an exception, the exception is rethrown from the `co_yield` expression.

Variables with automatic storage duration in the scope of the coroutine represented by \tcode{g.coroutine_} are destroyed
before variables with automatic storage duration in the scope of the coroutine denoted by this coroutine.

\begin{note}
Generators can transfer control recursively.
\end{note}

\returns An implementation defined \tcode{awaitable} type which takes ownership of the generator \tcode{g}.

\end{itemdescr}


\begin{itemdecl}
template<std::ranges::input_range R, typename Allocator>
requires convertible_to<ranges::range_reference_t<R>, Ref>
auto yield_value(elements_of<R, Allocator> rng);
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to:
\begin{codeblock}
{
    return yield_value(std::ranges::elements_of([](R&& rng, allocator_arg_t, Allocator alloc)
    -> generator<Ref, Value, Allocator> {
        auto it = std::ranges::begin(rng);
        auto itEnd = std::ranges::end(rng);
        while (it != itEnd) {
            co_yield *it;
            ++it;
        }
    }(std::rng.range()), rng.get_allocator())));
}
\end{codeblock}

The return object is of an implementation defined type T such that
\tcode{is_same_v<coroutine_traits<T>::promise_type, coroutine_traits<generator>::promise_type>} is \tcode{true}.

\end{itemdescr}

\begin{itemdecl}
void unhandled_exception();
\end{itemdecl}

\begin{itemdescr}
\effects Equivalent to: \tcode{throw;}
\end{itemdescr}

\begin{itemdecl}
static void* operator new(size_t size) requires same_as<Allocator, void>;
\end{itemdecl}

\begin{itemdescr}
\effects Allocates the coroutine state with \tcode{std::allocator}.
\end{itemdescr}

\begin{itemdecl}
static void* operator new(size_t size) requires (!same_as<Allocator, void> && is_default_constructible_v<Allocator>);
\end{itemdecl}

\begin{itemdescr}
\effects Allocates the coroutine state with a default-constructed instance of \tcode{Allocator}.
\end{itemdescr}


\begin{itemdecl}
template<typeame Alloc, class... Args>
static void* operator new(size_t size, allocator_arg_t, Alloc& alloc, Args&...);

template<class This, typeame Alloc, class... Args>
static void* operator new(size_t size, This&, allocator_arg_t, Alloc& alloc, Args&...);
\end{itemdecl}

\begin{itemdescr}

\mandates
\begin{itemize}
\item \tcode{same_as<Allocator, void> || convertible_to<Alloc, Allocator>} is \tcode{true},
\item \tcode{Alloc} meets the \tcode{Cpp17Allocator} requirements,
\end{itemize}

\effects Allocates the coroutine state with \tcode{Alloc}.

\begin{note}
If \tcode{std::allocator_traits<Alloc>::is_always_equal::value} is \tcode{false} or if \tcode{is_default_constructible_v<Alloc>} is \tcode{false}, \tcode{alloc} is stored in the allocation for the coroutine state.
\end{note}

\end{itemdescr}

\begin{itemdecl}
static void operator delete(void* pointer, size_t size) noexcept;
\end{itemdecl}

\begin{itemdescr}
Deallocate the coroutine state with an instance of the allocator equivalent to the one that was used to allocate it.
\end{itemdescr}

\rSec3[coroutine.generator.iterator]{Class template \tcode{generator::iterator}}

\begin{codeblock}

template <class Ref, class Value, class Allocator>
class generator<Ref, Value, Allocator>::iterator {
private:
    std::coroutine_handle<promise_type> coroutine_; // \expos

public:
    using iterator_category = std::input_iterator_tag;
    using difference_type = std::ptrdiff_t;
    using value_type = promise_type::value_type;
    using reference = promise_type::reference;

    iterator(const iterator&) = delete;

    iterator(iterator&& other) noexcept;

    iterator& operator=(iterator&& other) noexcept;



    bool operator==(default_sentinel_t) const noexcept;

    iterator& operator++();
    void operator++(int);

    reference operator*() const noexcept(std::is_nothrow_copy_constructible_v<reference>);

private:
    friend class generator<Ref, Value, Allocator>;
    explicit iterator(std::coroutine_handle<promise_type> coroutine) noexcept; // \expos
};

\end{codeblock}

\begin{itemdecl}
 iterator(iterator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{coroutine_} with \tcode{exchange(other.coroutine_, \{\})}.
\end{itemdescr}


\begin{itemdecl}
iterator& operator=(iterator&& other) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Equivalent to \tcode{coroutine_ = exchange(other.coroutine_, \{\});}
\end{itemdescr}

\begin{itemdecl}
explicit iterator(std::coroutine_handle<promise_type> coroutine) noexcept;
\end{itemdecl}

\begin{itemdescr}
\effects
Initializes \tcode{coroutine_} with \tcode{coroutine}.
\end{itemdescr}


\begin{itemdecl}
bool operator==(default_sentinel_t) const noexcept
\end{itemdecl}

\begin{itemdescr}
\returns \tcode{coroutine_.done()}.
\end{itemdescr}

\begin{itemdecl}
iterator& operator++();
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{!coroutine_.done()} is \tcode{true}.

% \effects

\returns \tcode{return *this};

\end{itemdescr}
\begin{itemdecl}
void operator++(int);
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{!coroutine_.done()} is \tcode{true}.

\effects
Equivalent to:
\begin{codeblock}
    (void)operator++();
\end{codeblock}
\end{itemdescr}


\begin{itemdecl}
reference operator*() const
noexcept (noexcept(std::is_nothrow_copy_constructible_v<reference>));
\end{itemdecl}

\begin{itemdescr}
\precondition \tcode{!coroutine_.done()} is \tcode{true}.

\effects
Equivalent to:
\begin{codeblock}
    return coroutine_.promise().value_;
\end{codeblock}
\end{itemdescr}


\end{addedblock}

\section{Feature test macros}

Insert into [version.syn]

\begin{addedblock}
\begin{codeblock}
    #define __cpp_lib_generator <DATE OF ADOPTION> // also in <ggenerator>
\end{codeblock}
\end{addedblock}


\section{References}
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{wg21}

\begin{thebibliography}{9}
    \bibitem[CppCoro]{CppCoro}
    Lewis Baker
    \emph{CppCoro: A library of C++ coroutine abstractions for the coroutines TS}\newline
    \url{https://github.com/lewissbaker/cppcoro}

    \bibitem[Folly]{Folly}
    Facebook
    \emph{Folly: An open-source C++ library developed and used at Facebook}\newline
    \url{https://github.com/facebook/folly}


    \bibitem[range]{range-v3}
    Eric Niebler
    \emph{range-v3 Range library for C++14/17/20}\newline
    \url{https://github.com/ericniebler/range-v3}

    \bibitem[Implementation]{Implementation}
    Lewis Baker, Corentin Jabot
    \emph{\tcode{std::generator} implementation}\newline
    \url{https://godbolt.org/z/T58h1W}

    \bibitem[N4861]{N4861}
    Richard Smith
    \emph{Working Draft, Standard for Programming Language C++}\newline
    \url{https://wg21.link/N4861}


\end{thebibliography}

\end{document}
